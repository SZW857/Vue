{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// The `sfnt` wrapper provides organization for the tables in the font.\n// It is the top-level data structure in a font.\n// https://www.microsoft.com/typography/OTSPEC/otff.htm\n// Recommendations for creating OpenType Fonts:\n// http://www.microsoft.com/typography/otspec140/recom.htm\n\nimport check from '../check';\nimport table from '../table';\nimport cmap from './cmap';\nimport cff from './cff';\nimport head from './head';\nimport hhea from './hhea';\nimport hmtx from './hmtx';\nimport ltag from './ltag';\nimport maxp from './maxp';\nimport _name from './name';\nimport os2 from './os2';\nimport post from './post';\nimport gsub from './gsub';\nimport meta from './meta';\nfunction log2(v) {\n  return Math.log(v) / Math.log(2) | 0;\n}\nfunction computeCheckSum(bytes) {\n  while (bytes.length % 4 !== 0) {\n    bytes.push(0);\n  }\n  let sum = 0;\n  for (let i = 0; i < bytes.length; i += 4) {\n    sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];\n  }\n  sum %= Math.pow(2, 32);\n  return sum;\n}\nfunction makeTableRecord(tag, checkSum, offset, length) {\n  return new table.Record('Table Record', [{\n    name: 'tag',\n    type: 'TAG',\n    value: tag !== undefined ? tag : ''\n  }, {\n    name: 'checkSum',\n    type: 'ULONG',\n    value: checkSum !== undefined ? checkSum : 0\n  }, {\n    name: 'offset',\n    type: 'ULONG',\n    value: offset !== undefined ? offset : 0\n  }, {\n    name: 'length',\n    type: 'ULONG',\n    value: length !== undefined ? length : 0\n  }]);\n}\nfunction makeSfntTable(tables) {\n  const sfnt = new table.Table('sfnt', [{\n    name: 'version',\n    type: 'TAG',\n    value: 'OTTO'\n  }, {\n    name: 'numTables',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'searchRange',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'entrySelector',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'rangeShift',\n    type: 'USHORT',\n    value: 0\n  }]);\n  sfnt.tables = tables;\n  sfnt.numTables = tables.length;\n  const highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n  sfnt.searchRange = 16 * highestPowerOf2;\n  sfnt.entrySelector = log2(highestPowerOf2);\n  sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n  const recordFields = [];\n  const tableFields = [];\n  let offset = sfnt.sizeOf() + makeTableRecord().sizeOf() * sfnt.numTables;\n  while (offset % 4 !== 0) {\n    offset += 1;\n    tableFields.push({\n      name: 'padding',\n      type: 'BYTE',\n      value: 0\n    });\n  }\n  for (let i = 0; i < tables.length; i += 1) {\n    const t = tables[i];\n    check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n    const tableLength = t.sizeOf();\n    const tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n    recordFields.push({\n      name: tableRecord.tag + ' Table Record',\n      type: 'RECORD',\n      value: tableRecord\n    });\n    tableFields.push({\n      name: t.tableName + ' table',\n      type: 'RECORD',\n      value: t\n    });\n    offset += tableLength;\n    check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n    while (offset % 4 !== 0) {\n      offset += 1;\n      tableFields.push({\n        name: 'padding',\n        type: 'BYTE',\n        value: 0\n      });\n    }\n  }\n\n  // Table records need to be sorted alphabetically.\n  recordFields.sort(function (r1, r2) {\n    if (r1.value.tag > r2.value.tag) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n  sfnt.fields = sfnt.fields.concat(recordFields);\n  sfnt.fields = sfnt.fields.concat(tableFields);\n  return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n  for (let i = 0; i < chars.length; i += 1) {\n    const glyphIndex = font.charToGlyphIndex(chars[i]);\n    if (glyphIndex > 0) {\n      const glyph = font.glyphs.get(glyphIndex);\n      return glyph.getMetrics();\n    }\n  }\n  return notFoundMetrics;\n}\nfunction average(vs) {\n  let sum = 0;\n  for (let i = 0; i < vs.length; i += 1) {\n    sum += vs[i];\n  }\n  return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n  const xMins = [];\n  const yMins = [];\n  const xMaxs = [];\n  const yMaxs = [];\n  const advanceWidths = [];\n  const leftSideBearings = [];\n  const rightSideBearings = [];\n  let firstCharIndex;\n  let lastCharIndex = 0;\n  let ulUnicodeRange1 = 0;\n  let ulUnicodeRange2 = 0;\n  let ulUnicodeRange3 = 0;\n  let ulUnicodeRange4 = 0;\n  for (let i = 0; i < font.glyphs.length; i += 1) {\n    const glyph = font.glyphs.get(i);\n    const unicode = glyph.unicode | 0;\n    if (isNaN(glyph.advanceWidth)) {\n      throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n    }\n    if (firstCharIndex > unicode || firstCharIndex === undefined) {\n      // ignore .notdef char\n      if (unicode > 0) {\n        firstCharIndex = unicode;\n      }\n    }\n    if (lastCharIndex < unicode) {\n      lastCharIndex = unicode;\n    }\n    const position = os2.getUnicodeRange(unicode);\n    if (position < 32) {\n      ulUnicodeRange1 |= 1 << position;\n    } else if (position < 64) {\n      ulUnicodeRange2 |= 1 << position - 32;\n    } else if (position < 96) {\n      ulUnicodeRange3 |= 1 << position - 64;\n    } else if (position < 123) {\n      ulUnicodeRange4 |= 1 << position - 96;\n    } else {\n      throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n    }\n    // Skip non-important characters.\n    if (glyph.name === '.notdef') continue;\n    const metrics = glyph.getMetrics();\n    xMins.push(metrics.xMin);\n    yMins.push(metrics.yMin);\n    xMaxs.push(metrics.xMax);\n    yMaxs.push(metrics.yMax);\n    leftSideBearings.push(metrics.leftSideBearing);\n    rightSideBearings.push(metrics.rightSideBearing);\n    advanceWidths.push(glyph.advanceWidth);\n  }\n  const globals = {\n    xMin: Math.min.apply(null, xMins),\n    yMin: Math.min.apply(null, yMins),\n    xMax: Math.max.apply(null, xMaxs),\n    yMax: Math.max.apply(null, yMaxs),\n    advanceWidthMax: Math.max.apply(null, advanceWidths),\n    advanceWidthAvg: average(advanceWidths),\n    minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n    maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n    minRightSideBearing: Math.min.apply(null, rightSideBearings)\n  };\n  globals.ascender = font.ascender;\n  globals.descender = font.descender;\n  const headTable = head.make({\n    flags: 3,\n    // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n    unitsPerEm: font.unitsPerEm,\n    xMin: globals.xMin,\n    yMin: globals.yMin,\n    xMax: globals.xMax,\n    yMax: globals.yMax,\n    lowestRecPPEM: 3,\n    createdTimestamp: font.createdTimestamp\n  });\n  const hheaTable = hhea.make({\n    ascender: globals.ascender,\n    descender: globals.descender,\n    advanceWidthMax: globals.advanceWidthMax,\n    minLeftSideBearing: globals.minLeftSideBearing,\n    minRightSideBearing: globals.minRightSideBearing,\n    xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n    numberOfHMetrics: font.glyphs.length\n  });\n  const maxpTable = maxp.make(font.glyphs.length);\n  const os2Table = os2.make({\n    xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n    usWeightClass: font.tables.os2.usWeightClass,\n    usWidthClass: font.tables.os2.usWidthClass,\n    usFirstCharIndex: firstCharIndex,\n    usLastCharIndex: lastCharIndex,\n    ulUnicodeRange1: ulUnicodeRange1,\n    ulUnicodeRange2: ulUnicodeRange2,\n    ulUnicodeRange3: ulUnicodeRange3,\n    ulUnicodeRange4: ulUnicodeRange4,\n    fsSelection: font.tables.os2.fsSelection,\n    // REGULAR\n    // See http://typophile.com/node/13081 for more info on vertical metrics.\n    // We get metrics for typical characters (such as \"x\" for xHeight).\n    // We provide some fallback characters if characters are unavailable: their\n    // ordering was chosen experimentally.\n    sTypoAscender: globals.ascender,\n    sTypoDescender: globals.descender,\n    sTypoLineGap: 0,\n    usWinAscent: globals.yMax,\n    usWinDescent: Math.abs(globals.yMin),\n    ulCodePageRange1: 1,\n    // FIXME: hard-code Latin 1 support for now\n    sxHeight: metricsForChar(font, 'xyvw', {\n      yMax: Math.round(globals.ascender / 2)\n    }).yMax,\n    sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n    usDefaultChar: font.hasChar(' ') ? 32 : 0,\n    // Use space as the default character, if available.\n    usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.\n  });\n\n  const hmtxTable = hmtx.make(font.glyphs);\n  const cmapTable = cmap.make(font.glyphs);\n  const englishFamilyName = font.getEnglishName('fontFamily');\n  const englishStyleName = font.getEnglishName('fontSubfamily');\n  const englishFullName = englishFamilyName + ' ' + englishStyleName;\n  let postScriptName = font.getEnglishName('postScriptName');\n  if (!postScriptName) {\n    postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n  }\n  const names = {};\n  for (let n in font.names) {\n    names[n] = font.names[n];\n  }\n  if (!names.uniqueID) {\n    names.uniqueID = {\n      en: font.getEnglishName('manufacturer') + ':' + englishFullName\n    };\n  }\n  if (!names.postScriptName) {\n    names.postScriptName = {\n      en: postScriptName\n    };\n  }\n  if (!names.preferredFamily) {\n    names.preferredFamily = font.names.fontFamily;\n  }\n  if (!names.preferredSubfamily) {\n    names.preferredSubfamily = font.names.fontSubfamily;\n  }\n  const languageTags = [];\n  const nameTable = _name.make(names, languageTags);\n  const ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : undefined;\n  const postTable = post.make();\n  const cffTable = cff.make(font.glyphs, {\n    version: font.getEnglishName('version'),\n    fullName: englishFullName,\n    familyName: englishFamilyName,\n    weightName: englishStyleName,\n    postScriptName: postScriptName,\n    unitsPerEm: font.unitsPerEm,\n    fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n  });\n  const metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : undefined;\n\n  // The order does not matter because makeSfntTable() will sort them.\n  const tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n  if (ltagTable) {\n    tables.push(ltagTable);\n  }\n  // Optional tables\n  if (font.tables.gsub) {\n    tables.push(gsub.make(font.tables.gsub));\n  }\n  if (metaTable) {\n    tables.push(metaTable);\n  }\n  const sfntTable = makeSfntTable(tables);\n\n  // Compute the font's checkSum and store it in head.checkSumAdjustment.\n  const bytes = sfntTable.encode();\n  const checkSum = computeCheckSum(bytes);\n  const tableFields = sfntTable.fields;\n  let checkSumAdjusted = false;\n  for (let i = 0; i < tableFields.length; i += 1) {\n    if (tableFields[i].name === 'head table') {\n      tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n      checkSumAdjusted = true;\n      break;\n    }\n  }\n  if (!checkSumAdjusted) {\n    throw new Error('Could not find head table with checkSum to adjust.');\n  }\n  return sfntTable;\n}\nexport default {\n  make: makeSfntTable,\n  fontToTable: fontToSfntTable,\n  computeCheckSum\n};","map":{"version":3,"names":["check","table","cmap","cff","head","hhea","hmtx","ltag","maxp","_name","os2","post","gsub","meta","log2","v","Math","log","computeCheckSum","bytes","length","push","sum","i","pow","makeTableRecord","tag","checkSum","offset","Record","name","type","value","undefined","makeSfntTable","tables","sfnt","Table","numTables","highestPowerOf2","searchRange","entrySelector","rangeShift","recordFields","tableFields","sizeOf","t","argument","tableName","tableLength","tableRecord","encode","isNaN","sort","r1","r2","fields","concat","metricsForChar","font","chars","notFoundMetrics","glyphIndex","charToGlyphIndex","glyph","glyphs","get","getMetrics","average","vs","fontToSfntTable","xMins","yMins","xMaxs","yMaxs","advanceWidths","leftSideBearings","rightSideBearings","firstCharIndex","lastCharIndex","ulUnicodeRange1","ulUnicodeRange2","ulUnicodeRange3","ulUnicodeRange4","unicode","advanceWidth","Error","position","getUnicodeRange","metrics","xMin","yMin","xMax","yMax","leftSideBearing","rightSideBearing","globals","min","apply","max","advanceWidthMax","advanceWidthAvg","minLeftSideBearing","maxLeftSideBearing","minRightSideBearing","ascender","descender","headTable","make","flags","unitsPerEm","lowestRecPPEM","createdTimestamp","hheaTable","xMaxExtent","numberOfHMetrics","maxpTable","os2Table","xAvgCharWidth","round","usWeightClass","usWidthClass","usFirstCharIndex","usLastCharIndex","fsSelection","sTypoAscender","sTypoDescender","sTypoLineGap","usWinAscent","usWinDescent","abs","ulCodePageRange1","sxHeight","sCapHeight","usDefaultChar","hasChar","usBreakChar","hmtxTable","cmapTable","englishFamilyName","getEnglishName","englishStyleName","englishFullName","postScriptName","replace","names","n","uniqueID","en","preferredFamily","fontFamily","preferredSubfamily","fontSubfamily","languageTags","nameTable","ltagTable","postTable","cffTable","version","fullName","familyName","weightName","fontBBox","metaTable","metas","Object","keys","sfntTable","checkSumAdjusted","checkSumAdjustment","fontToTable"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/opentype.js/src/tables/sfnt.js"],"sourcesContent":["// The `sfnt` wrapper provides organization for the tables in the font.\n// It is the top-level data structure in a font.\n// https://www.microsoft.com/typography/OTSPEC/otff.htm\n// Recommendations for creating OpenType Fonts:\n// http://www.microsoft.com/typography/otspec140/recom.htm\n\nimport check from '../check';\nimport table from '../table';\n\nimport cmap from './cmap';\nimport cff from './cff';\nimport head from './head';\nimport hhea from './hhea';\nimport hmtx from './hmtx';\nimport ltag from './ltag';\nimport maxp from './maxp';\nimport _name from './name';\nimport os2 from './os2';\nimport post from './post';\nimport gsub from './gsub';\nimport meta from './meta';\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    let sum = 0;\n    for (let i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Record('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    const sfnt = new table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    const highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    const recordFields = [];\n    const tableFields = [];\n\n    let offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (let i = 0; i < tables.length; i += 1) {\n        const t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        const tableLength = t.sizeOf();\n        const tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (let i = 0; i < chars.length; i += 1) {\n        const glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            const glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    let sum = 0;\n    for (let i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    const xMins = [];\n    const yMins = [];\n    const xMaxs = [];\n    const yMaxs = [];\n    const advanceWidths = [];\n    const leftSideBearings = [];\n    const rightSideBearings = [];\n    let firstCharIndex;\n    let lastCharIndex = 0;\n    let ulUnicodeRange1 = 0;\n    let ulUnicodeRange2 = 0;\n    let ulUnicodeRange3 = 0;\n    let ulUnicodeRange4 = 0;\n\n    for (let i = 0; i < font.glyphs.length; i += 1) {\n        const glyph = font.glyphs.get(i);\n        const unicode = glyph.unicode | 0;\n\n        if (isNaN(glyph.advanceWidth)) {\n            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n        }\n\n        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n            // ignore .notdef char\n            if (unicode > 0) {\n                firstCharIndex = unicode;\n            }\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        const position = os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') continue;\n        const metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    const globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender;\n    globals.descender = font.descender;\n\n    const headTable = head.make({\n        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax,\n        lowestRecPPEM: 3,\n        createdTimestamp: font.createdTimestamp\n    });\n\n    const hheaTable = hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    const maxpTable = maxp.make(font.glyphs.length);\n\n    const os2Table = os2.make({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usWeightClass: font.tables.os2.usWeightClass,\n        usWidthClass: font.tables.os2.usWidthClass,\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        fsSelection: font.tables.os2.fsSelection, // REGULAR\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.yMax,\n        usWinDescent: Math.abs(globals.yMin),\n        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.\n    });\n\n    const hmtxTable = hmtx.make(font.glyphs);\n    const cmapTable = cmap.make(font.glyphs);\n\n    const englishFamilyName = font.getEnglishName('fontFamily');\n    const englishStyleName = font.getEnglishName('fontSubfamily');\n    const englishFullName = englishFamilyName + ' ' + englishStyleName;\n    let postScriptName = font.getEnglishName('postScriptName');\n    if (!postScriptName) {\n        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n    }\n\n    const names = {};\n    for (let n in font.names) {\n        names[n] = font.names[n];\n    }\n\n    if (!names.uniqueID) {\n        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n    }\n\n    if (!names.postScriptName) {\n        names.postScriptName = {en: postScriptName};\n    }\n\n    if (!names.preferredFamily) {\n        names.preferredFamily = font.names.fontFamily;\n    }\n\n    if (!names.preferredSubfamily) {\n        names.preferredSubfamily = font.names.fontSubfamily;\n    }\n\n    const languageTags = [];\n    const nameTable = _name.make(names, languageTags);\n    const ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n    const postTable = post.make();\n    const cffTable = cff.make(font.glyphs, {\n        version: font.getEnglishName('version'),\n        fullName: englishFullName,\n        familyName: englishFamilyName,\n        weightName: englishStyleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm,\n        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n    });\n\n    const metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n    // The order does not matter because makeSfntTable() will sort them.\n    const tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n    if (ltagTable) {\n        tables.push(ltagTable);\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n        tables.push(gsub.make(font.tables.gsub));\n    }\n    if (metaTable) {\n        tables.push(metaTable);\n    }\n\n    const sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    const bytes = sfntTable.encode();\n    const checkSum = computeCheckSum(bytes);\n    const tableFields = sfntTable.fields;\n    let checkSumAdjusted = false;\n    for (let i = 0; i < tableFields.length; i += 1) {\n        if (tableFields[i].name === 'head table') {\n            tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\nexport default { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}