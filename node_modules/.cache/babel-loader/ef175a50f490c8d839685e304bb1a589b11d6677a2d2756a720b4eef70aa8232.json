{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar core = require('@vueuse/core');\nvar lodashUnified = require('lodash-unified');\nvar index$5 = require('../../icon/index.js');\nvar iconsVue = require('@element-plus/icons-vue');\nrequire('../../../utils/index.js');\nrequire('../../../hooks/index.js');\nrequire('../../../constants/index.js');\nvar utils = require('./utils.js');\nvar input = require('./input.js');\nvar pluginVue_exportHelper = require('../../../_virtual/plugin-vue_export-helper.js');\nvar index = require('../../../hooks/use-attrs/index.js');\nvar index$1 = require('../../../hooks/use-form-item/index.js');\nvar index$2 = require('../../../hooks/use-common-props/index.js');\nvar index$3 = require('../../../hooks/use-namespace/index.js');\nvar icon = require('../../../utils/vue/icon.js');\nvar index$4 = require('../../../hooks/use-cursor/index.js');\nvar shared = require('@vue/shared');\nvar event = require('../../../constants/event.js');\nvar i18n = require('../../../utils/i18n.js');\nvar error = require('../../../utils/error.js');\nconst _hoisted_1 = [\"role\"];\nconst _hoisted_2 = [\"id\", \"type\", \"disabled\", \"formatter\", \"parser\", \"readonly\", \"autocomplete\", \"tabindex\", \"aria-label\", \"placeholder\", \"form\"];\nconst _hoisted_3 = [\"id\", \"tabindex\", \"disabled\", \"readonly\", \"autocomplete\", \"aria-label\", \"placeholder\", \"form\"];\nconst __default__ = vue.defineComponent({\n  name: \"ElInput\",\n  inheritAttrs: false\n});\nconst _sfc_main = /* @__PURE__ */vue.defineComponent({\n  ...__default__,\n  props: input.inputProps,\n  emits: input.inputEmits,\n  setup(__props, {\n    expose,\n    emit\n  }) {\n    const props = __props;\n    const rawAttrs = vue.useAttrs();\n    const slots = vue.useSlots();\n    const containerAttrs = vue.computed(() => {\n      const comboBoxAttrs = {};\n      if (props.containerRole === \"combobox\") {\n        comboBoxAttrs[\"aria-haspopup\"] = rawAttrs[\"aria-haspopup\"];\n        comboBoxAttrs[\"aria-owns\"] = rawAttrs[\"aria-owns\"];\n        comboBoxAttrs[\"aria-expanded\"] = rawAttrs[\"aria-expanded\"];\n      }\n      return comboBoxAttrs;\n    });\n    const attrs = index.useAttrs({\n      excludeKeys: vue.computed(() => {\n        return Object.keys(containerAttrs.value);\n      })\n    });\n    const {\n      form,\n      formItem\n    } = index$1.useFormItem();\n    const {\n      inputId\n    } = index$1.useFormItemInputId(props, {\n      formItemContext: formItem\n    });\n    const inputSize = index$2.useSize();\n    const inputDisabled = index$2.useDisabled();\n    const nsInput = index$3.useNamespace(\"input\");\n    const nsTextarea = index$3.useNamespace(\"textarea\");\n    const input = vue.shallowRef();\n    const textarea = vue.shallowRef();\n    const focused = vue.ref(false);\n    const hovering = vue.ref(false);\n    const isComposing = vue.ref(false);\n    const passwordVisible = vue.ref(false);\n    const countStyle = vue.ref();\n    const textareaCalcStyle = vue.shallowRef(props.inputStyle);\n    const _ref = vue.computed(() => input.value || textarea.value);\n    const needStatusIcon = vue.computed(() => {\n      var _a;\n      return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;\n    });\n    const validateState = vue.computed(() => (formItem == null ? void 0 : formItem.validateState) || \"\");\n    const validateIcon = vue.computed(() => validateState.value && icon.ValidateComponentsMap[validateState.value]);\n    const passwordIcon = vue.computed(() => passwordVisible.value ? iconsVue.View : iconsVue.Hide);\n    const containerStyle = vue.computed(() => [rawAttrs.style, props.inputStyle]);\n    const textareaStyle = vue.computed(() => [props.inputStyle, textareaCalcStyle.value, {\n      resize: props.resize\n    }]);\n    const nativeInputValue = vue.computed(() => lodashUnified.isNil(props.modelValue) ? \"\" : String(props.modelValue));\n    const showClear = vue.computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));\n    const showPwdVisible = vue.computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || focused.value));\n    const isWordLimitVisible = vue.computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === \"text\" || props.type === \"textarea\") && !inputDisabled.value && !props.readonly && !props.showPassword);\n    const textLength = vue.computed(() => Array.from(nativeInputValue.value).length);\n    const inputExceed = vue.computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));\n    const suffixVisible = vue.computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);\n    const [recordCursor, setCursor] = index$4.useCursor(input);\n    core.useResizeObserver(textarea, entries => {\n      if (!isWordLimitVisible.value || props.resize !== \"both\") return;\n      const entry = entries[0];\n      const {\n        width\n      } = entry.contentRect;\n      countStyle.value = {\n        right: `calc(100% - ${width + 15 + 6}px)`\n      };\n    });\n    const resizeTextarea = () => {\n      const {\n        type,\n        autosize\n      } = props;\n      if (!core.isClient || type !== \"textarea\") return;\n      if (autosize) {\n        const minRows = shared.isObject(autosize) ? autosize.minRows : void 0;\n        const maxRows = shared.isObject(autosize) ? autosize.maxRows : void 0;\n        textareaCalcStyle.value = {\n          ...utils.calcTextareaHeight(textarea.value, minRows, maxRows)\n        };\n      } else {\n        textareaCalcStyle.value = {\n          minHeight: utils.calcTextareaHeight(textarea.value).minHeight\n        };\n      }\n    };\n    const setNativeInputValue = () => {\n      const input2 = _ref.value;\n      if (!input2 || input2.value === nativeInputValue.value) return;\n      input2.value = nativeInputValue.value;\n    };\n    const handleInput = async event$1 => {\n      recordCursor();\n      let {\n        value\n      } = event$1.target;\n      if (props.formatter) {\n        value = props.parser ? props.parser(value) : value;\n        value = props.formatter(value);\n      }\n      if (isComposing.value) return;\n      if (value === nativeInputValue.value) {\n        setNativeInputValue();\n        return;\n      }\n      emit(event.UPDATE_MODEL_EVENT, value);\n      emit(\"input\", value);\n      await vue.nextTick();\n      setNativeInputValue();\n      setCursor();\n    };\n    const handleChange = event => {\n      emit(\"change\", event.target.value);\n    };\n    const handleCompositionStart = event => {\n      emit(\"compositionstart\", event);\n      isComposing.value = true;\n    };\n    const handleCompositionUpdate = event => {\n      var _a;\n      emit(\"compositionupdate\", event);\n      const text = (_a = event.target) == null ? void 0 : _a.value;\n      const lastCharacter = text[text.length - 1] || \"\";\n      isComposing.value = !i18n.isKorean(lastCharacter);\n    };\n    const handleCompositionEnd = event => {\n      emit(\"compositionend\", event);\n      if (isComposing.value) {\n        isComposing.value = false;\n        handleInput(event);\n      }\n    };\n    const handlePasswordVisible = () => {\n      passwordVisible.value = !passwordVisible.value;\n      focus();\n    };\n    const focus = async () => {\n      var _a;\n      await vue.nextTick();\n      (_a = _ref.value) == null ? void 0 : _a.focus();\n    };\n    const blur = () => {\n      var _a;\n      return (_a = _ref.value) == null ? void 0 : _a.blur();\n    };\n    const handleFocus = event => {\n      focused.value = true;\n      emit(\"focus\", event);\n    };\n    const handleBlur = event => {\n      var _a;\n      focused.value = false;\n      emit(\"blur\", event);\n      if (props.validateEvent) {\n        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, \"blur\").catch(err => error.debugWarn(err));\n      }\n    };\n    const handleMouseLeave = evt => {\n      hovering.value = false;\n      emit(\"mouseleave\", evt);\n    };\n    const handleMouseEnter = evt => {\n      hovering.value = true;\n      emit(\"mouseenter\", evt);\n    };\n    const handleKeydown = evt => {\n      emit(\"keydown\", evt);\n    };\n    const select = () => {\n      var _a;\n      (_a = _ref.value) == null ? void 0 : _a.select();\n    };\n    const clear = () => {\n      emit(event.UPDATE_MODEL_EVENT, \"\");\n      emit(\"change\", \"\");\n      emit(\"clear\");\n      emit(\"input\", \"\");\n    };\n    vue.watch(() => props.modelValue, () => {\n      var _a;\n      vue.nextTick(() => resizeTextarea());\n      if (props.validateEvent) {\n        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, \"change\").catch(err => error.debugWarn(err));\n      }\n    });\n    vue.watch(nativeInputValue, () => setNativeInputValue());\n    vue.watch(() => props.type, async () => {\n      await vue.nextTick();\n      setNativeInputValue();\n      resizeTextarea();\n    });\n    vue.onMounted(() => {\n      if (!props.formatter && props.parser) {\n        error.debugWarn(\"ElInput\", \"If you set the parser, you also need to set the formatter.\");\n      }\n      setNativeInputValue();\n      vue.nextTick(resizeTextarea);\n    });\n    expose({\n      input,\n      textarea,\n      ref: _ref,\n      textareaStyle,\n      autosize: vue.toRef(props, \"autosize\"),\n      focus,\n      blur,\n      select,\n      clear,\n      resizeTextarea\n    });\n    return (_ctx, _cache) => {\n      return vue.withDirectives((vue.openBlock(), vue.createElementBlock(\"div\", vue.mergeProps(vue.unref(containerAttrs), {\n        class: [_ctx.type === \"textarea\" ? vue.unref(nsTextarea).b() : vue.unref(nsInput).b(), vue.unref(nsInput).m(vue.unref(inputSize)), vue.unref(nsInput).is(\"disabled\", vue.unref(inputDisabled)), vue.unref(nsInput).is(\"exceed\", vue.unref(inputExceed)), {\n          [vue.unref(nsInput).b(\"group\")]: _ctx.$slots.prepend || _ctx.$slots.append,\n          [vue.unref(nsInput).bm(\"group\", \"append\")]: _ctx.$slots.append,\n          [vue.unref(nsInput).bm(\"group\", \"prepend\")]: _ctx.$slots.prepend,\n          [vue.unref(nsInput).m(\"prefix\")]: _ctx.$slots.prefix || _ctx.prefixIcon,\n          [vue.unref(nsInput).m(\"suffix\")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,\n          [vue.unref(nsInput).bm(\"suffix\", \"password-clear\")]: vue.unref(showClear) && vue.unref(showPwdVisible)\n        }, _ctx.$attrs.class],\n        style: vue.unref(containerStyle),\n        role: _ctx.containerRole,\n        onMouseenter: handleMouseEnter,\n        onMouseleave: handleMouseLeave\n      }), [vue.createCommentVNode(\" input \"), _ctx.type !== \"textarea\" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {\n        key: 0\n      }, [vue.createCommentVNode(\" prepend slot \"), _ctx.$slots.prepend ? (vue.openBlock(), vue.createElementBlock(\"div\", {\n        key: 0,\n        class: vue.normalizeClass(vue.unref(nsInput).be(\"group\", \"prepend\"))\n      }, [vue.renderSlot(_ctx.$slots, \"prepend\")], 2)) : vue.createCommentVNode(\"v-if\", true), vue.createElementVNode(\"div\", {\n        class: vue.normalizeClass([vue.unref(nsInput).e(\"wrapper\"), vue.unref(nsInput).is(\"focus\", focused.value)])\n      }, [vue.createCommentVNode(\" prefix slot \"), _ctx.$slots.prefix || _ctx.prefixIcon ? (vue.openBlock(), vue.createElementBlock(\"span\", {\n        key: 0,\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"prefix\"))\n      }, [vue.createElementVNode(\"span\", {\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"prefix-inner\"))\n      }, [vue.renderSlot(_ctx.$slots, \"prefix\"), _ctx.prefixIcon ? (vue.openBlock(), vue.createBlock(vue.unref(index$5.ElIcon), {\n        key: 0,\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"icon\"))\n      }, {\n        default: vue.withCtx(() => [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.prefixIcon)))]),\n        _: 1\n      }, 8, [\"class\"])) : vue.createCommentVNode(\"v-if\", true)], 2)], 2)) : vue.createCommentVNode(\"v-if\", true), vue.createElementVNode(\"input\", vue.mergeProps({\n        id: vue.unref(inputId),\n        ref_key: \"input\",\n        ref: input,\n        class: vue.unref(nsInput).e(\"inner\")\n      }, vue.unref(attrs), {\n        type: _ctx.showPassword ? passwordVisible.value ? \"text\" : \"password\" : _ctx.type,\n        disabled: vue.unref(inputDisabled),\n        formatter: _ctx.formatter,\n        parser: _ctx.parser,\n        readonly: _ctx.readonly,\n        autocomplete: _ctx.autocomplete,\n        tabindex: _ctx.tabindex,\n        \"aria-label\": _ctx.label,\n        placeholder: _ctx.placeholder,\n        style: _ctx.inputStyle,\n        form: props.form,\n        onCompositionstart: handleCompositionStart,\n        onCompositionupdate: handleCompositionUpdate,\n        onCompositionend: handleCompositionEnd,\n        onInput: handleInput,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onKeydown: handleKeydown\n      }), null, 16, _hoisted_2), vue.createCommentVNode(\" suffix slot \"), vue.unref(suffixVisible) ? (vue.openBlock(), vue.createElementBlock(\"span\", {\n        key: 1,\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"suffix\"))\n      }, [vue.createElementVNode(\"span\", {\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"suffix-inner\"))\n      }, [!vue.unref(showClear) || !vue.unref(showPwdVisible) || !vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {\n        key: 0\n      }, [vue.renderSlot(_ctx.$slots, \"suffix\"), _ctx.suffixIcon ? (vue.openBlock(), vue.createBlock(vue.unref(index$5.ElIcon), {\n        key: 0,\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"icon\"))\n      }, {\n        default: vue.withCtx(() => [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.suffixIcon)))]),\n        _: 1\n      }, 8, [\"class\"])) : vue.createCommentVNode(\"v-if\", true)], 64)) : vue.createCommentVNode(\"v-if\", true), vue.unref(showClear) ? (vue.openBlock(), vue.createBlock(vue.unref(index$5.ElIcon), {\n        key: 1,\n        class: vue.normalizeClass([vue.unref(nsInput).e(\"icon\"), vue.unref(nsInput).e(\"clear\")]),\n        onMousedown: vue.withModifiers(vue.unref(shared.NOOP), [\"prevent\"]),\n        onClick: clear\n      }, {\n        default: vue.withCtx(() => [vue.createVNode(vue.unref(iconsVue.CircleClose))]),\n        _: 1\n      }, 8, [\"class\", \"onMousedown\"])) : vue.createCommentVNode(\"v-if\", true), vue.unref(showPwdVisible) ? (vue.openBlock(), vue.createBlock(vue.unref(index$5.ElIcon), {\n        key: 2,\n        class: vue.normalizeClass([vue.unref(nsInput).e(\"icon\"), vue.unref(nsInput).e(\"password\")]),\n        onClick: handlePasswordVisible\n      }, {\n        default: vue.withCtx(() => [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(passwordIcon))))]),\n        _: 1\n      }, 8, [\"class\"])) : vue.createCommentVNode(\"v-if\", true), vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock(\"span\", {\n        key: 3,\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"count\"))\n      }, [vue.createElementVNode(\"span\", {\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"count-inner\"))\n      }, vue.toDisplayString(vue.unref(textLength)) + \" / \" + vue.toDisplayString(vue.unref(attrs).maxlength), 3)], 2)) : vue.createCommentVNode(\"v-if\", true), vue.unref(validateState) && vue.unref(validateIcon) && vue.unref(needStatusIcon) ? (vue.openBlock(), vue.createBlock(vue.unref(index$5.ElIcon), {\n        key: 4,\n        class: vue.normalizeClass([vue.unref(nsInput).e(\"icon\"), vue.unref(nsInput).e(\"validateIcon\"), vue.unref(nsInput).is(\"loading\", vue.unref(validateState) === \"validating\")])\n      }, {\n        default: vue.withCtx(() => [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(validateIcon))))]),\n        _: 1\n      }, 8, [\"class\"])) : vue.createCommentVNode(\"v-if\", true)], 2)], 2)) : vue.createCommentVNode(\"v-if\", true)], 2), vue.createCommentVNode(\" append slot \"), _ctx.$slots.append ? (vue.openBlock(), vue.createElementBlock(\"div\", {\n        key: 1,\n        class: vue.normalizeClass(vue.unref(nsInput).be(\"group\", \"append\"))\n      }, [vue.renderSlot(_ctx.$slots, \"append\")], 2)) : vue.createCommentVNode(\"v-if\", true)], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {\n        key: 1\n      }, [vue.createCommentVNode(\" textarea \"), vue.createElementVNode(\"textarea\", vue.mergeProps({\n        id: vue.unref(inputId),\n        ref_key: \"textarea\",\n        ref: textarea,\n        class: vue.unref(nsTextarea).e(\"inner\")\n      }, vue.unref(attrs), {\n        tabindex: _ctx.tabindex,\n        disabled: vue.unref(inputDisabled),\n        readonly: _ctx.readonly,\n        autocomplete: _ctx.autocomplete,\n        style: vue.unref(textareaStyle),\n        \"aria-label\": _ctx.label,\n        placeholder: _ctx.placeholder,\n        form: props.form,\n        onCompositionstart: handleCompositionStart,\n        onCompositionupdate: handleCompositionUpdate,\n        onCompositionend: handleCompositionEnd,\n        onInput: handleInput,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onKeydown: handleKeydown\n      }), null, 16, _hoisted_3), vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock(\"span\", {\n        key: 0,\n        style: vue.normalizeStyle(countStyle.value),\n        class: vue.normalizeClass(vue.unref(nsInput).e(\"count\"))\n      }, vue.toDisplayString(vue.unref(textLength)) + \" / \" + vue.toDisplayString(vue.unref(attrs).maxlength), 7)) : vue.createCommentVNode(\"v-if\", true)], 64))], 16, _hoisted_1)), [[vue.vShow, _ctx.type !== \"hidden\"]]);\n    };\n  }\n});\nvar Input = /* @__PURE__ */pluginVue_exportHelper[\"default\"](_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue\"]]);\nexports[\"default\"] = Input;","map":{"version":3,"mappings":"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","names":["name","inheritAttrs","rawAttrs","useRawAttrs","slots","useSlots","computed","comboBoxAttrs","containerRole","attrs","useAttrs","excludeKeys","keys","value","form","formItem","useFormItem","inputId","props","formItemContext","inputSize","useSize","inputDisabled","useDisabled","useNamespace","input","shallowRef","textarea","ref","countStyle","inputStyle","_ref","needStatusIcon","_a","validateIcon","passwordIcon","containerStyle","textareaStyle","textareaCalcStyle","resize","showPwdVisible","readonly","textLength","nativeInputValue","suffixVisible","useResizeObserver","width","right","type","autosize","minRows","minHeight","input2","handleInput","recordCursor","event","setNativeInputValue","emit","setCursor","isComposing","handlePasswordVisible","passwordVisible","focus","focused","validateEvent","hovering","evt","watch","nextTick","resizeTextarea","onMounted","formatter","debugWarn","expose"],"sources":["../../../../../../packages/components/input/src/input.vue"],"sourcesContent":["<template>\n  <div\n    v-show=\"type !== 'hidden'\"\n    v-bind=\"containerAttrs\"\n    :class=\"[\n      type === 'textarea' ? nsTextarea.b() : nsInput.b(),\n      nsInput.m(inputSize),\n      nsInput.is('disabled', inputDisabled),\n      nsInput.is('exceed', inputExceed),\n      {\n        [nsInput.b('group')]: $slots.prepend || $slots.append,\n        [nsInput.bm('group', 'append')]: $slots.append,\n        [nsInput.bm('group', 'prepend')]: $slots.prepend,\n        [nsInput.m('prefix')]: $slots.prefix || prefixIcon,\n        [nsInput.m('suffix')]:\n          $slots.suffix || suffixIcon || clearable || showPassword,\n        [nsInput.bm('suffix', 'password-clear')]: showClear && showPwdVisible,\n      },\n      $attrs.class,\n    ]\"\n    :style=\"containerStyle\"\n    :role=\"containerRole\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n  >\n    <!-- input -->\n    <template v-if=\"type !== 'textarea'\">\n      <!-- prepend slot -->\n      <div v-if=\"$slots.prepend\" :class=\"nsInput.be('group', 'prepend')\">\n        <slot name=\"prepend\" />\n      </div>\n\n      <div :class=\"[nsInput.e('wrapper'), nsInput.is('focus', focused)]\">\n        <!-- prefix slot -->\n        <span v-if=\"$slots.prefix || prefixIcon\" :class=\"nsInput.e('prefix')\">\n          <span :class=\"nsInput.e('prefix-inner')\">\n            <slot name=\"prefix\" />\n            <el-icon v-if=\"prefixIcon\" :class=\"nsInput.e('icon')\">\n              <component :is=\"prefixIcon\" />\n            </el-icon>\n          </span>\n        </span>\n\n        <input\n          :id=\"inputId\"\n          ref=\"input\"\n          :class=\"nsInput.e('inner')\"\n          v-bind=\"attrs\"\n          :type=\"showPassword ? (passwordVisible ? 'text' : 'password') : type\"\n          :disabled=\"inputDisabled\"\n          :formatter=\"formatter\"\n          :parser=\"parser\"\n          :readonly=\"readonly\"\n          :autocomplete=\"autocomplete\"\n          :tabindex=\"tabindex\"\n          :aria-label=\"label\"\n          :placeholder=\"placeholder\"\n          :style=\"inputStyle\"\n          :form=\"props.form\"\n          @compositionstart=\"handleCompositionStart\"\n          @compositionupdate=\"handleCompositionUpdate\"\n          @compositionend=\"handleCompositionEnd\"\n          @input=\"handleInput\"\n          @focus=\"handleFocus\"\n          @blur=\"handleBlur\"\n          @change=\"handleChange\"\n          @keydown=\"handleKeydown\"\n        />\n\n        <!-- suffix slot -->\n        <span v-if=\"suffixVisible\" :class=\"nsInput.e('suffix')\">\n          <span :class=\"nsInput.e('suffix-inner')\">\n            <template\n              v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\"\n            >\n              <slot name=\"suffix\" />\n              <el-icon v-if=\"suffixIcon\" :class=\"nsInput.e('icon')\">\n                <component :is=\"suffixIcon\" />\n              </el-icon>\n            </template>\n            <el-icon\n              v-if=\"showClear\"\n              :class=\"[nsInput.e('icon'), nsInput.e('clear')]\"\n              @mousedown.prevent=\"NOOP\"\n              @click=\"clear\"\n            >\n              <circle-close />\n            </el-icon>\n            <el-icon\n              v-if=\"showPwdVisible\"\n              :class=\"[nsInput.e('icon'), nsInput.e('password')]\"\n              @click=\"handlePasswordVisible\"\n            >\n              <component :is=\"passwordIcon\" />\n            </el-icon>\n            <span v-if=\"isWordLimitVisible\" :class=\"nsInput.e('count')\">\n              <span :class=\"nsInput.e('count-inner')\">\n                {{ textLength }} / {{ attrs.maxlength }}\n              </span>\n            </span>\n            <el-icon\n              v-if=\"validateState && validateIcon && needStatusIcon\"\n              :class=\"[\n                nsInput.e('icon'),\n                nsInput.e('validateIcon'),\n                nsInput.is('loading', validateState === 'validating'),\n              ]\"\n            >\n              <component :is=\"validateIcon\" />\n            </el-icon>\n          </span>\n        </span>\n      </div>\n\n      <!-- append slot -->\n      <div v-if=\"$slots.append\" :class=\"nsInput.be('group', 'append')\">\n        <slot name=\"append\" />\n      </div>\n    </template>\n\n    <!-- textarea -->\n    <template v-else>\n      <textarea\n        :id=\"inputId\"\n        ref=\"textarea\"\n        :class=\"nsTextarea.e('inner')\"\n        v-bind=\"attrs\"\n        :tabindex=\"tabindex\"\n        :disabled=\"inputDisabled\"\n        :readonly=\"readonly\"\n        :autocomplete=\"autocomplete\"\n        :style=\"textareaStyle\"\n        :aria-label=\"label\"\n        :placeholder=\"placeholder\"\n        :form=\"props.form\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n        @input=\"handleInput\"\n        @focus=\"handleFocus\"\n        @blur=\"handleBlur\"\n        @change=\"handleChange\"\n        @keydown=\"handleKeydown\"\n      />\n      <span\n        v-if=\"isWordLimitVisible\"\n        :style=\"countStyle\"\n        :class=\"nsInput.e('count')\"\n      >\n        {{ textLength }} / {{ attrs.maxlength }}\n      </span>\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onMounted,\n  ref,\n  shallowRef,\n  toRef,\n  useAttrs as useRawAttrs,\n  useSlots,\n  watch,\n} from 'vue'\nimport { isClient, useResizeObserver } from '@vueuse/core'\nimport { isNil } from 'lodash-unified'\nimport { ElIcon } from '@element-plus/components/icon'\nimport {\n  CircleClose,\n  Hide as IconHide,\n  View as IconView,\n} from '@element-plus/icons-vue'\nimport {\n  NOOP,\n  ValidateComponentsMap,\n  debugWarn,\n  isKorean,\n  isObject,\n} from '@element-plus/utils'\nimport {\n  useAttrs,\n  useCursor,\n  useDisabled,\n  useFormItem,\n  useFormItemInputId,\n  useNamespace,\n  useSize,\n} from '@element-plus/hooks'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { calcTextareaHeight } from './utils'\nimport { inputEmits, inputProps } from './input'\nimport type { StyleValue } from 'vue'\n\ntype TargetElement = HTMLInputElement | HTMLTextAreaElement\n\ndefineOptions({\n  name: 'ElInput',\n  inheritAttrs: false,\n})\nconst props = defineProps(inputProps)\nconst emit = defineEmits(inputEmits)\n\nconst rawAttrs = useRawAttrs()\nconst slots = useSlots()\n\nconst containerAttrs = computed(() => {\n  const comboBoxAttrs: Record<string, unknown> = {}\n  if (props.containerRole === 'combobox') {\n    comboBoxAttrs['aria-haspopup'] = rawAttrs['aria-haspopup']\n    comboBoxAttrs['aria-owns'] = rawAttrs['aria-owns']\n    comboBoxAttrs['aria-expanded'] = rawAttrs['aria-expanded']\n  }\n  return comboBoxAttrs\n})\n\nconst attrs = useAttrs({\n  excludeKeys: computed<string[]>(() => {\n    return Object.keys(containerAttrs.value)\n  }),\n})\nconst { form, formItem } = useFormItem()\nconst { inputId } = useFormItemInputId(props, {\n  formItemContext: formItem,\n})\nconst inputSize = useSize()\nconst inputDisabled = useDisabled()\nconst nsInput = useNamespace('input')\nconst nsTextarea = useNamespace('textarea')\n\nconst input = shallowRef<HTMLInputElement>()\nconst textarea = shallowRef<HTMLTextAreaElement>()\n\nconst focused = ref(false)\nconst hovering = ref(false)\nconst isComposing = ref(false)\nconst passwordVisible = ref(false)\nconst countStyle = ref<StyleValue>()\nconst textareaCalcStyle = shallowRef(props.inputStyle)\n\nconst _ref = computed(() => input.value || textarea.value)\n\nconst needStatusIcon = computed(() => form?.statusIcon ?? false)\nconst validateState = computed(() => formItem?.validateState || '')\nconst validateIcon = computed(\n  () => validateState.value && ValidateComponentsMap[validateState.value]\n)\nconst passwordIcon = computed(() =>\n  passwordVisible.value ? IconView : IconHide\n)\nconst containerStyle = computed<StyleValue>(() => [\n  rawAttrs.style as StyleValue,\n  props.inputStyle,\n])\nconst textareaStyle = computed<StyleValue>(() => [\n  props.inputStyle,\n  textareaCalcStyle.value,\n  { resize: props.resize },\n])\nconst nativeInputValue = computed(() =>\n  isNil(props.modelValue) ? '' : String(props.modelValue)\n)\nconst showClear = computed(\n  () =>\n    props.clearable &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !!nativeInputValue.value &&\n    (focused.value || hovering.value)\n)\nconst showPwdVisible = computed(\n  () =>\n    props.showPassword &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !!nativeInputValue.value &&\n    (!!nativeInputValue.value || focused.value)\n)\nconst isWordLimitVisible = computed(\n  () =>\n    props.showWordLimit &&\n    !!attrs.value.maxlength &&\n    (props.type === 'text' || props.type === 'textarea') &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !props.showPassword\n)\nconst textLength = computed(() => Array.from(nativeInputValue.value).length)\nconst inputExceed = computed(\n  () =>\n    // show exceed style if length of initial value greater then maxlength\n    !!isWordLimitVisible.value &&\n    textLength.value > Number(attrs.value.maxlength)\n)\nconst suffixVisible = computed(\n  () =>\n    !!slots.suffix ||\n    !!props.suffixIcon ||\n    showClear.value ||\n    props.showPassword ||\n    isWordLimitVisible.value ||\n    (!!validateState.value && needStatusIcon.value)\n)\n\nconst [recordCursor, setCursor] = useCursor(input)\n\nuseResizeObserver(textarea, (entries) => {\n  if (!isWordLimitVisible.value || props.resize !== 'both') return\n  const entry = entries[0]\n  const { width } = entry.contentRect\n  countStyle.value = {\n    /** right: 100% - width + padding(15) + right(6) */\n    right: `calc(100% - ${width + 15 + 6}px)`,\n  }\n})\n\nconst resizeTextarea = () => {\n  const { type, autosize } = props\n\n  if (!isClient || type !== 'textarea') return\n\n  if (autosize) {\n    const minRows = isObject(autosize) ? autosize.minRows : undefined\n    const maxRows = isObject(autosize) ? autosize.maxRows : undefined\n    textareaCalcStyle.value = {\n      ...calcTextareaHeight(textarea.value!, minRows, maxRows),\n    }\n  } else {\n    textareaCalcStyle.value = {\n      minHeight: calcTextareaHeight(textarea.value!).minHeight,\n    }\n  }\n}\n\nconst setNativeInputValue = () => {\n  const input = _ref.value\n  if (!input || input.value === nativeInputValue.value) return\n  input.value = nativeInputValue.value\n}\n\nconst handleInput = async (event: Event) => {\n  recordCursor()\n\n  let { value } = event.target as TargetElement\n\n  if (props.formatter) {\n    value = props.parser ? props.parser(value) : value\n    value = props.formatter(value)\n  }\n\n  // should not emit input during composition\n  // see: https://github.com/ElemeFE/element/issues/10516\n  if (isComposing.value) return\n\n  // hack for https://github.com/ElemeFE/element/issues/8548\n  // should remove the following line when we don't support IE\n  if (value === nativeInputValue.value) {\n    setNativeInputValue()\n    return\n  }\n\n  emit(UPDATE_MODEL_EVENT, value)\n  emit('input', value)\n\n  // ensure native input value is controlled\n  // see: https://github.com/ElemeFE/element/issues/12850\n  await nextTick()\n  setNativeInputValue()\n  setCursor()\n}\n\nconst handleChange = (event: Event) => {\n  emit('change', (event.target as TargetElement).value)\n}\n\nconst handleCompositionStart = (event: CompositionEvent) => {\n  emit('compositionstart', event)\n  isComposing.value = true\n}\n\nconst handleCompositionUpdate = (event: CompositionEvent) => {\n  emit('compositionupdate', event)\n  const text = (event.target as HTMLInputElement)?.value\n  const lastCharacter = text[text.length - 1] || ''\n  isComposing.value = !isKorean(lastCharacter)\n}\n\nconst handleCompositionEnd = (event: CompositionEvent) => {\n  emit('compositionend', event)\n  if (isComposing.value) {\n    isComposing.value = false\n    handleInput(event)\n  }\n}\n\nconst handlePasswordVisible = () => {\n  passwordVisible.value = !passwordVisible.value\n  focus()\n}\n\nconst focus = async () => {\n  // see: https://github.com/ElemeFE/element/issues/18573\n  await nextTick()\n  _ref.value?.focus()\n}\n\nconst blur = () => _ref.value?.blur()\n\nconst handleFocus = (event: FocusEvent) => {\n  focused.value = true\n  emit('focus', event)\n}\n\nconst handleBlur = (event: FocusEvent) => {\n  focused.value = false\n  emit('blur', event)\n  if (props.validateEvent) {\n    formItem?.validate?.('blur').catch((err) => debugWarn(err))\n  }\n}\n\nconst handleMouseLeave = (evt: MouseEvent) => {\n  hovering.value = false\n  emit('mouseleave', evt)\n}\n\nconst handleMouseEnter = (evt: MouseEvent) => {\n  hovering.value = true\n  emit('mouseenter', evt)\n}\n\nconst handleKeydown = (evt: KeyboardEvent) => {\n  emit('keydown', evt)\n}\n\nconst select = () => {\n  _ref.value?.select()\n}\n\nconst clear = () => {\n  emit(UPDATE_MODEL_EVENT, '')\n  emit('change', '')\n  emit('clear')\n  emit('input', '')\n}\n\nwatch(\n  () => props.modelValue,\n  () => {\n    nextTick(() => resizeTextarea())\n    if (props.validateEvent) {\n      formItem?.validate?.('change').catch((err) => debugWarn(err))\n    }\n  }\n)\n\n// native input value is set explicitly\n// do not use v-model / :value in template\n// see: https://github.com/ElemeFE/element/issues/14521\nwatch(nativeInputValue, () => setNativeInputValue())\n\n// when change between <input> and <textarea>,\n// update DOM dependent value and styles\n// https://github.com/ElemeFE/element/issues/14857\nwatch(\n  () => props.type,\n  async () => {\n    await nextTick()\n    setNativeInputValue()\n    resizeTextarea()\n  }\n)\n\nonMounted(() => {\n  if (!props.formatter && props.parser) {\n    debugWarn(\n      'ElInput',\n      'If you set the parser, you also need to set the formatter.'\n    )\n  }\n  setNativeInputValue()\n  nextTick(resizeTextarea)\n})\n\ndefineExpose({\n  /** @description HTML input element */\n  input,\n  /** @description HTML textarea element */\n  textarea,\n  /** @description HTML element, input or textarea */\n  ref: _ref,\n  /** @description style of textarea. */\n  textareaStyle,\n\n  /** @description from props (used on unit test) */\n  autosize: toRef(props, 'autosize'),\n\n  /** @description HTML input element native method */\n  focus,\n  /** @description HTML input element native method */\n  blur,\n  /** @description HTML input element native method */\n  select,\n  /** @description clear input value */\n  clear,\n  /** @description resize textarea. */\n  resizeTextarea,\n})\n</script>\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}