{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Data types used in the OpenType font file.\n// All OpenType fonts use Motorola-style byte ordering (Big Endian)\n\nimport check from './check';\nconst LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nconst LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nconst decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nconst encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nconst sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n  return function () {\n    return v;\n  };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function (v) {\n  check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n  return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function (v) {\n  return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function (v) {\n  const b = [];\n  for (let i = 0; i < v.length; i += 1) {\n    b[i] = v.charCodeAt(i);\n  }\n  return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function (v) {\n  return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function (v) {\n  return [v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function (v) {\n  // Two's complement\n  if (v >= LIMIT16) {\n    v = -(2 * LIMIT16 - v);\n  }\n  return [v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function (v) {\n  return [v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function (v) {\n  return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function (v) {\n  // Two's complement\n  if (v >= LIMIT32) {\n    v = -(2 * LIMIT32 - v);\n  }\n  return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function (v) {\n  return [0, 0, 0, 0, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function (v) {\n  check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n  return [v.charCodeAt(0), v.charCodeAt(1), v.charCodeAt(2), v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function (v) {\n  if (v >= -107 && v <= 107) {\n    return [v + 139];\n  } else if (v >= 108 && v <= 1131) {\n    v = v - 108;\n    return [(v >> 8) + 247, v & 0xFF];\n  } else if (v >= -1131 && v <= -108) {\n    v = -v - 108;\n    return [(v >> 8) + 251, v & 0xFF];\n  } else if (v >= -32768 && v <= 32767) {\n    return encode.NUMBER16(v);\n  } else {\n    return encode.NUMBER32(v);\n  }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function (v) {\n  return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function (v) {\n  return [28, v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function (v) {\n  return [29, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function (v) {\n  let value = v.toString();\n\n  // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n  // This code converts it back to a number without the epsilon.\n  const m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n  if (m) {\n    const epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n    value = (Math.round(v * epsilon) / epsilon).toString();\n  }\n  let nibbles = '';\n  for (let i = 0, ii = value.length; i < ii; i += 1) {\n    const c = value[i];\n    if (c === 'e') {\n      nibbles += value[++i] === '-' ? 'c' : 'b';\n    } else if (c === '.') {\n      nibbles += 'a';\n    } else if (c === '-') {\n      nibbles += 'e';\n    } else {\n      nibbles += c;\n    }\n  }\n  nibbles += nibbles.length & 1 ? 'f' : 'ff';\n  const out = [30];\n  for (let i = 0, ii = nibbles.length; i < ii; i += 2) {\n    out.push(parseInt(nibbles.substr(i, 2), 16));\n  }\n  return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function (v) {\n  return encode.REAL(v).length;\n};\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function (data, offset, numBytes) {\n  const codePoints = [];\n  const numChars = numBytes;\n  for (let j = 0; j < numChars; j++, offset += 1) {\n    codePoints[j] = data.getUint8(offset);\n  }\n  return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function (data, offset, numBytes) {\n  const codePoints = [];\n  const numChars = numBytes / 2;\n  for (let j = 0; j < numChars; j++, offset += 2) {\n    codePoints[j] = data.getUint16(offset);\n  }\n  return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function (v) {\n  const b = [];\n  for (let i = 0; i < v.length; i += 1) {\n    const codepoint = v.charCodeAt(i);\n    b[b.length] = codepoint >> 8 & 0xFF;\n    b[b.length] = codepoint & 0xFF;\n  }\n  return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function (v) {\n  return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nconst eightBitMacEncodings = {\n  'x-mac-croatian':\n  // Python: 'mac_croatian'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' + '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n  'x-mac-cyrillic':\n  // Python: 'mac_cyrillic'\n  'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' + 'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n  'x-mac-gaelic':\n  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' + 'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n  'x-mac-greek':\n  // Python: 'mac_greek'\n  'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' + 'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n  'x-mac-icelandic':\n  // Python: 'mac_iceland'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n  'x-mac-inuit':\n  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n  'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' + 'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n  'x-mac-ce':\n  // Python: 'mac_latin2'\n  'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' + 'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n  macintosh:\n  // Python: 'mac_roman'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n  'x-mac-romanian':\n  // Python: 'mac_romanian'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n  'x-mac-turkish':\n  // Python: 'mac_turkish'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function (dataView, offset, dataLength, encoding) {\n  const table = eightBitMacEncodings[encoding];\n  if (table === undefined) {\n    return undefined;\n  }\n  let result = '';\n  for (let i = 0; i < dataLength; i++) {\n    const c = dataView.getUint8(offset + i);\n    // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n    // mapped to U+0000..U+007F; we only need to look up the others.\n    if (c <= 0x7F) {\n      result += String.fromCharCode(c);\n    } else {\n      result += table[c & 0x7F];\n    }\n  }\n  return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nconst macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nlet macEncodingCacheKeys;\nconst getMacEncodingTable = function (encoding) {\n  // Since we use encoding as a cache key for WeakMap, it has to be\n  // a String object and not a literal. And at least on NodeJS 2.10.1,\n  // WeakMap requires that the same String instance is passed for cache hits.\n  if (!macEncodingCacheKeys) {\n    macEncodingCacheKeys = {};\n    for (let e in eightBitMacEncodings) {\n      /*jshint -W053 */ // Suppress \"Do not use String as a constructor.\"\n      macEncodingCacheKeys[e] = new String(e);\n    }\n  }\n  const cacheKey = macEncodingCacheKeys[encoding];\n  if (cacheKey === undefined) {\n    return undefined;\n  }\n\n  // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n  // since garbage collection may run at any time, it could also kick in\n  // between the calls to cache.has() and cache.get(). In that case,\n  // we would return 'undefined' even though we do support the encoding.\n  if (macEncodingTableCache) {\n    const cachedTable = macEncodingTableCache.get(cacheKey);\n    if (cachedTable !== undefined) {\n      return cachedTable;\n    }\n  }\n  const decodingTable = eightBitMacEncodings[encoding];\n  if (decodingTable === undefined) {\n    return undefined;\n  }\n  const encodingTable = {};\n  for (let i = 0; i < decodingTable.length; i++) {\n    encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n  }\n  if (macEncodingTableCache) {\n    macEncodingTableCache.set(cacheKey, encodingTable);\n  }\n  return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function (str, encoding) {\n  const table = getMacEncodingTable(encoding);\n  if (table === undefined) {\n    return undefined;\n  }\n  const result = [];\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n\n    // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n    // mapped to U+0000..U+007F; we only need to look up the others.\n    if (c >= 0x80) {\n      c = table[c];\n      if (c === undefined) {\n        // str contains a Unicode character that cannot be encoded\n        // in the requested encoding.\n        return undefined;\n      }\n    }\n    result[i] = c;\n    // result.push(c);\n  }\n\n  return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function (str, encoding) {\n  const b = encode.MACSTRING(str, encoding);\n  if (b !== undefined) {\n    return b.length;\n  } else {\n    return 0;\n  }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n  return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n  let runLength = 0;\n  const numDeltas = deltas.length;\n  while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n    ++pos;\n    ++runLength;\n  }\n  result.push(0x80 | runLength - 1);\n  return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n  let runLength = 0;\n  const numDeltas = deltas.length;\n  let pos = offset;\n  while (pos < numDeltas && runLength < 64) {\n    const value = deltas[pos];\n    if (!isByteEncodable(value)) {\n      break;\n    }\n\n    // Within a byte-encoded run of deltas, a single zero is best\n    // stored literally as 0x00 value. However, if we have two or\n    // more zeroes in a sequence, it is better to start a new run.\n    // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n    // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n    // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n    // when starting a new run.\n    if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n      break;\n    }\n    ++pos;\n    ++runLength;\n  }\n  result.push(runLength - 1);\n  for (let i = offset; i < pos; ++i) {\n    result.push(deltas[i] + 256 & 0xff);\n  }\n  return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n  let runLength = 0;\n  const numDeltas = deltas.length;\n  let pos = offset;\n  while (pos < numDeltas && runLength < 64) {\n    const value = deltas[pos];\n\n    // Within a word-encoded run of deltas, it is easiest to start\n    // a new run (with a different encoding) whenever we encounter\n    // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n    // needs 7 bytes when storing the zero inside the current run\n    // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n    // new run (40 66 66 80 40 77 77).\n    if (value === 0) {\n      break;\n    }\n\n    // Within a word-encoded run of deltas, a single value in the\n    // range (-128..127) should be encoded within the current run\n    // because it is more compact. For example, the sequence\n    // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n    // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n    // a new run (40 66 66 00 02 40 77 77).\n    if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n      break;\n    }\n    ++pos;\n    ++runLength;\n  }\n  result.push(0x40 | runLength - 1);\n  for (let i = offset; i < pos; ++i) {\n    const val = deltas[i];\n    result.push(val + 0x10000 >> 8 & 0xff, val + 0x100 & 0xff);\n  }\n  return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function (deltas) {\n  let pos = 0;\n  const result = [];\n  while (pos < deltas.length) {\n    const value = deltas[pos];\n    if (value === 0) {\n      pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n    } else if (value >= -128 && value <= 127) {\n      pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n    } else {\n      pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n    }\n  }\n  return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function (l) {\n  //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n  //    i, v;\n  // Because we have to know which data type to use to encode the offsets,\n  // we have to go through the values twice: once to encode the data and\n  // calculate the offsets, then again to encode the offsets using the fitting data type.\n  let offset = 1; // First offset is always 1.\n  const offsets = [offset];\n  const data = [];\n  for (let i = 0; i < l.length; i += 1) {\n    const v = encode.OBJECT(l[i]);\n    Array.prototype.push.apply(data, v);\n    offset += v.length;\n    offsets.push(offset);\n  }\n  if (data.length === 0) {\n    return [0, 0];\n  }\n  const encodedOffsets = [];\n  const offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;\n  const offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n  for (let i = 0; i < offsets.length; i += 1) {\n    const encodedOffset = offsetEncoder(offsets[i]);\n    Array.prototype.push.apply(encodedOffsets, encodedOffset);\n  }\n  return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function (v) {\n  return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function (m) {\n  let d = [];\n  const keys = Object.keys(m);\n  const length = keys.length;\n  for (let i = 0; i < length; i += 1) {\n    // Object.keys() return string keys, but our keys are always numeric.\n    const k = parseInt(keys[i], 0);\n    const v = m[k];\n    // Value comes before the key.\n    d = d.concat(encode.OPERAND(v.value, v.type));\n    d = d.concat(encode.OPERATOR(k));\n  }\n  return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function (m) {\n  return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function (v) {\n  if (v < 1200) {\n    return [v];\n  } else {\n    return [12, v - 1200];\n  }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function (v, type) {\n  let d = [];\n  if (Array.isArray(type)) {\n    for (let i = 0; i < type.length; i += 1) {\n      check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n      d = d.concat(encode.OPERAND(v[i], type[i]));\n    }\n  } else {\n    if (type === 'SID') {\n      d = d.concat(encode.NUMBER(v));\n    } else if (type === 'offset') {\n      // We make it easy for ourselves and always encode offsets as\n      // 4 bytes. This makes offset calculation for the top dict easier.\n      d = d.concat(encode.NUMBER32(v));\n    } else if (type === 'number') {\n      d = d.concat(encode.NUMBER(v));\n    } else if (type === 'real') {\n      d = d.concat(encode.REAL(v));\n    } else {\n      throw new Error('Unknown operand type ' + type);\n      // FIXME Add support for booleans\n    }\n  }\n\n  return d;\n};\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nconst wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function (ops) {\n  // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n  if (wmm) {\n    const cachedValue = wmm.get(ops);\n    if (cachedValue !== undefined) {\n      return cachedValue;\n    }\n  }\n  let d = [];\n  const length = ops.length;\n  for (let i = 0; i < length; i += 1) {\n    const op = ops[i];\n    d = d.concat(encode[op.type](op.value));\n  }\n  if (wmm) {\n    wmm.set(ops, d);\n  }\n  return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function (ops) {\n  return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function (v) {\n  const encodingFunction = encode[v.type];\n  check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n  return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function (v) {\n  const sizeOfFunction = sizeOf[v.type];\n  check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n  return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function (table) {\n  let d = [];\n  const length = table.fields.length;\n  const subtables = [];\n  const subtableOffsets = [];\n  for (let i = 0; i < length; i += 1) {\n    const field = table.fields[i];\n    const encodingFunction = encode[field.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n    let value = table[field.name];\n    if (value === undefined) {\n      value = field.value;\n    }\n    const bytes = encodingFunction(value);\n    if (field.type === 'TABLE') {\n      subtableOffsets.push(d.length);\n      d = d.concat([0, 0]);\n      subtables.push(bytes);\n    } else {\n      d = d.concat(bytes);\n    }\n  }\n  for (let i = 0; i < subtables.length; i += 1) {\n    const o = subtableOffsets[i];\n    const offset = d.length;\n    check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n    d[o] = offset >> 8;\n    d[o + 1] = offset & 0xff;\n    d = d.concat(subtables[i]);\n  }\n  return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function (table) {\n  let numBytes = 0;\n  const length = table.fields.length;\n  for (let i = 0; i < length; i += 1) {\n    const field = table.fields[i];\n    const sizeOfFunction = sizeOf[field.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n    let value = table[field.name];\n    if (value === undefined) {\n      value = field.value;\n    }\n    numBytes += sizeOfFunction(value);\n\n    // Subtables take 2 more bytes for offsets.\n    if (field.type === 'TABLE') {\n      numBytes += 2;\n    }\n  }\n  return numBytes;\n};\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function (v) {\n  return v;\n};\nsizeOf.LITERAL = function (v) {\n  return v.length;\n};\nexport { decode, encode, sizeOf };","map":{"version":3,"names":["check","LIMIT16","LIMIT32","decode","encode","sizeOf","constant","v","BYTE","argument","CHAR","charCodeAt","CHARARRAY","b","i","length","USHORT","SHORT","UINT24","ULONG","LONG","FIXED","FWORD","UFWORD","LONGDATETIME","TAG","Card8","Card16","OffSize","SID","NUMBER","NUMBER16","NUMBER32","REAL","value","toString","m","exec","epsilon","parseFloat","Math","round","nibbles","ii","c","out","push","parseInt","substr","NAME","STRING","UTF8","data","offset","numBytes","codePoints","numChars","j","getUint8","String","fromCharCode","apply","UTF16","getUint16","codepoint","eightBitMacEncodings","macintosh","MACSTRING","dataView","dataLength","encoding","table","undefined","result","macEncodingTableCache","WeakMap","macEncodingCacheKeys","getMacEncodingTable","e","cacheKey","cachedTable","get","decodingTable","encodingTable","set","str","isByteEncodable","encodeVarDeltaRunAsZeroes","deltas","pos","runLength","numDeltas","encodeVarDeltaRunAsBytes","encodeVarDeltaRunAsWords","val","VARDELTAS","INDEX","l","offsets","OBJECT","Array","prototype","encodedOffsets","offSize","floor","log","offsetEncoder","encodedOffset","concat","DICT","d","keys","Object","k","OPERAND","type","OPERATOR","isArray","Error","OP","wmm","CHARSTRING","ops","cachedValue","op","encodingFunction","sizeOfFunction","TABLE","fields","subtables","subtableOffsets","field","name","bytes","o","tableName","RECORD","LITERAL"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/opentype.js/src/types.js"],"sourcesContent":["// Data types used in the OpenType font file.\n// All OpenType fonts use Motorola-style byte ordering (Big Endian)\n\nimport check from './check';\n\nconst LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nconst LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nconst decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nconst encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nconst sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function(v) {\n    const b = [];\n    for (let i = 0; i < v.length; i += 1) {\n        b[i] = v.charCodeAt(i);\n    }\n\n    return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function(v) {\n    return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function(v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function(v) {\n    let value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    const m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        const epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    let nibbles = '';\n    for (let i = 0, ii = value.length; i < ii; i += 1) {\n        const c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    const out = [30];\n    for (let i = 0, ii = nibbles.length; i < ii; i += 2) {\n        out.push(parseInt(nibbles.substr(i, 2), 16));\n    }\n\n    return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    const codePoints = [];\n    const numChars = numBytes;\n    for (let j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    const codePoints = [];\n    const numChars = numBytes / 2;\n    for (let j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function(v) {\n    const b = [];\n    for (let i = 0; i < v.length; i += 1) {\n        const codepoint = v.charCodeAt(i);\n        b[b.length] = (codepoint >> 8) & 0xFF;\n        b[b.length] = codepoint & 0xFF;\n    }\n\n    return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nconst eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n    macintosh:  // Python: 'mac_roman'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    const table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    let result = '';\n    for (let i = 0; i < dataLength; i++) {\n        const c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nconst macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nlet macEncodingCacheKeys;\nconst getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n        macEncodingCacheKeys = {};\n        for (let e in eightBitMacEncodings) {\n            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n            macEncodingCacheKeys[e] = new String(e);\n        }\n    }\n\n    const cacheKey = macEncodingCacheKeys[encoding];\n    if (cacheKey === undefined) {\n        return undefined;\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n        const cachedTable = macEncodingTableCache.get(cacheKey);\n        if (cachedTable !== undefined) {\n            return cachedTable;\n        }\n    }\n\n    const decodingTable = eightBitMacEncodings[encoding];\n    if (decodingTable === undefined) {\n        return undefined;\n    }\n\n    const encodingTable = {};\n    for (let i = 0; i < decodingTable.length; i++) {\n        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n    }\n\n    if (macEncodingTableCache) {\n        macEncodingTableCache.set(cacheKey, encodingTable);\n    }\n\n    return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function(str, encoding) {\n    const table = getMacEncodingTable(encoding);\n    if (table === undefined) {\n        return undefined;\n    }\n\n    const result = [];\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c >= 0x80) {\n            c = table[c];\n            if (c === undefined) {\n                // str contains a Unicode character that cannot be encoded\n                // in the requested encoding.\n                return undefined;\n            }\n        }\n        result[i] = c;\n        // result.push(c);\n    }\n\n    return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function(str, encoding) {\n    const b = encode.MACSTRING(str, encoding);\n    if (b !== undefined) {\n        return b.length;\n    } else {\n        return 0;\n    }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n    return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    let runLength = 0;\n    const numDeltas = deltas.length;\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x80 | (runLength - 1));\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    let runLength = 0;\n    const numDeltas = deltas.length;\n    let pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        const value = deltas[pos];\n        if (!isByteEncodable(value)) {\n            break;\n        }\n\n        // Within a byte-encoded run of deltas, a single zero is best\n        // stored literally as 0x00 value. However, if we have two or\n        // more zeroes in a sequence, it is better to start a new run.\n        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n        // when starting a new run.\n        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(runLength - 1);\n    for (let i = offset; i < pos; ++i) {\n        result.push((deltas[i] + 256) & 0xff);\n    }\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n    let runLength = 0;\n    const numDeltas = deltas.length;\n    let pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        const value = deltas[pos];\n\n        // Within a word-encoded run of deltas, it is easiest to start\n        // a new run (with a different encoding) whenever we encounter\n        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n        // needs 7 bytes when storing the zero inside the current run\n        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n        // new run (40 66 66 80 40 77 77).\n        if (value === 0) {\n            break;\n        }\n\n        // Within a word-encoded run of deltas, a single value in the\n        // range (-128..127) should be encoded within the current run\n        // because it is more compact. For example, the sequence\n        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n        // a new run (40 66 66 00 02 40 77 77).\n        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x40 | (runLength - 1));\n    for (let i = offset; i < pos; ++i) {\n        const val = deltas[i];\n        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n    }\n    return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function(deltas) {\n    let pos = 0;\n    const result = [];\n    while (pos < deltas.length) {\n        const value = deltas[pos];\n        if (value === 0) {\n            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n        } else if (value >= -128 && value <= 127) {\n            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n        } else {\n            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n        }\n    }\n    return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function(l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    let offset = 1; // First offset is always 1.\n    const offsets = [offset];\n    const data = [];\n    for (let i = 0; i < l.length; i += 1) {\n        const v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    const encodedOffsets = [];\n    const offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n    const offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (let i = 0; i < offsets.length; i += 1) {\n        const encodedOffset = offsetEncoder(offsets[i]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function(m) {\n    let d = [];\n    const keys = Object.keys(m);\n    const length = keys.length;\n\n    for (let i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        const k = parseInt(keys[i], 0);\n        const v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function(v, type) {\n    let d = [];\n    if (Array.isArray(type)) {\n        for (let i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nconst wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function(ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n        const cachedValue = wmm.get(ops);\n        if (cachedValue !== undefined) {\n            return cachedValue;\n        }\n    }\n\n    let d = [];\n    const length = ops.length;\n\n    for (let i = 0; i < length; i += 1) {\n        const op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function(v) {\n    const encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function(v) {\n    const sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function(table) {\n    let d = [];\n    const length = table.fields.length;\n    const subtables = [];\n    const subtableOffsets = [];\n\n    for (let i = 0; i < length; i += 1) {\n        const field = table.fields[i];\n        const encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n        let value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        const bytes = encodingFunction(value);\n\n        if (field.type === 'TABLE') {\n            subtableOffsets.push(d.length);\n            d = d.concat([0, 0]);\n            subtables.push(bytes);\n        } else {\n            d = d.concat(bytes);\n        }\n    }\n\n    for (let i = 0; i < subtables.length; i += 1) {\n        const o = subtableOffsets[i];\n        const offset = d.length;\n        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n        d[o] = offset >> 8;\n        d[o + 1] = offset & 0xff;\n        d = d.concat(subtables[i]);\n    }\n\n    return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function(table) {\n    let numBytes = 0;\n    const length = table.fields.length;\n\n    for (let i = 0; i < length; i += 1) {\n        const field = table.fields[i];\n        const sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n        let value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n\n        // Subtables take 2 more bytes for offsets.\n        if (field.type === 'TABLE') {\n            numBytes += 2;\n        }\n    }\n\n    return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\nexport { decode, encode, sizeOf };\n"],"mappings":";AAAA;AACA;;AAEA,OAAOA,KAAK,MAAM,SAAS;AAE3B,MAAMC,OAAO,GAAG,KAAK,CAAC,CAAC;AACvB,MAAMC,OAAO,GAAG,UAAU,CAAC,CAAC;;AAE5B;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAG,CAAC,CAAC;AACjB;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAG,CAAC,CAAC;AACjB;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAG,CAAC,CAAC;;AAEjB;AACA,SAASC,QAAQ,CAACC,CAAC,EAAE;EACjB,OAAO,YAAW;IACd,OAAOA,CAAC;EACZ,CAAC;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACAH,MAAM,CAACI,IAAI,GAAG,UAASD,CAAC,EAAE;EACtBP,KAAK,CAACS,QAAQ,CAACF,CAAC,IAAI,CAAC,IAAIA,CAAC,IAAI,GAAG,EAAE,yCAAyC,CAAC;EAC7E,OAAO,CAACA,CAAC,CAAC;AACd,CAAC;AACD;AACA;AACA;AACA;AACAF,MAAM,CAACG,IAAI,GAAGF,QAAQ,CAAC,CAAC,CAAC;;AAEzB;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACM,IAAI,GAAG,UAASH,CAAC,EAAE;EACtB,OAAO,CAACA,CAAC,CAACI,UAAU,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACAN,MAAM,CAACK,IAAI,GAAGJ,QAAQ,CAAC,CAAC,CAAC;;AAEzB;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACQ,SAAS,GAAG,UAASL,CAAC,EAAE;EAC3B,MAAMM,CAAC,GAAG,EAAE;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,CAACQ,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAClCD,CAAC,CAACC,CAAC,CAAC,GAAGP,CAAC,CAACI,UAAU,CAACG,CAAC,CAAC;EAC1B;EAEA,OAAOD,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACAR,MAAM,CAACO,SAAS,GAAG,UAASL,CAAC,EAAE;EAC3B,OAAOA,CAAC,CAACQ,MAAM;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAX,MAAM,CAACY,MAAM,GAAG,UAAST,CAAC,EAAE;EACxB,OAAO,CAAEA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AACtC,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACW,MAAM,GAAGV,QAAQ,CAAC,CAAC,CAAC;;AAE3B;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACa,KAAK,GAAG,UAASV,CAAC,EAAE;EACvB;EACA,IAAIA,CAAC,IAAIN,OAAO,EAAE;IACdM,CAAC,GAAG,EAAE,CAAC,GAAGN,OAAO,GAAGM,CAAC,CAAC;EAC1B;EAEA,OAAO,CAAEA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AACtC,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACY,KAAK,GAAGX,QAAQ,CAAC,CAAC,CAAC;;AAE1B;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACc,MAAM,GAAG,UAASX,CAAC,EAAE;EACxB,OAAO,CAAEA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACa,MAAM,GAAGZ,QAAQ,CAAC,CAAC,CAAC;;AAE3B;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACe,KAAK,GAAG,UAASZ,CAAC,EAAE;EACvB,OAAO,CAAEA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AAC1E,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACc,KAAK,GAAGb,QAAQ,CAAC,CAAC,CAAC;;AAE1B;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACgB,IAAI,GAAG,UAASb,CAAC,EAAE;EACtB;EACA,IAAIA,CAAC,IAAIL,OAAO,EAAE;IACdK,CAAC,GAAG,EAAE,CAAC,GAAGL,OAAO,GAAGK,CAAC,CAAC;EAC1B;EAEA,OAAO,CAAEA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AAC1E,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACe,IAAI,GAAGd,QAAQ,CAAC,CAAC,CAAC;AAEzBF,MAAM,CAACiB,KAAK,GAAGjB,MAAM,CAACe,KAAK;AAC3Bd,MAAM,CAACgB,KAAK,GAAGhB,MAAM,CAACc,KAAK;AAE3Bf,MAAM,CAACkB,KAAK,GAAGlB,MAAM,CAACa,KAAK;AAC3BZ,MAAM,CAACiB,KAAK,GAAGjB,MAAM,CAACY,KAAK;AAE3Bb,MAAM,CAACmB,MAAM,GAAGnB,MAAM,CAACY,MAAM;AAC7BX,MAAM,CAACkB,MAAM,GAAGlB,MAAM,CAACW,MAAM;;AAE7B;AACA;AACA;AACA;AACA;AACAZ,MAAM,CAACoB,YAAY,GAAG,UAASjB,CAAC,EAAE;EAC9B,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAGA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AACtF,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACmB,YAAY,GAAGlB,QAAQ,CAAC,CAAC,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACAF,MAAM,CAACqB,GAAG,GAAG,UAASlB,CAAC,EAAE;EACrBP,KAAK,CAACS,QAAQ,CAACF,CAAC,CAACQ,MAAM,KAAK,CAAC,EAAE,2CAA2C,CAAC;EAC3E,OAAO,CAACR,CAAC,CAACI,UAAU,CAAC,CAAC,CAAC,EACfJ,CAAC,CAACI,UAAU,CAAC,CAAC,CAAC,EACfJ,CAAC,CAACI,UAAU,CAAC,CAAC,CAAC,EACfJ,CAAC,CAACI,UAAU,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACAN,MAAM,CAACoB,GAAG,GAAGnB,QAAQ,CAAC,CAAC,CAAC;;AAExB;;AAEAF,MAAM,CAACsB,KAAK,GAAGtB,MAAM,CAACI,IAAI;AAC1BH,MAAM,CAACqB,KAAK,GAAGrB,MAAM,CAACG,IAAI;AAE1BJ,MAAM,CAACuB,MAAM,GAAGvB,MAAM,CAACY,MAAM;AAC7BX,MAAM,CAACsB,MAAM,GAAGtB,MAAM,CAACW,MAAM;AAE7BZ,MAAM,CAACwB,OAAO,GAAGxB,MAAM,CAACI,IAAI;AAC5BH,MAAM,CAACuB,OAAO,GAAGvB,MAAM,CAACG,IAAI;AAE5BJ,MAAM,CAACyB,GAAG,GAAGzB,MAAM,CAACY,MAAM;AAC1BX,MAAM,CAACwB,GAAG,GAAGxB,MAAM,CAACW,MAAM;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACAZ,MAAM,CAAC0B,MAAM,GAAG,UAASvB,CAAC,EAAE;EACxB,IAAIA,CAAC,IAAI,CAAC,GAAG,IAAIA,CAAC,IAAI,GAAG,EAAE;IACvB,OAAO,CAACA,CAAC,GAAG,GAAG,CAAC;EACpB,CAAC,MAAM,IAAIA,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAI,IAAI,EAAE;IAC9BA,CAAC,GAAGA,CAAC,GAAG,GAAG;IACX,OAAO,CAAC,CAACA,CAAC,IAAI,CAAC,IAAI,GAAG,EAAEA,CAAC,GAAG,IAAI,CAAC;EACrC,CAAC,MAAM,IAAIA,CAAC,IAAI,CAAC,IAAI,IAAIA,CAAC,IAAI,CAAC,GAAG,EAAE;IAChCA,CAAC,GAAG,CAACA,CAAC,GAAG,GAAG;IACZ,OAAO,CAAC,CAACA,CAAC,IAAI,CAAC,IAAI,GAAG,EAAEA,CAAC,GAAG,IAAI,CAAC;EACrC,CAAC,MAAM,IAAIA,CAAC,IAAI,CAAC,KAAK,IAAIA,CAAC,IAAI,KAAK,EAAE;IAClC,OAAOH,MAAM,CAAC2B,QAAQ,CAACxB,CAAC,CAAC;EAC7B,CAAC,MAAM;IACH,OAAOH,MAAM,CAAC4B,QAAQ,CAACzB,CAAC,CAAC;EAC7B;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAACyB,MAAM,GAAG,UAASvB,CAAC,EAAE;EACxB,OAAOH,MAAM,CAAC0B,MAAM,CAACvB,CAAC,CAAC,CAACQ,MAAM;AAClC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAX,MAAM,CAAC2B,QAAQ,GAAG,UAASxB,CAAC,EAAE;EAC1B,OAAO,CAAC,EAAE,EAAGA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAAC0B,QAAQ,GAAGzB,QAAQ,CAAC,CAAC,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,MAAM,CAAC4B,QAAQ,GAAG,UAASzB,CAAC,EAAE;EAC1B,OAAO,CAAC,EAAE,EAAGA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,EAAE,GAAI,IAAI,EAAGA,CAAC,IAAI,CAAC,GAAI,IAAI,EAAEA,CAAC,GAAG,IAAI,CAAC;AAC9E,CAAC;;AAED;AACA;AACA;AACA;AACAF,MAAM,CAAC2B,QAAQ,GAAG1B,QAAQ,CAAC,CAAC,CAAC;;AAE7B;AACA;AACA;AACA;AACAF,MAAM,CAAC6B,IAAI,GAAG,UAAS1B,CAAC,EAAE;EACtB,IAAI2B,KAAK,GAAG3B,CAAC,CAAC4B,QAAQ,EAAE;;EAExB;EACA;EACA,MAAMC,CAAC,GAAG,+CAA+C,CAACC,IAAI,CAACH,KAAK,CAAC;EACrE,IAAIE,CAAC,EAAE;IACH,MAAME,OAAO,GAAGC,UAAU,CAAC,IAAI,IAAI,CAACH,CAAC,CAAC,CAAC,CAAC,GAAG,CAACA,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM,CAAC,CAAC;IACrEmB,KAAK,GAAG,CAACM,IAAI,CAACC,KAAK,CAAClC,CAAC,GAAG+B,OAAO,CAAC,GAAGA,OAAO,EAAEH,QAAQ,EAAE;EAC1D;EAEA,IAAIO,OAAO,GAAG,EAAE;EAChB,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAE6B,EAAE,GAAGT,KAAK,CAACnB,MAAM,EAAED,CAAC,GAAG6B,EAAE,EAAE7B,CAAC,IAAI,CAAC,EAAE;IAC/C,MAAM8B,CAAC,GAAGV,KAAK,CAACpB,CAAC,CAAC;IAClB,IAAI8B,CAAC,KAAK,GAAG,EAAE;MACXF,OAAO,IAAIR,KAAK,CAAC,EAAEpB,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;IAC7C,CAAC,MAAM,IAAI8B,CAAC,KAAK,GAAG,EAAE;MAClBF,OAAO,IAAI,GAAG;IAClB,CAAC,MAAM,IAAIE,CAAC,KAAK,GAAG,EAAE;MAClBF,OAAO,IAAI,GAAG;IAClB,CAAC,MAAM;MACHA,OAAO,IAAIE,CAAC;IAChB;EACJ;EAEAF,OAAO,IAAKA,OAAO,CAAC3B,MAAM,GAAG,CAAC,GAAI,GAAG,GAAG,IAAI;EAC5C,MAAM8B,GAAG,GAAG,CAAC,EAAE,CAAC;EAChB,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAE6B,EAAE,GAAGD,OAAO,CAAC3B,MAAM,EAAED,CAAC,GAAG6B,EAAE,EAAE7B,CAAC,IAAI,CAAC,EAAE;IACjD+B,GAAG,CAACC,IAAI,CAACC,QAAQ,CAACL,OAAO,CAACM,MAAM,CAAClC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EAChD;EAEA,OAAO+B,GAAG;AACd,CAAC;;AAED;AACA;AACA;AACA;AACAxC,MAAM,CAAC4B,IAAI,GAAG,UAAS1B,CAAC,EAAE;EACtB,OAAOH,MAAM,CAAC6B,IAAI,CAAC1B,CAAC,CAAC,CAACQ,MAAM;AAChC,CAAC;AAEDX,MAAM,CAAC6C,IAAI,GAAG7C,MAAM,CAACQ,SAAS;AAC9BP,MAAM,CAAC4C,IAAI,GAAG5C,MAAM,CAACO,SAAS;AAE9BR,MAAM,CAAC8C,MAAM,GAAG9C,MAAM,CAACQ,SAAS;AAChCP,MAAM,CAAC6C,MAAM,GAAG7C,MAAM,CAACO,SAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACAT,MAAM,CAACgD,IAAI,GAAG,UAASC,IAAI,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC3C,MAAMC,UAAU,GAAG,EAAE;EACrB,MAAMC,QAAQ,GAAGF,QAAQ;EACzB,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,EAAEC,CAAC,EAAE,EAAEJ,MAAM,IAAI,CAAC,EAAE;IAC5CE,UAAU,CAACE,CAAC,CAAC,GAAGL,IAAI,CAACM,QAAQ,CAACL,MAAM,CAAC;EACzC;EAEA,OAAOM,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEN,UAAU,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACApD,MAAM,CAAC2D,KAAK,GAAG,UAASV,IAAI,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC5C,MAAMC,UAAU,GAAG,EAAE;EACrB,MAAMC,QAAQ,GAAGF,QAAQ,GAAG,CAAC;EAC7B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,EAAEC,CAAC,EAAE,EAAEJ,MAAM,IAAI,CAAC,EAAE;IAC5CE,UAAU,CAACE,CAAC,CAAC,GAAGL,IAAI,CAACW,SAAS,CAACV,MAAM,CAAC;EAC1C;EAEA,OAAOM,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEN,UAAU,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAnD,MAAM,CAAC0D,KAAK,GAAG,UAASvD,CAAC,EAAE;EACvB,MAAMM,CAAC,GAAG,EAAE;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,CAACQ,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAClC,MAAMkD,SAAS,GAAGzD,CAAC,CAACI,UAAU,CAACG,CAAC,CAAC;IACjCD,CAAC,CAACA,CAAC,CAACE,MAAM,CAAC,GAAIiD,SAAS,IAAI,CAAC,GAAI,IAAI;IACrCnD,CAAC,CAACA,CAAC,CAACE,MAAM,CAAC,GAAGiD,SAAS,GAAG,IAAI;EAClC;EAEA,OAAOnD,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACAR,MAAM,CAACyD,KAAK,GAAG,UAASvD,CAAC,EAAE;EACvB,OAAOA,CAAC,CAACQ,MAAM,GAAG,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMkD,oBAAoB,GAAG;EACzB,gBAAgB;EAAG;EACnB,kEAAkE,GAClE,kEAAkE;EAClE,gBAAgB;EAAG;EACnB,kEAAkE,GAClE,iEAAiE;EACjE,cAAc;EAAE;EAChB,kEAAkE,GAClE,kEAAkE;EAClE,aAAa;EAAG;EAChB,kEAAkE,GAClE,uEAAuE;EACvE,iBAAiB;EAAG;EACpB,kEAAkE,GAClE,kEAAkE;EAClE,aAAa;EAAE;EACf,kEAAkE,GAClE,kEAAkE;EAClE,UAAU;EAAG;EACb,kEAAkE,GAClE,kEAAkE;EAClEC,SAAS;EAAG;EACZ,kEAAkE,GAClE,kEAAkE;EAClE,gBAAgB;EAAG;EACnB,kEAAkE,GAClE,kEAAkE;EAClE,eAAe;EAAG;EAClB,kEAAkE,GAClE;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/D,MAAM,CAACgE,SAAS,GAAG,UAASC,QAAQ,EAAEf,MAAM,EAAEgB,UAAU,EAAEC,QAAQ,EAAE;EAChE,MAAMC,KAAK,GAAGN,oBAAoB,CAACK,QAAQ,CAAC;EAC5C,IAAIC,KAAK,KAAKC,SAAS,EAAE;IACrB,OAAOA,SAAS;EACpB;EAEA,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAI3D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuD,UAAU,EAAEvD,CAAC,EAAE,EAAE;IACjC,MAAM8B,CAAC,GAAGwB,QAAQ,CAACV,QAAQ,CAACL,MAAM,GAAGvC,CAAC,CAAC;IACvC;IACA;IACA,IAAI8B,CAAC,IAAI,IAAI,EAAE;MACX6B,MAAM,IAAId,MAAM,CAACC,YAAY,CAAChB,CAAC,CAAC;IACpC,CAAC,MAAM;MACH6B,MAAM,IAAIF,KAAK,CAAC3B,CAAC,GAAG,IAAI,CAAC;IAC7B;EACJ;EAEA,OAAO6B,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,OAAOC,OAAO,KAAK,UAAU,IAAI,IAAIA,OAAO,EAAE;AAC5E,IAAIC,oBAAoB;AACxB,MAAMC,mBAAmB,GAAG,UAAUP,QAAQ,EAAE;EAC5C;EACA;EACA;EACA,IAAI,CAACM,oBAAoB,EAAE;IACvBA,oBAAoB,GAAG,CAAC,CAAC;IACzB,KAAK,IAAIE,CAAC,IAAIb,oBAAoB,EAAE;MAChC,kBAAmB;MACnBW,oBAAoB,CAACE,CAAC,CAAC,GAAG,IAAInB,MAAM,CAACmB,CAAC,CAAC;IAC3C;EACJ;EAEA,MAAMC,QAAQ,GAAGH,oBAAoB,CAACN,QAAQ,CAAC;EAC/C,IAAIS,QAAQ,KAAKP,SAAS,EAAE;IACxB,OAAOA,SAAS;EACpB;;EAEA;EACA;EACA;EACA;EACA,IAAIE,qBAAqB,EAAE;IACvB,MAAMM,WAAW,GAAGN,qBAAqB,CAACO,GAAG,CAACF,QAAQ,CAAC;IACvD,IAAIC,WAAW,KAAKR,SAAS,EAAE;MAC3B,OAAOQ,WAAW;IACtB;EACJ;EAEA,MAAME,aAAa,GAAGjB,oBAAoB,CAACK,QAAQ,CAAC;EACpD,IAAIY,aAAa,KAAKV,SAAS,EAAE;IAC7B,OAAOA,SAAS;EACpB;EAEA,MAAMW,aAAa,GAAG,CAAC,CAAC;EACxB,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoE,aAAa,CAACnE,MAAM,EAAED,CAAC,EAAE,EAAE;IAC3CqE,aAAa,CAACD,aAAa,CAACvE,UAAU,CAACG,CAAC,CAAC,CAAC,GAAGA,CAAC,GAAG,IAAI;EACzD;EAEA,IAAI4D,qBAAqB,EAAE;IACvBA,qBAAqB,CAACU,GAAG,CAACL,QAAQ,EAAEI,aAAa,CAAC;EACtD;EAEA,OAAOA,aAAa;AACxB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/E,MAAM,CAAC+D,SAAS,GAAG,UAASkB,GAAG,EAAEf,QAAQ,EAAE;EACvC,MAAMC,KAAK,GAAGM,mBAAmB,CAACP,QAAQ,CAAC;EAC3C,IAAIC,KAAK,KAAKC,SAAS,EAAE;IACrB,OAAOA,SAAS;EACpB;EAEA,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,IAAI3D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuE,GAAG,CAACtE,MAAM,EAAED,CAAC,EAAE,EAAE;IACjC,IAAI8B,CAAC,GAAGyC,GAAG,CAAC1E,UAAU,CAACG,CAAC,CAAC;;IAEzB;IACA;IACA,IAAI8B,CAAC,IAAI,IAAI,EAAE;MACXA,CAAC,GAAG2B,KAAK,CAAC3B,CAAC,CAAC;MACZ,IAAIA,CAAC,KAAK4B,SAAS,EAAE;QACjB;QACA;QACA,OAAOA,SAAS;MACpB;IACJ;IACAC,MAAM,CAAC3D,CAAC,CAAC,GAAG8B,CAAC;IACb;EACJ;;EAEA,OAAO6B,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACApE,MAAM,CAAC8D,SAAS,GAAG,UAASkB,GAAG,EAAEf,QAAQ,EAAE;EACvC,MAAMzD,CAAC,GAAGT,MAAM,CAAC+D,SAAS,CAACkB,GAAG,EAAEf,QAAQ,CAAC;EACzC,IAAIzD,CAAC,KAAK2D,SAAS,EAAE;IACjB,OAAO3D,CAAC,CAACE,MAAM;EACnB,CAAC,MAAM;IACH,OAAO,CAAC;EACZ;AACJ,CAAC;;AAED;AACA,SAASuE,eAAe,CAACpD,KAAK,EAAE;EAC5B,OAAOA,KAAK,IAAI,CAAC,GAAG,IAAIA,KAAK,IAAI,GAAG;AACxC;;AAEA;AACA,SAASqD,yBAAyB,CAACC,MAAM,EAAEC,GAAG,EAAEhB,MAAM,EAAE;EACpD,IAAIiB,SAAS,GAAG,CAAC;EACjB,MAAMC,SAAS,GAAGH,MAAM,CAACzE,MAAM;EAC/B,OAAO0E,GAAG,GAAGE,SAAS,IAAID,SAAS,GAAG,EAAE,IAAIF,MAAM,CAACC,GAAG,CAAC,KAAK,CAAC,EAAE;IAC3D,EAAEA,GAAG;IACL,EAAEC,SAAS;EACf;EACAjB,MAAM,CAAC3B,IAAI,CAAC,IAAI,GAAI4C,SAAS,GAAG,CAAE,CAAC;EACnC,OAAOD,GAAG;AACd;;AAEA;AACA,SAASG,wBAAwB,CAACJ,MAAM,EAAEnC,MAAM,EAAEoB,MAAM,EAAE;EACtD,IAAIiB,SAAS,GAAG,CAAC;EACjB,MAAMC,SAAS,GAAGH,MAAM,CAACzE,MAAM;EAC/B,IAAI0E,GAAG,GAAGpC,MAAM;EAChB,OAAOoC,GAAG,GAAGE,SAAS,IAAID,SAAS,GAAG,EAAE,EAAE;IACtC,MAAMxD,KAAK,GAAGsD,MAAM,CAACC,GAAG,CAAC;IACzB,IAAI,CAACH,eAAe,CAACpD,KAAK,CAAC,EAAE;MACzB;IACJ;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIA,KAAK,KAAK,CAAC,IAAIuD,GAAG,GAAG,CAAC,GAAGE,SAAS,IAAIH,MAAM,CAACC,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;MAC7D;IACJ;IAEA,EAAEA,GAAG;IACL,EAAEC,SAAS;EACf;EACAjB,MAAM,CAAC3B,IAAI,CAAC4C,SAAS,GAAG,CAAC,CAAC;EAC1B,KAAK,IAAI5E,CAAC,GAAGuC,MAAM,EAAEvC,CAAC,GAAG2E,GAAG,EAAE,EAAE3E,CAAC,EAAE;IAC/B2D,MAAM,CAAC3B,IAAI,CAAE0C,MAAM,CAAC1E,CAAC,CAAC,GAAG,GAAG,GAAI,IAAI,CAAC;EACzC;EACA,OAAO2E,GAAG;AACd;;AAEA;AACA,SAASI,wBAAwB,CAACL,MAAM,EAAEnC,MAAM,EAAEoB,MAAM,EAAE;EACtD,IAAIiB,SAAS,GAAG,CAAC;EACjB,MAAMC,SAAS,GAAGH,MAAM,CAACzE,MAAM;EAC/B,IAAI0E,GAAG,GAAGpC,MAAM;EAChB,OAAOoC,GAAG,GAAGE,SAAS,IAAID,SAAS,GAAG,EAAE,EAAE;IACtC,MAAMxD,KAAK,GAAGsD,MAAM,CAACC,GAAG,CAAC;;IAEzB;IACA;IACA;IACA;IACA;IACA;IACA,IAAIvD,KAAK,KAAK,CAAC,EAAE;MACb;IACJ;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIoD,eAAe,CAACpD,KAAK,CAAC,IAAIuD,GAAG,GAAG,CAAC,GAAGE,SAAS,IAAIL,eAAe,CAACE,MAAM,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE;MACnF;IACJ;IAEA,EAAEA,GAAG;IACL,EAAEC,SAAS;EACf;EACAjB,MAAM,CAAC3B,IAAI,CAAC,IAAI,GAAI4C,SAAS,GAAG,CAAE,CAAC;EACnC,KAAK,IAAI5E,CAAC,GAAGuC,MAAM,EAAEvC,CAAC,GAAG2E,GAAG,EAAE,EAAE3E,CAAC,EAAE;IAC/B,MAAMgF,GAAG,GAAGN,MAAM,CAAC1E,CAAC,CAAC;IACrB2D,MAAM,CAAC3B,IAAI,CAAGgD,GAAG,GAAG,OAAO,IAAK,CAAC,GAAI,IAAI,EAAGA,GAAG,GAAG,KAAK,GAAI,IAAI,CAAC;EACpE;EACA,OAAOL,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArF,MAAM,CAAC2F,SAAS,GAAG,UAASP,MAAM,EAAE;EAChC,IAAIC,GAAG,GAAG,CAAC;EACX,MAAMhB,MAAM,GAAG,EAAE;EACjB,OAAOgB,GAAG,GAAGD,MAAM,CAACzE,MAAM,EAAE;IACxB,MAAMmB,KAAK,GAAGsD,MAAM,CAACC,GAAG,CAAC;IACzB,IAAIvD,KAAK,KAAK,CAAC,EAAE;MACbuD,GAAG,GAAGF,yBAAyB,CAACC,MAAM,EAAEC,GAAG,EAAEhB,MAAM,CAAC;IACxD,CAAC,MAAM,IAAIvC,KAAK,IAAI,CAAC,GAAG,IAAIA,KAAK,IAAI,GAAG,EAAE;MACtCuD,GAAG,GAAGG,wBAAwB,CAACJ,MAAM,EAAEC,GAAG,EAAEhB,MAAM,CAAC;IACvD,CAAC,MAAM;MACHgB,GAAG,GAAGI,wBAAwB,CAACL,MAAM,EAAEC,GAAG,EAAEhB,MAAM,CAAC;IACvD;EACJ;EACA,OAAOA,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACArE,MAAM,CAAC4F,KAAK,GAAG,UAASC,CAAC,EAAE;EACvB;EACA;EACA;EACA;EACA;EACA,IAAI5C,MAAM,GAAG,CAAC,CAAC,CAAC;EAChB,MAAM6C,OAAO,GAAG,CAAC7C,MAAM,CAAC;EACxB,MAAMD,IAAI,GAAG,EAAE;EACf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmF,CAAC,CAAClF,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAClC,MAAMP,CAAC,GAAGH,MAAM,CAAC+F,MAAM,CAACF,CAAC,CAACnF,CAAC,CAAC,CAAC;IAC7BsF,KAAK,CAACC,SAAS,CAACvD,IAAI,CAACe,KAAK,CAACT,IAAI,EAAE7C,CAAC,CAAC;IACnC8C,MAAM,IAAI9C,CAAC,CAACQ,MAAM;IAClBmF,OAAO,CAACpD,IAAI,CAACO,MAAM,CAAC;EACxB;EAEA,IAAID,IAAI,CAACrC,MAAM,KAAK,CAAC,EAAE;IACnB,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EACjB;EAEA,MAAMuF,cAAc,GAAG,EAAE;EACzB,MAAMC,OAAO,GAAI,CAAC,GAAG/D,IAAI,CAACgE,KAAK,CAAChE,IAAI,CAACiE,GAAG,CAACpD,MAAM,CAAC,GAAGb,IAAI,CAACiE,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAI,CAAC;EACxE,MAAMC,aAAa,GAAG,CAAClC,SAAS,EAAEpE,MAAM,CAACI,IAAI,EAAEJ,MAAM,CAACY,MAAM,EAAEZ,MAAM,CAACc,MAAM,EAAEd,MAAM,CAACe,KAAK,CAAC,CAACoF,OAAO,CAAC;EACnG,KAAK,IAAIzF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoF,OAAO,CAACnF,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACxC,MAAM6F,aAAa,GAAGD,aAAa,CAACR,OAAO,CAACpF,CAAC,CAAC,CAAC;IAC/CsF,KAAK,CAACC,SAAS,CAACvD,IAAI,CAACe,KAAK,CAACyC,cAAc,EAAEK,aAAa,CAAC;EAC7D;EAEA,OAAOP,KAAK,CAACC,SAAS,CAACO,MAAM,CAACxG,MAAM,CAACuB,MAAM,CAACsE,CAAC,CAAClF,MAAM,CAAC,EAC9BX,MAAM,CAACwB,OAAO,CAAC2E,OAAO,CAAC,EACvBD,cAAc,EACdlD,IAAI,CAAC;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA/C,MAAM,CAAC2F,KAAK,GAAG,UAASzF,CAAC,EAAE;EACvB,OAAOH,MAAM,CAAC4F,KAAK,CAACzF,CAAC,CAAC,CAACQ,MAAM;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,MAAM,CAACyG,IAAI,GAAG,UAASzE,CAAC,EAAE;EACtB,IAAI0E,CAAC,GAAG,EAAE;EACV,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAC3E,CAAC,CAAC;EAC3B,MAAMrB,MAAM,GAAGgG,IAAI,CAAChG,MAAM;EAE1B,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAChC;IACA,MAAMmG,CAAC,GAAGlE,QAAQ,CAACgE,IAAI,CAACjG,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9B,MAAMP,CAAC,GAAG6B,CAAC,CAAC6E,CAAC,CAAC;IACd;IACAH,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAAC8G,OAAO,CAAC3G,CAAC,CAAC2B,KAAK,EAAE3B,CAAC,CAAC4G,IAAI,CAAC,CAAC;IAC7CL,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAACgH,QAAQ,CAACH,CAAC,CAAC,CAAC;EACpC;EAEA,OAAOH,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACAzG,MAAM,CAACwG,IAAI,GAAG,UAASzE,CAAC,EAAE;EACtB,OAAOhC,MAAM,CAACyG,IAAI,CAACzE,CAAC,CAAC,CAACrB,MAAM;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACAX,MAAM,CAACgH,QAAQ,GAAG,UAAS7G,CAAC,EAAE;EAC1B,IAAIA,CAAC,GAAG,IAAI,EAAE;IACV,OAAO,CAACA,CAAC,CAAC;EACd,CAAC,MAAM;IACH,OAAO,CAAC,EAAE,EAAEA,CAAC,GAAG,IAAI,CAAC;EACzB;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAH,MAAM,CAAC8G,OAAO,GAAG,UAAS3G,CAAC,EAAE4G,IAAI,EAAE;EAC/B,IAAIL,CAAC,GAAG,EAAE;EACV,IAAIV,KAAK,CAACiB,OAAO,CAACF,IAAI,CAAC,EAAE;IACrB,KAAK,IAAIrG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqG,IAAI,CAACpG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MACrCd,KAAK,CAACS,QAAQ,CAACF,CAAC,CAACQ,MAAM,KAAKoG,IAAI,CAACpG,MAAM,EAAE,qCAAqC,GAAGoG,IAAI,CAAC;MACtFL,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAAC8G,OAAO,CAAC3G,CAAC,CAACO,CAAC,CAAC,EAAEqG,IAAI,CAACrG,CAAC,CAAC,CAAC,CAAC;IAC/C;EACJ,CAAC,MAAM;IACH,IAAIqG,IAAI,KAAK,KAAK,EAAE;MAChBL,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAAC0B,MAAM,CAACvB,CAAC,CAAC,CAAC;IAClC,CAAC,MAAM,IAAI4G,IAAI,KAAK,QAAQ,EAAE;MAC1B;MACA;MACAL,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAAC4B,QAAQ,CAACzB,CAAC,CAAC,CAAC;IACpC,CAAC,MAAM,IAAI4G,IAAI,KAAK,QAAQ,EAAE;MAC1BL,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAAC0B,MAAM,CAACvB,CAAC,CAAC,CAAC;IAClC,CAAC,MAAM,IAAI4G,IAAI,KAAK,MAAM,EAAE;MACxBL,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAAC6B,IAAI,CAAC1B,CAAC,CAAC,CAAC;IAChC,CAAC,MAAM;MACH,MAAM,IAAI+G,KAAK,CAAC,uBAAuB,GAAGH,IAAI,CAAC;MAC/C;IACJ;EACJ;;EAEA,OAAOL,CAAC;AACZ,CAAC;AAED1G,MAAM,CAACmH,EAAE,GAAGnH,MAAM,CAACI,IAAI;AACvBH,MAAM,CAACkH,EAAE,GAAGlH,MAAM,CAACG,IAAI;;AAEvB;AACA,MAAMgH,GAAG,GAAG,OAAO7C,OAAO,KAAK,UAAU,IAAI,IAAIA,OAAO,EAAE;;AAE1D;AACA;AACA;AACA;AACA;AACAvE,MAAM,CAACqH,UAAU,GAAG,UAASC,GAAG,EAAE;EAC9B;EACA,IAAIF,GAAG,EAAE;IACL,MAAMG,WAAW,GAAGH,GAAG,CAACvC,GAAG,CAACyC,GAAG,CAAC;IAChC,IAAIC,WAAW,KAAKnD,SAAS,EAAE;MAC3B,OAAOmD,WAAW;IACtB;EACJ;EAEA,IAAIb,CAAC,GAAG,EAAE;EACV,MAAM/F,MAAM,GAAG2G,GAAG,CAAC3G,MAAM;EAEzB,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAChC,MAAM8G,EAAE,GAAGF,GAAG,CAAC5G,CAAC,CAAC;IACjBgG,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACxG,MAAM,CAACwH,EAAE,CAACT,IAAI,CAAC,CAACS,EAAE,CAAC1F,KAAK,CAAC,CAAC;EAC3C;EAEA,IAAIsF,GAAG,EAAE;IACLA,GAAG,CAACpC,GAAG,CAACsC,GAAG,EAAEZ,CAAC,CAAC;EACnB;EAEA,OAAOA,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACAzG,MAAM,CAACoH,UAAU,GAAG,UAASC,GAAG,EAAE;EAC9B,OAAOtH,MAAM,CAACqH,UAAU,CAACC,GAAG,CAAC,CAAC3G,MAAM;AACxC,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACAX,MAAM,CAAC+F,MAAM,GAAG,UAAS5F,CAAC,EAAE;EACxB,MAAMsH,gBAAgB,GAAGzH,MAAM,CAACG,CAAC,CAAC4G,IAAI,CAAC;EACvCnH,KAAK,CAACS,QAAQ,CAACoH,gBAAgB,KAAKrD,SAAS,EAAE,gCAAgC,GAAGjE,CAAC,CAAC4G,IAAI,CAAC;EACzF,OAAOU,gBAAgB,CAACtH,CAAC,CAAC2B,KAAK,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA7B,MAAM,CAAC8F,MAAM,GAAG,UAAS5F,CAAC,EAAE;EACxB,MAAMuH,cAAc,GAAGzH,MAAM,CAACE,CAAC,CAAC4G,IAAI,CAAC;EACrCnH,KAAK,CAACS,QAAQ,CAACqH,cAAc,KAAKtD,SAAS,EAAE,8BAA8B,GAAGjE,CAAC,CAAC4G,IAAI,CAAC;EACrF,OAAOW,cAAc,CAACvH,CAAC,CAAC2B,KAAK,CAAC;AAClC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA9B,MAAM,CAAC2H,KAAK,GAAG,UAASxD,KAAK,EAAE;EAC3B,IAAIuC,CAAC,GAAG,EAAE;EACV,MAAM/F,MAAM,GAAGwD,KAAK,CAACyD,MAAM,CAACjH,MAAM;EAClC,MAAMkH,SAAS,GAAG,EAAE;EACpB,MAAMC,eAAe,GAAG,EAAE;EAE1B,KAAK,IAAIpH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAChC,MAAMqH,KAAK,GAAG5D,KAAK,CAACyD,MAAM,CAAClH,CAAC,CAAC;IAC7B,MAAM+G,gBAAgB,GAAGzH,MAAM,CAAC+H,KAAK,CAAChB,IAAI,CAAC;IAC3CnH,KAAK,CAACS,QAAQ,CAACoH,gBAAgB,KAAKrD,SAAS,EAAE,sCAAsC,GAAG2D,KAAK,CAAChB,IAAI,GAAG,IAAI,GAAGgB,KAAK,CAACC,IAAI,GAAG,GAAG,CAAC;IAC7H,IAAIlG,KAAK,GAAGqC,KAAK,CAAC4D,KAAK,CAACC,IAAI,CAAC;IAC7B,IAAIlG,KAAK,KAAKsC,SAAS,EAAE;MACrBtC,KAAK,GAAGiG,KAAK,CAACjG,KAAK;IACvB;IAEA,MAAMmG,KAAK,GAAGR,gBAAgB,CAAC3F,KAAK,CAAC;IAErC,IAAIiG,KAAK,CAAChB,IAAI,KAAK,OAAO,EAAE;MACxBe,eAAe,CAACpF,IAAI,CAACgE,CAAC,CAAC/F,MAAM,CAAC;MAC9B+F,CAAC,GAAGA,CAAC,CAACF,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACpBqB,SAAS,CAACnF,IAAI,CAACuF,KAAK,CAAC;IACzB,CAAC,MAAM;MACHvB,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACyB,KAAK,CAAC;IACvB;EACJ;EAEA,KAAK,IAAIvH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmH,SAAS,CAAClH,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAC1C,MAAMwH,CAAC,GAAGJ,eAAe,CAACpH,CAAC,CAAC;IAC5B,MAAMuC,MAAM,GAAGyD,CAAC,CAAC/F,MAAM;IACvBf,KAAK,CAACS,QAAQ,CAAC4C,MAAM,GAAG,KAAK,EAAE,QAAQ,GAAGkB,KAAK,CAACgE,SAAS,GAAG,WAAW,CAAC;IACxEzB,CAAC,CAACwB,CAAC,CAAC,GAAGjF,MAAM,IAAI,CAAC;IAClByD,CAAC,CAACwB,CAAC,GAAG,CAAC,CAAC,GAAGjF,MAAM,GAAG,IAAI;IACxByD,CAAC,GAAGA,CAAC,CAACF,MAAM,CAACqB,SAAS,CAACnH,CAAC,CAAC,CAAC;EAC9B;EAEA,OAAOgG,CAAC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACAzG,MAAM,CAAC0H,KAAK,GAAG,UAASxD,KAAK,EAAE;EAC3B,IAAIjB,QAAQ,GAAG,CAAC;EAChB,MAAMvC,MAAM,GAAGwD,KAAK,CAACyD,MAAM,CAACjH,MAAM;EAElC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAChC,MAAMqH,KAAK,GAAG5D,KAAK,CAACyD,MAAM,CAAClH,CAAC,CAAC;IAC7B,MAAMgH,cAAc,GAAGzH,MAAM,CAAC8H,KAAK,CAAChB,IAAI,CAAC;IACzCnH,KAAK,CAACS,QAAQ,CAACqH,cAAc,KAAKtD,SAAS,EAAE,oCAAoC,GAAG2D,KAAK,CAAChB,IAAI,GAAG,IAAI,GAAGgB,KAAK,CAACC,IAAI,GAAG,GAAG,CAAC;IACzH,IAAIlG,KAAK,GAAGqC,KAAK,CAAC4D,KAAK,CAACC,IAAI,CAAC;IAC7B,IAAIlG,KAAK,KAAKsC,SAAS,EAAE;MACrBtC,KAAK,GAAGiG,KAAK,CAACjG,KAAK;IACvB;IAEAoB,QAAQ,IAAIwE,cAAc,CAAC5F,KAAK,CAAC;;IAEjC;IACA,IAAIiG,KAAK,CAAChB,IAAI,KAAK,OAAO,EAAE;MACxB7D,QAAQ,IAAI,CAAC;IACjB;EACJ;EAEA,OAAOA,QAAQ;AACnB,CAAC;AAEDlD,MAAM,CAACoI,MAAM,GAAGpI,MAAM,CAAC2H,KAAK;AAC5B1H,MAAM,CAACmI,MAAM,GAAGnI,MAAM,CAAC0H,KAAK;;AAE5B;AACA3H,MAAM,CAACqI,OAAO,GAAG,UAASlI,CAAC,EAAE;EACzB,OAAOA,CAAC;AACZ,CAAC;AAEDF,MAAM,CAACoI,OAAO,GAAG,UAASlI,CAAC,EAAE;EACzB,OAAOA,CAAC,CAACQ,MAAM;AACnB,CAAC;AAED,SAASZ,MAAM,EAAEC,MAAM,EAAEC,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}