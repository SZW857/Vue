{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// The `GPOS` table contains kerning pairs, among other things.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\n\nimport check from '../check';\nimport parse from '../parse';\n\n// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.\n// These lists are unused by now, this function is just the basis for a real parsing.\nfunction parseTaggedListTable(data, start) {\n  const p = new parse.Parser(data, start);\n  const n = p.parseUShort();\n  const list = [];\n  for (let i = 0; i < n; i++) {\n    list[p.parseTag()] = {\n      offset: p.parseUShort()\n    };\n  }\n  return list;\n}\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// Format 1 is a simple list of glyph ids,\n// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.\nfunction parseCoverageTable(data, start) {\n  const p = new parse.Parser(data, start);\n  const format = p.parseUShort();\n  let count = p.parseUShort();\n  if (format === 1) {\n    return p.parseUShortList(count);\n  } else if (format === 2) {\n    const coverage = [];\n    for (; count--;) {\n      const begin = p.parseUShort();\n      const end = p.parseUShort();\n      let index = p.parseUShort();\n      for (let i = begin; i <= end; i++) {\n        coverage[index++] = i;\n      }\n    }\n    return coverage;\n  }\n}\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// Returns a function that gets a class value from a glyph ID.\nfunction parseClassDefTable(data, start) {\n  const p = new parse.Parser(data, start);\n  const format = p.parseUShort();\n  if (format === 1) {\n    // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.\n    const startGlyph = p.parseUShort();\n    const glyphCount = p.parseUShort();\n    const classes = p.parseUShortList(glyphCount);\n    return function (glyphID) {\n      return classes[glyphID - startGlyph] || 0;\n    };\n  } else if (format === 2) {\n    // Format 2 defines multiple groups of glyph indices that belong to the same class.\n    const rangeCount = p.parseUShort();\n    const startGlyphs = [];\n    const endGlyphs = [];\n    const classValues = [];\n    for (let i = 0; i < rangeCount; i++) {\n      startGlyphs[i] = p.parseUShort();\n      endGlyphs[i] = p.parseUShort();\n      classValues[i] = p.parseUShort();\n    }\n    return function (glyphID) {\n      let l = 0;\n      let r = startGlyphs.length - 1;\n      while (l < r) {\n        const c = l + r + 1 >> 1;\n        if (glyphID < startGlyphs[c]) {\n          r = c - 1;\n        } else {\n          l = c;\n        }\n      }\n      if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {\n        return classValues[l] || 0;\n      }\n      return 0;\n    };\n  }\n}\n\n// Parse a pair adjustment positioning subtable, format 1 or format 2\n// The subtable is returned in the form of a lookup function.\nfunction parsePairPosSubTable(data, start) {\n  const p = new parse.Parser(data, start);\n  // This part is common to format 1 and format 2 subtables\n  const format = p.parseUShort();\n  const coverageOffset = p.parseUShort();\n  const coverage = parseCoverageTable(data, start + coverageOffset);\n  // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph\n  // Only valueFormat1=4 and valueFormat2=0 is supported.\n  const valueFormat1 = p.parseUShort();\n  const valueFormat2 = p.parseUShort();\n  let value1;\n  let value2;\n  if (valueFormat1 !== 4 || valueFormat2 !== 0) return;\n  const sharedPairSets = {};\n  if (format === 1) {\n    // Pair Positioning Adjustment: Format 1\n    const pairSetCount = p.parseUShort();\n    const pairSet = [];\n    // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index\n    const pairSetOffsets = p.parseOffset16List(pairSetCount);\n    for (let firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {\n      const pairSetOffset = pairSetOffsets[firstGlyph];\n      let sharedPairSet = sharedPairSets[pairSetOffset];\n      if (!sharedPairSet) {\n        // Parse a pairset table in a pair adjustment subtable format 1\n        sharedPairSet = {};\n        p.relativeOffset = pairSetOffset;\n        let pairValueCount = p.parseUShort();\n        for (; pairValueCount--;) {\n          const secondGlyph = p.parseUShort();\n          if (valueFormat1) value1 = p.parseShort();\n          if (valueFormat2) value2 = p.parseShort();\n          // We only support valueFormat1 = 4 and valueFormat2 = 0,\n          // so value1 is the XAdvance and value2 is empty.\n          sharedPairSet[secondGlyph] = value1;\n        }\n      }\n      pairSet[coverage[firstGlyph]] = sharedPairSet;\n    }\n    return function (leftGlyph, rightGlyph) {\n      const pairs = pairSet[leftGlyph];\n      if (pairs) return pairs[rightGlyph];\n    };\n  } else if (format === 2) {\n    // Pair Positioning Adjustment: Format 2\n    const classDef1Offset = p.parseUShort();\n    const classDef2Offset = p.parseUShort();\n    const class1Count = p.parseUShort();\n    const class2Count = p.parseUShort();\n    const getClass1 = parseClassDefTable(data, start + classDef1Offset);\n    const getClass2 = parseClassDefTable(data, start + classDef2Offset);\n\n    // Parse kerning values by class pair.\n    const kerningMatrix = [];\n    for (let i = 0; i < class1Count; i++) {\n      const kerningRow = kerningMatrix[i] = [];\n      for (let j = 0; j < class2Count; j++) {\n        if (valueFormat1) value1 = p.parseShort();\n        if (valueFormat2) value2 = p.parseShort();\n        // We only support valueFormat1 = 4 and valueFormat2 = 0,\n        // so value1 is the XAdvance and value2 is empty.\n        kerningRow[j] = value1;\n      }\n    }\n\n    // Convert coverage list to a hash\n    const covered = {};\n    for (let i = 0; i < coverage.length; i++) {\n      covered[coverage[i]] = 1;\n    }\n\n    // Get the kerning value for a specific glyph pair.\n    return function (leftGlyph, rightGlyph) {\n      if (!covered[leftGlyph]) return;\n      const class1 = getClass1(leftGlyph);\n      const class2 = getClass2(rightGlyph);\n      const kerningRow = kerningMatrix[class1];\n      if (kerningRow) {\n        return kerningRow[class2];\n      }\n    };\n  }\n}\n\n// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).\nfunction parseLookupTable(data, start) {\n  const p = new parse.Parser(data, start);\n  const lookupType = p.parseUShort();\n  const lookupFlag = p.parseUShort();\n  const useMarkFilteringSet = lookupFlag & 0x10;\n  const subTableCount = p.parseUShort();\n  const subTableOffsets = p.parseOffset16List(subTableCount);\n  const table = {\n    lookupType: lookupType,\n    lookupFlag: lookupFlag,\n    markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1\n  };\n  // LookupType 2, Pair adjustment\n  if (lookupType === 2) {\n    const subtables = [];\n    for (let i = 0; i < subTableCount; i++) {\n      const pairPosSubTable = parsePairPosSubTable(data, start + subTableOffsets[i]);\n      if (pairPosSubTable) subtables.push(pairPosSubTable);\n    }\n    // Return a function which finds the kerning values in the subtables.\n    table.getKerningValue = function (leftGlyph, rightGlyph) {\n      for (let i = subtables.length; i--;) {\n        const value = subtables[i](leftGlyph, rightGlyph);\n        if (value !== undefined) return value;\n      }\n      return 0;\n    };\n  }\n  return table;\n}\n\n// Parse the `GPOS` table which contains, among other things, kerning pairs.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\nfunction parseGposTable(data, start, font) {\n  const p = new parse.Parser(data, start);\n  const tableVersion = p.parseFixed();\n  check.argument(tableVersion === 1, 'Unsupported GPOS table version.');\n\n  // ScriptList and FeatureList - ignored for now\n  parseTaggedListTable(data, start + p.parseUShort());\n  // 'kern' is the feature we are looking for.\n  parseTaggedListTable(data, start + p.parseUShort());\n\n  // LookupList\n  const lookupListOffset = p.parseUShort();\n  p.relativeOffset = lookupListOffset;\n  const lookupCount = p.parseUShort();\n  const lookupTableOffsets = p.parseOffset16List(lookupCount);\n  const lookupListAbsoluteOffset = start + lookupListOffset;\n  for (let i = 0; i < lookupCount; i++) {\n    const table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);\n    if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;\n  }\n}\nexport default {\n  parse: parseGposTable\n};","map":{"version":3,"names":["check","parse","parseTaggedListTable","data","start","p","Parser","n","parseUShort","list","i","parseTag","offset","parseCoverageTable","format","count","parseUShortList","coverage","begin","end","index","parseClassDefTable","startGlyph","glyphCount","classes","glyphID","rangeCount","startGlyphs","endGlyphs","classValues","l","r","length","c","parsePairPosSubTable","coverageOffset","valueFormat1","valueFormat2","value1","value2","sharedPairSets","pairSetCount","pairSet","pairSetOffsets","parseOffset16List","firstGlyph","pairSetOffset","sharedPairSet","relativeOffset","pairValueCount","secondGlyph","parseShort","leftGlyph","rightGlyph","pairs","classDef1Offset","classDef2Offset","class1Count","class2Count","getClass1","getClass2","kerningMatrix","kerningRow","j","covered","class1","class2","parseLookupTable","lookupType","lookupFlag","useMarkFilteringSet","subTableCount","subTableOffsets","table","markFilteringSet","subtables","pairPosSubTable","push","getKerningValue","value","undefined","parseGposTable","font","tableVersion","parseFixed","argument","lookupListOffset","lookupCount","lookupTableOffsets","lookupListAbsoluteOffset","getGposKerningValue"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/opentype.js/src/tables/gpos.js"],"sourcesContent":["// The `GPOS` table contains kerning pairs, among other things.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\n\nimport check from '../check';\nimport parse from '../parse';\n\n// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.\n// These lists are unused by now, this function is just the basis for a real parsing.\nfunction parseTaggedListTable(data, start) {\n    const p = new parse.Parser(data, start);\n    const n = p.parseUShort();\n    const list = [];\n    for (let i = 0; i < n; i++) {\n        list[p.parseTag()] = { offset: p.parseUShort() };\n    }\n\n    return list;\n}\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// Format 1 is a simple list of glyph ids,\n// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.\nfunction parseCoverageTable(data, start) {\n    const p = new parse.Parser(data, start);\n    const format = p.parseUShort();\n    let count = p.parseUShort();\n    if (format === 1) {\n        return p.parseUShortList(count);\n    } else if (format === 2) {\n        const coverage = [];\n        for (; count--;) {\n            const begin = p.parseUShort();\n            const end = p.parseUShort();\n            let index = p.parseUShort();\n            for (let i = begin; i <= end; i++) {\n                coverage[index++] = i;\n            }\n        }\n\n        return coverage;\n    }\n}\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// Returns a function that gets a class value from a glyph ID.\nfunction parseClassDefTable(data, start) {\n    const p = new parse.Parser(data, start);\n    const format = p.parseUShort();\n    if (format === 1) {\n        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.\n        const startGlyph = p.parseUShort();\n        const glyphCount = p.parseUShort();\n        const classes = p.parseUShortList(glyphCount);\n        return function(glyphID) {\n            return classes[glyphID - startGlyph] || 0;\n        };\n    } else if (format === 2) {\n        // Format 2 defines multiple groups of glyph indices that belong to the same class.\n        const rangeCount = p.parseUShort();\n        const startGlyphs = [];\n        const endGlyphs = [];\n        const classValues = [];\n        for (let i = 0; i < rangeCount; i++) {\n            startGlyphs[i] = p.parseUShort();\n            endGlyphs[i] = p.parseUShort();\n            classValues[i] = p.parseUShort();\n        }\n\n        return function(glyphID) {\n            let l = 0;\n            let r = startGlyphs.length - 1;\n            while (l < r) {\n                const c = (l + r + 1) >> 1;\n                if (glyphID < startGlyphs[c]) {\n                    r = c - 1;\n                } else {\n                    l = c;\n                }\n            }\n\n            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {\n                return classValues[l] || 0;\n            }\n\n            return 0;\n        };\n    }\n}\n\n// Parse a pair adjustment positioning subtable, format 1 or format 2\n// The subtable is returned in the form of a lookup function.\nfunction parsePairPosSubTable(data, start) {\n    const p = new parse.Parser(data, start);\n    // This part is common to format 1 and format 2 subtables\n    const format = p.parseUShort();\n    const coverageOffset = p.parseUShort();\n    const coverage = parseCoverageTable(data, start + coverageOffset);\n    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph\n    // Only valueFormat1=4 and valueFormat2=0 is supported.\n    const valueFormat1 = p.parseUShort();\n    const valueFormat2 = p.parseUShort();\n    let value1;\n    let value2;\n    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;\n    const sharedPairSets = {};\n    if (format === 1) {\n        // Pair Positioning Adjustment: Format 1\n        const pairSetCount = p.parseUShort();\n        const pairSet = [];\n        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index\n        const pairSetOffsets = p.parseOffset16List(pairSetCount);\n        for (let firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {\n            const pairSetOffset = pairSetOffsets[firstGlyph];\n            let sharedPairSet = sharedPairSets[pairSetOffset];\n            if (!sharedPairSet) {\n                // Parse a pairset table in a pair adjustment subtable format 1\n                sharedPairSet = {};\n                p.relativeOffset = pairSetOffset;\n                let pairValueCount = p.parseUShort();\n                for (; pairValueCount--;) {\n                    const secondGlyph = p.parseUShort();\n                    if (valueFormat1) value1 = p.parseShort();\n                    if (valueFormat2) value2 = p.parseShort();\n                    // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                    // so value1 is the XAdvance and value2 is empty.\n                    sharedPairSet[secondGlyph] = value1;\n                }\n            }\n\n            pairSet[coverage[firstGlyph]] = sharedPairSet;\n        }\n\n        return function(leftGlyph, rightGlyph) {\n            const pairs = pairSet[leftGlyph];\n            if (pairs) return pairs[rightGlyph];\n        };\n    } else if (format === 2) {\n        // Pair Positioning Adjustment: Format 2\n        const classDef1Offset = p.parseUShort();\n        const classDef2Offset = p.parseUShort();\n        const class1Count = p.parseUShort();\n        const class2Count = p.parseUShort();\n        const getClass1 = parseClassDefTable(data, start + classDef1Offset);\n        const getClass2 = parseClassDefTable(data, start + classDef2Offset);\n\n        // Parse kerning values by class pair.\n        const kerningMatrix = [];\n        for (let i = 0; i < class1Count; i++) {\n            const kerningRow = kerningMatrix[i] = [];\n            for (let j = 0; j < class2Count; j++) {\n                if (valueFormat1) value1 = p.parseShort();\n                if (valueFormat2) value2 = p.parseShort();\n                // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                // so value1 is the XAdvance and value2 is empty.\n                kerningRow[j] = value1;\n            }\n        }\n\n        // Convert coverage list to a hash\n        const covered = {};\n        for (let i = 0; i < coverage.length; i++) {\n            covered[coverage[i]] = 1;\n        }\n\n        // Get the kerning value for a specific glyph pair.\n        return function(leftGlyph, rightGlyph) {\n            if (!covered[leftGlyph]) return;\n            const class1 = getClass1(leftGlyph);\n            const class2 = getClass2(rightGlyph);\n            const kerningRow = kerningMatrix[class1];\n\n            if (kerningRow) {\n                return kerningRow[class2];\n            }\n        };\n    }\n}\n\n// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).\nfunction parseLookupTable(data, start) {\n    const p = new parse.Parser(data, start);\n    const lookupType = p.parseUShort();\n    const lookupFlag = p.parseUShort();\n    const useMarkFilteringSet = lookupFlag & 0x10;\n    const subTableCount = p.parseUShort();\n    const subTableOffsets = p.parseOffset16List(subTableCount);\n    const table = {\n        lookupType: lookupType,\n        lookupFlag: lookupFlag,\n        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1\n    };\n    // LookupType 2, Pair adjustment\n    if (lookupType === 2) {\n        const subtables = [];\n        for (let i = 0; i < subTableCount; i++) {\n            const pairPosSubTable = parsePairPosSubTable(data, start + subTableOffsets[i]);\n            if (pairPosSubTable) subtables.push(pairPosSubTable);\n        }\n        // Return a function which finds the kerning values in the subtables.\n        table.getKerningValue = function(leftGlyph, rightGlyph) {\n            for (let i = subtables.length; i--;) {\n                const value = subtables[i](leftGlyph, rightGlyph);\n                if (value !== undefined) return value;\n            }\n\n            return 0;\n        };\n    }\n\n    return table;\n}\n\n// Parse the `GPOS` table which contains, among other things, kerning pairs.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\nfunction parseGposTable(data, start, font) {\n    const p = new parse.Parser(data, start);\n    const tableVersion = p.parseFixed();\n    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');\n\n    // ScriptList and FeatureList - ignored for now\n    parseTaggedListTable(data, start + p.parseUShort());\n    // 'kern' is the feature we are looking for.\n    parseTaggedListTable(data, start + p.parseUShort());\n\n    // LookupList\n    const lookupListOffset = p.parseUShort();\n    p.relativeOffset = lookupListOffset;\n    const lookupCount = p.parseUShort();\n    const lookupTableOffsets = p.parseOffset16List(lookupCount);\n    const lookupListAbsoluteOffset = start + lookupListOffset;\n    for (let i = 0; i < lookupCount; i++) {\n        const table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);\n        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;\n    }\n}\n\nexport default { parse: parseGposTable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}