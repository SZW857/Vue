{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// The `glyf` table describes the glyphs in TrueType outline format.\n// http://www.microsoft.com/typography/otspec/glyf.htm\n\nimport check from '../check';\nimport glyphset from '../glyphset';\nimport parse from '../parse';\nimport Path from '../path';\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n  let v;\n  if ((flag & shortVectorBitMask) > 0) {\n    // The coordinate is 1 byte long.\n    v = p.parseByte();\n    // The `same` bit is re-used for short values to signify the sign of the value.\n    if ((flag & sameBitMask) === 0) {\n      v = -v;\n    }\n    v = previousValue + v;\n  } else {\n    //  The coordinate is 2 bytes long.\n    // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n    if ((flag & sameBitMask) > 0) {\n      v = previousValue;\n    } else {\n      // Parse the coordinate as a signed 16-bit delta value.\n      v = previousValue + p.parseShort();\n    }\n  }\n  return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n  const p = new parse.Parser(data, start);\n  glyph.numberOfContours = p.parseShort();\n  glyph._xMin = p.parseShort();\n  glyph._yMin = p.parseShort();\n  glyph._xMax = p.parseShort();\n  glyph._yMax = p.parseShort();\n  let flags;\n  let flag;\n  if (glyph.numberOfContours > 0) {\n    // This glyph is not a composite.\n    const endPointIndices = glyph.endPointIndices = [];\n    for (let i = 0; i < glyph.numberOfContours; i += 1) {\n      endPointIndices.push(p.parseUShort());\n    }\n    glyph.instructionLength = p.parseUShort();\n    glyph.instructions = [];\n    for (let i = 0; i < glyph.instructionLength; i += 1) {\n      glyph.instructions.push(p.parseByte());\n    }\n    const numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n    flags = [];\n    for (let i = 0; i < numberOfCoordinates; i += 1) {\n      flag = p.parseByte();\n      flags.push(flag);\n      // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n      if ((flag & 8) > 0) {\n        const repeatCount = p.parseByte();\n        for (let j = 0; j < repeatCount; j += 1) {\n          flags.push(flag);\n          i += 1;\n        }\n      }\n    }\n    check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n    if (endPointIndices.length > 0) {\n      const points = [];\n      let point;\n      // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n      if (numberOfCoordinates > 0) {\n        for (let i = 0; i < numberOfCoordinates; i += 1) {\n          flag = flags[i];\n          point = {};\n          point.onCurve = !!(flag & 1);\n          point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;\n          points.push(point);\n        }\n        let px = 0;\n        for (let i = 0; i < numberOfCoordinates; i += 1) {\n          flag = flags[i];\n          point = points[i];\n          point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n          px = point.x;\n        }\n        let py = 0;\n        for (let i = 0; i < numberOfCoordinates; i += 1) {\n          flag = flags[i];\n          point = points[i];\n          point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n          py = point.y;\n        }\n      }\n      glyph.points = points;\n    } else {\n      glyph.points = [];\n    }\n  } else if (glyph.numberOfContours === 0) {\n    glyph.points = [];\n  } else {\n    glyph.isComposite = true;\n    glyph.points = [];\n    glyph.components = [];\n    let moreComponents = true;\n    while (moreComponents) {\n      flags = p.parseUShort();\n      const component = {\n        glyphIndex: p.parseUShort(),\n        xScale: 1,\n        scale01: 0,\n        scale10: 0,\n        yScale: 1,\n        dx: 0,\n        dy: 0\n      };\n      if ((flags & 1) > 0) {\n        // The arguments are words\n        if ((flags & 2) > 0) {\n          // values are offset\n          component.dx = p.parseShort();\n          component.dy = p.parseShort();\n        } else {\n          // values are matched points\n          component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n        }\n      } else {\n        // The arguments are bytes\n        if ((flags & 2) > 0) {\n          // values are offset\n          component.dx = p.parseChar();\n          component.dy = p.parseChar();\n        } else {\n          // values are matched points\n          component.matchedPoints = [p.parseByte(), p.parseByte()];\n        }\n      }\n      if ((flags & 8) > 0) {\n        // We have a scale\n        component.xScale = component.yScale = p.parseF2Dot14();\n      } else if ((flags & 64) > 0) {\n        // We have an X / Y scale\n        component.xScale = p.parseF2Dot14();\n        component.yScale = p.parseF2Dot14();\n      } else if ((flags & 128) > 0) {\n        // We have a 2x2 transformation\n        component.xScale = p.parseF2Dot14();\n        component.scale01 = p.parseF2Dot14();\n        component.scale10 = p.parseF2Dot14();\n        component.yScale = p.parseF2Dot14();\n      }\n      glyph.components.push(component);\n      moreComponents = !!(flags & 32);\n    }\n    if (flags & 0x100) {\n      // We have instructions\n      glyph.instructionLength = p.parseUShort();\n      glyph.instructions = [];\n      for (let i = 0; i < glyph.instructionLength; i += 1) {\n        glyph.instructions.push(p.parseByte());\n      }\n    }\n  }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n  const newPoints = [];\n  for (let i = 0; i < points.length; i += 1) {\n    const pt = points[i];\n    const newPt = {\n      x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n      y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n      onCurve: pt.onCurve,\n      lastPointOfContour: pt.lastPointOfContour\n    };\n    newPoints.push(newPt);\n  }\n  return newPoints;\n}\nfunction getContours(points) {\n  const contours = [];\n  let currentContour = [];\n  for (let i = 0; i < points.length; i += 1) {\n    const pt = points[i];\n    currentContour.push(pt);\n    if (pt.lastPointOfContour) {\n      contours.push(currentContour);\n      currentContour = [];\n    }\n  }\n  check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n  return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n  const p = new Path();\n  if (!points) {\n    return p;\n  }\n  const contours = getContours(points);\n  for (let contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n    const contour = contours[contourIndex];\n    let prev = null;\n    let curr = contour[contour.length - 1];\n    let next = contour[0];\n    if (curr.onCurve) {\n      p.moveTo(curr.x, curr.y);\n    } else {\n      if (next.onCurve) {\n        p.moveTo(next.x, next.y);\n      } else {\n        // If both first and last points are off-curve, start at their middle.\n        const start = {\n          x: (curr.x + next.x) * 0.5,\n          y: (curr.y + next.y) * 0.5\n        };\n        p.moveTo(start.x, start.y);\n      }\n    }\n    for (let i = 0; i < contour.length; ++i) {\n      prev = curr;\n      curr = next;\n      next = contour[(i + 1) % contour.length];\n      if (curr.onCurve) {\n        // This is a straight line.\n        p.lineTo(curr.x, curr.y);\n      } else {\n        let prev2 = prev;\n        let next2 = next;\n        if (!prev.onCurve) {\n          prev2 = {\n            x: (curr.x + prev.x) * 0.5,\n            y: (curr.y + prev.y) * 0.5\n          };\n          p.lineTo(prev2.x, prev2.y);\n        }\n        if (!next.onCurve) {\n          next2 = {\n            x: (curr.x + next.x) * 0.5,\n            y: (curr.y + next.y) * 0.5\n          };\n        }\n        p.lineTo(prev2.x, prev2.y);\n        p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n      }\n    }\n    p.closePath();\n  }\n  return p;\n}\nfunction buildPath(glyphs, glyph) {\n  if (glyph.isComposite) {\n    for (let j = 0; j < glyph.components.length; j += 1) {\n      const component = glyph.components[j];\n      const componentGlyph = glyphs.get(component.glyphIndex);\n      // Force the ttfGlyphLoader to parse the glyph.\n      componentGlyph.getPath();\n      if (componentGlyph.points) {\n        let transformedPoints;\n        if (component.matchedPoints === undefined) {\n          // component positioned by offset\n          transformedPoints = transformPoints(componentGlyph.points, component);\n        } else {\n          // component positioned by matched points\n          if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {\n            throw Error('Matched points out of range in ' + glyph.name);\n          }\n          const firstPt = glyph.points[component.matchedPoints[0]];\n          let secondPt = componentGlyph.points[component.matchedPoints[1]];\n          const transform = {\n            xScale: component.xScale,\n            scale01: component.scale01,\n            scale10: component.scale10,\n            yScale: component.yScale,\n            dx: 0,\n            dy: 0\n          };\n          secondPt = transformPoints([secondPt], transform)[0];\n          transform.dx = firstPt.x - secondPt.x;\n          transform.dy = firstPt.y - secondPt.y;\n          transformedPoints = transformPoints(componentGlyph.points, transform);\n        }\n        glyph.points = glyph.points.concat(transformedPoints);\n      }\n    }\n  }\n  return getPath(glyph.points);\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font) {\n  const glyphs = new glyphset.GlyphSet(font);\n\n  // The last element of the loca table is invalid.\n  for (let i = 0; i < loca.length - 1; i += 1) {\n    const offset = loca[i];\n    const nextOffset = loca[i + 1];\n    if (offset !== nextOffset) {\n      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n    } else {\n      glyphs.push(i, glyphset.glyphLoader(font, i));\n    }\n  }\n  return glyphs;\n}\nexport default {\n  getPath,\n  parse: parseGlyfTable\n};","map":{"version":3,"names":["check","glyphset","parse","Path","parseGlyphCoordinate","p","flag","previousValue","shortVectorBitMask","sameBitMask","v","parseByte","parseShort","parseGlyph","glyph","data","start","Parser","numberOfContours","_xMin","_yMin","_xMax","_yMax","flags","endPointIndices","i","push","parseUShort","instructionLength","instructions","numberOfCoordinates","length","repeatCount","j","argument","points","point","onCurve","lastPointOfContour","indexOf","px","x","py","y","isComposite","components","moreComponents","component","glyphIndex","xScale","scale01","scale10","yScale","dx","dy","matchedPoints","parseChar","parseF2Dot14","transformPoints","transform","newPoints","pt","newPt","getContours","contours","currentContour","getPath","contourIndex","contour","prev","curr","next","moveTo","lineTo","prev2","next2","quadraticCurveTo","closePath","buildPath","glyphs","componentGlyph","get","transformedPoints","undefined","Error","name","firstPt","secondPt","concat","parseGlyfTable","loca","font","GlyphSet","offset","nextOffset","ttfGlyphLoader","glyphLoader"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/_opentype.js@0.7.3@opentype.js/src/tables/glyf.js"],"sourcesContent":["// The `glyf` table describes the glyphs in TrueType outline format.\n// http://www.microsoft.com/typography/otspec/glyf.htm\n\nimport check from '../check';\nimport glyphset from '../glyphset';\nimport parse from '../parse';\nimport Path from '../path';\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    let v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    const p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    let flags;\n    let flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        const endPointIndices = glyph.endPointIndices = [];\n        for (let i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (let i = 0; i < glyph.instructionLength; i += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        const numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (let i = 0; i < numberOfCoordinates; i += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                const repeatCount = p.parseByte();\n                for (let j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            const points = [];\n            let point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (let i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;\n                    points.push(point);\n                }\n\n                let px = 0;\n                for (let i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = points[i];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                let py = 0;\n                for (let i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = points[i];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        let moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            const component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (let i = 0; i < glyph.instructionLength; i += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    const newPoints = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const pt = points[i];\n        const newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    const contours = [];\n    let currentContour = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    const p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    const contours = getContours(points);\n\n    for (let contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        const contour = contours[contourIndex];\n\n        let prev = null;\n        let curr = contour[contour.length - 1];\n        let next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                const start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (let i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                let prev2 = prev;\n                let next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                    p.lineTo(prev2.x, prev2.y);\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.lineTo(prev2.x, prev2.y);\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (let j = 0; j < glyph.components.length; j += 1) {\n            const component = glyph.components[j];\n            const componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                let transformedPoints;\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    const firstPt = glyph.points[component.matchedPoints[0]];\n                    let secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    const transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font) {\n    const glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (let i = 0; i < loca.length - 1; i += 1) {\n        const offset = loca[i];\n        const nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nexport default { getPath, parse: parseGlyfTable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}