{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\n// The `CFF` table contains the glyph outlines in PostScript format.\n// https://www.microsoft.com/typography/OTSPEC/cff.htm\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf\n\nimport { CffEncoding, cffStandardEncoding, cffExpertEncoding, cffStandardStrings } from '../encoding';\nimport glyphset from '../glyphset';\nimport parse from '../parse';\nimport Path from '../path';\nimport table from '../table';\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n  if (a === b) {\n    return true;\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i += 1) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n  let bias;\n  if (subrs.length < 1240) {\n    bias = 107;\n  } else if (subrs.length < 33900) {\n    bias = 1131;\n  } else {\n    bias = 32768;\n  }\n  return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n  const offsets = [];\n  const objects = [];\n  const count = parse.getCard16(data, start);\n  let objectOffset;\n  let endOffset;\n  if (count !== 0) {\n    const offsetSize = parse.getByte(data, start + 2);\n    objectOffset = start + (count + 1) * offsetSize + 2;\n    let pos = start + 3;\n    for (let i = 0; i < count + 1; i += 1) {\n      offsets.push(parse.getOffset(data, pos, offsetSize));\n      pos += offsetSize;\n    }\n\n    // The total size of the index array is 4 header bytes + the value of the last offset.\n    endOffset = objectOffset + offsets[count];\n  } else {\n    endOffset = start + 2;\n  }\n  for (let i = 0; i < offsets.length - 1; i += 1) {\n    let value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n    if (conversionFn) {\n      value = conversionFn(value);\n    }\n    objects.push(value);\n  }\n  return {\n    objects: objects,\n    startOffset: start,\n    endOffset: endOffset\n  };\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n  let s = '';\n  const eof = 15;\n  const lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n  while (true) {\n    const b = parser.parseByte();\n    const n1 = b >> 4;\n    const n2 = b & 15;\n    if (n1 === eof) {\n      break;\n    }\n    s += lookup[n1];\n    if (n2 === eof) {\n      break;\n    }\n    s += lookup[n2];\n  }\n  return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n  let b1;\n  let b2;\n  let b3;\n  let b4;\n  if (b0 === 28) {\n    b1 = parser.parseByte();\n    b2 = parser.parseByte();\n    return b1 << 8 | b2;\n  }\n  if (b0 === 29) {\n    b1 = parser.parseByte();\n    b2 = parser.parseByte();\n    b3 = parser.parseByte();\n    b4 = parser.parseByte();\n    return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n  }\n  if (b0 === 30) {\n    return parseFloatOperand(parser);\n  }\n  if (b0 >= 32 && b0 <= 246) {\n    return b0 - 139;\n  }\n  if (b0 >= 247 && b0 <= 250) {\n    b1 = parser.parseByte();\n    return (b0 - 247) * 256 + b1 + 108;\n  }\n  if (b0 >= 251 && b0 <= 254) {\n    b1 = parser.parseByte();\n    return -(b0 - 251) * 256 - b1 - 108;\n  }\n  throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n  const o = {};\n  for (let i = 0; i < entries.length; i += 1) {\n    const key = entries[i][0];\n    const values = entries[i][1];\n    let value;\n    if (values.length === 1) {\n      value = values[0];\n    } else {\n      value = values;\n    }\n    if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n      throw new Error('Object ' + o + ' already has key ' + key);\n    }\n    o[key] = value;\n  }\n  return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n  start = start !== undefined ? start : 0;\n  const parser = new parse.Parser(data, start);\n  const entries = [];\n  let operands = [];\n  size = size !== undefined ? size : data.length;\n  while (parser.relativeOffset < size) {\n    let op = parser.parseByte();\n\n    // The first byte for each dict item distinguishes between operator (key) and operand (value).\n    // Values <= 21 are operators.\n    if (op <= 21) {\n      // Two-byte operators have an initial escape byte of 12.\n      if (op === 12) {\n        op = 1200 + parser.parseByte();\n      }\n      entries.push([op, operands]);\n      operands = [];\n    } else {\n      // Since the operands (values) come before the operators (keys), we store all operands in a list\n      // until we encounter an operator.\n      operands.push(parseOperand(parser, op));\n    }\n  }\n  return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n  if (index <= 390) {\n    index = cffStandardStrings[index];\n  } else {\n    index = strings[index - 391];\n  }\n  return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n  const newDict = {};\n  let value;\n\n  // Because we also want to include missing values, we start out from the meta list\n  // and lookup values in the dict.\n  for (let i = 0; i < meta.length; i += 1) {\n    const m = meta[i];\n    if (Array.isArray(m.type)) {\n      const values = [];\n      values.length = m.type.length;\n      for (let j = 0; j < m.type.length; j++) {\n        value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n        if (value === undefined) {\n          value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n        }\n        if (m.type[j] === 'SID') {\n          value = getCFFString(strings, value);\n        }\n        values[j] = value;\n      }\n      newDict[m.name] = values;\n    } else {\n      value = dict[m.op];\n      if (value === undefined) {\n        value = m.value !== undefined ? m.value : null;\n      }\n      if (m.type === 'SID') {\n        value = getCFFString(strings, value);\n      }\n      newDict[m.name] = value;\n    }\n  }\n  return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n  const header = {};\n  header.formatMajor = parse.getCard8(data, start);\n  header.formatMinor = parse.getCard8(data, start + 1);\n  header.size = parse.getCard8(data, start + 2);\n  header.offsetSize = parse.getCard8(data, start + 3);\n  header.startOffset = start;\n  header.endOffset = start + 4;\n  return header;\n}\nconst TOP_DICT_META = [{\n  name: 'version',\n  op: 0,\n  type: 'SID'\n}, {\n  name: 'notice',\n  op: 1,\n  type: 'SID'\n}, {\n  name: 'copyright',\n  op: 1200,\n  type: 'SID'\n}, {\n  name: 'fullName',\n  op: 2,\n  type: 'SID'\n}, {\n  name: 'familyName',\n  op: 3,\n  type: 'SID'\n}, {\n  name: 'weight',\n  op: 4,\n  type: 'SID'\n}, {\n  name: 'isFixedPitch',\n  op: 1201,\n  type: 'number',\n  value: 0\n}, {\n  name: 'italicAngle',\n  op: 1202,\n  type: 'number',\n  value: 0\n}, {\n  name: 'underlinePosition',\n  op: 1203,\n  type: 'number',\n  value: -100\n}, {\n  name: 'underlineThickness',\n  op: 1204,\n  type: 'number',\n  value: 50\n}, {\n  name: 'paintType',\n  op: 1205,\n  type: 'number',\n  value: 0\n}, {\n  name: 'charstringType',\n  op: 1206,\n  type: 'number',\n  value: 2\n}, {\n  name: 'fontMatrix',\n  op: 1207,\n  type: ['real', 'real', 'real', 'real', 'real', 'real'],\n  value: [0.001, 0, 0, 0.001, 0, 0]\n}, {\n  name: 'uniqueId',\n  op: 13,\n  type: 'number'\n}, {\n  name: 'fontBBox',\n  op: 5,\n  type: ['number', 'number', 'number', 'number'],\n  value: [0, 0, 0, 0]\n}, {\n  name: 'strokeWidth',\n  op: 1208,\n  type: 'number',\n  value: 0\n}, {\n  name: 'xuid',\n  op: 14,\n  type: [],\n  value: null\n}, {\n  name: 'charset',\n  op: 15,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'encoding',\n  op: 16,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'charStrings',\n  op: 17,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'private',\n  op: 18,\n  type: ['number', 'offset'],\n  value: [0, 0]\n}, {\n  name: 'ros',\n  op: 1230,\n  type: ['SID', 'SID', 'number']\n}, {\n  name: 'cidFontVersion',\n  op: 1231,\n  type: 'number',\n  value: 0\n}, {\n  name: 'cidFontRevision',\n  op: 1232,\n  type: 'number',\n  value: 0\n}, {\n  name: 'cidFontType',\n  op: 1233,\n  type: 'number',\n  value: 0\n}, {\n  name: 'cidCount',\n  op: 1234,\n  type: 'number',\n  value: 8720\n}, {\n  name: 'uidBase',\n  op: 1235,\n  type: 'number'\n}, {\n  name: 'fdArray',\n  op: 1236,\n  type: 'offset'\n}, {\n  name: 'fdSelect',\n  op: 1237,\n  type: 'offset'\n}, {\n  name: 'fontName',\n  op: 1238,\n  type: 'SID'\n}];\nconst PRIVATE_DICT_META = [{\n  name: 'subrs',\n  op: 19,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'defaultWidthX',\n  op: 20,\n  type: 'number',\n  value: 0\n}, {\n  name: 'nominalWidthX',\n  op: 21,\n  type: 'number',\n  value: 0\n}];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n  const dict = parseCFFDict(data, 0, data.byteLength);\n  return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n  const dict = parseCFFDict(data, start, size);\n  return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n  const topDictArray = [];\n  for (let iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n    const topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n    const topDict = parseCFFTopDict(topDictData, strings);\n    topDict._subrs = [];\n    topDict._subrsBias = 0;\n    const privateSize = topDict.private[0];\n    const privateOffset = topDict.private[1];\n    if (privateSize !== 0 && privateOffset !== 0) {\n      const privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n      topDict._defaultWidthX = privateDict.defaultWidthX;\n      topDict._nominalWidthX = privateDict.nominalWidthX;\n      if (privateDict.subrs !== 0) {\n        const subrOffset = privateOffset + privateDict.subrs;\n        const subrIndex = parseCFFIndex(data, subrOffset + start);\n        topDict._subrs = subrIndex.objects;\n        topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n      }\n      topDict._privateDict = privateDict;\n    }\n    topDictArray.push(topDict);\n  }\n  return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n  let sid;\n  let count;\n  const parser = new parse.Parser(data, start);\n\n  // The .notdef glyph is not included, so subtract 1.\n  nGlyphs -= 1;\n  const charset = ['.notdef'];\n  const format = parser.parseCard8();\n  if (format === 0) {\n    for (let i = 0; i < nGlyphs; i += 1) {\n      sid = parser.parseSID();\n      charset.push(getCFFString(strings, sid));\n    }\n  } else if (format === 1) {\n    while (charset.length <= nGlyphs) {\n      sid = parser.parseSID();\n      count = parser.parseCard8();\n      for (let i = 0; i <= count; i += 1) {\n        charset.push(getCFFString(strings, sid));\n        sid += 1;\n      }\n    }\n  } else if (format === 2) {\n    while (charset.length <= nGlyphs) {\n      sid = parser.parseSID();\n      count = parser.parseCard16();\n      for (let i = 0; i <= count; i += 1) {\n        charset.push(getCFFString(strings, sid));\n        sid += 1;\n      }\n    }\n  } else {\n    throw new Error('Unknown charset format ' + format);\n  }\n  return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n  let code;\n  const enc = {};\n  const parser = new parse.Parser(data, start);\n  const format = parser.parseCard8();\n  if (format === 0) {\n    const nCodes = parser.parseCard8();\n    for (let i = 0; i < nCodes; i += 1) {\n      code = parser.parseCard8();\n      enc[code] = i;\n    }\n  } else if (format === 1) {\n    const nRanges = parser.parseCard8();\n    code = 1;\n    for (let i = 0; i < nRanges; i += 1) {\n      const first = parser.parseCard8();\n      const nLeft = parser.parseCard8();\n      for (let j = first; j <= first + nLeft; j += 1) {\n        enc[j] = code;\n        code += 1;\n      }\n    }\n  } else {\n    throw new Error('Unknown encoding format ' + format);\n  }\n  return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n  let c1x;\n  let c1y;\n  let c2x;\n  let c2y;\n  const p = new Path();\n  const stack = [];\n  let nStems = 0;\n  let haveWidth = false;\n  let open = false;\n  let x = 0;\n  let y = 0;\n  let subrs;\n  let subrsBias;\n  let defaultWidthX;\n  let nominalWidthX;\n  if (font.isCIDFont) {\n    const fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n    const fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n    subrs = fdDict._subrs;\n    subrsBias = fdDict._subrsBias;\n    defaultWidthX = fdDict._defaultWidthX;\n    nominalWidthX = fdDict._nominalWidthX;\n  } else {\n    subrs = font.tables.cff.topDict._subrs;\n    subrsBias = font.tables.cff.topDict._subrsBias;\n    defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n    nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n  }\n  let width = defaultWidthX;\n  function newContour(x, y) {\n    if (open) {\n      p.closePath();\n    }\n    p.moveTo(x, y);\n    open = true;\n  }\n  function parseStems() {\n    let hasWidthArg;\n\n    // The number of stem operators on the stack is always even.\n    // If the value is uneven, that means a width is specified.\n    hasWidthArg = stack.length % 2 !== 0;\n    if (hasWidthArg && !haveWidth) {\n      width = stack.shift() + nominalWidthX;\n    }\n    nStems += stack.length >> 1;\n    stack.length = 0;\n    haveWidth = true;\n  }\n  function parse(code) {\n    let b1;\n    let b2;\n    let b3;\n    let b4;\n    let codeIndex;\n    let subrCode;\n    let jpx;\n    let jpy;\n    let c3x;\n    let c3y;\n    let c4x;\n    let c4y;\n    let i = 0;\n    while (i < code.length) {\n      let v = code[i];\n      i += 1;\n      switch (v) {\n        case 1:\n          // hstem\n          parseStems();\n          break;\n        case 3:\n          // vstem\n          parseStems();\n          break;\n        case 4:\n          // vmoveto\n          if (stack.length > 1 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n          y += stack.pop();\n          newContour(x, y);\n          break;\n        case 5:\n          // rlineto\n          while (stack.length > 0) {\n            x += stack.shift();\n            y += stack.shift();\n            p.lineTo(x, y);\n          }\n          break;\n        case 6:\n          // hlineto\n          while (stack.length > 0) {\n            x += stack.shift();\n            p.lineTo(x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            y += stack.shift();\n            p.lineTo(x, y);\n          }\n          break;\n        case 7:\n          // vlineto\n          while (stack.length > 0) {\n            y += stack.shift();\n            p.lineTo(x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            x += stack.shift();\n            p.lineTo(x, y);\n          }\n          break;\n        case 8:\n          // rrcurveto\n          while (stack.length > 0) {\n            c1x = x + stack.shift();\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + stack.shift();\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n          break;\n        case 10:\n          // callsubr\n          codeIndex = stack.pop() + subrsBias;\n          subrCode = subrs[codeIndex];\n          if (subrCode) {\n            parse(subrCode);\n          }\n          break;\n        case 11:\n          // return\n          return;\n        case 12:\n          // flex operators\n          v = code[i];\n          i += 1;\n          switch (v) {\n            case 35:\n              // flex\n              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n              c1x = x + stack.shift(); // dx1\n              c1y = y + stack.shift(); // dy1\n              c2x = c1x + stack.shift(); // dx2\n              c2y = c1y + stack.shift(); // dy2\n              jpx = c2x + stack.shift(); // dx3\n              jpy = c2y + stack.shift(); // dy3\n              c3x = jpx + stack.shift(); // dx4\n              c3y = jpy + stack.shift(); // dy4\n              c4x = c3x + stack.shift(); // dx5\n              c4y = c3y + stack.shift(); // dy5\n              x = c4x + stack.shift(); // dx6\n              y = c4y + stack.shift(); // dy6\n              stack.shift(); // flex depth\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n            case 34:\n              // hflex\n              // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n              c1x = x + stack.shift(); // dx1\n              c1y = y; // dy1\n              c2x = c1x + stack.shift(); // dx2\n              c2y = c1y + stack.shift(); // dy2\n              jpx = c2x + stack.shift(); // dx3\n              jpy = c2y; // dy3\n              c3x = jpx + stack.shift(); // dx4\n              c3y = c2y; // dy4\n              c4x = c3x + stack.shift(); // dx5\n              c4y = y; // dy5\n              x = c4x + stack.shift(); // dx6\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n            case 36:\n              // hflex1\n              // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n              c1x = x + stack.shift(); // dx1\n              c1y = y + stack.shift(); // dy1\n              c2x = c1x + stack.shift(); // dx2\n              c2y = c1y + stack.shift(); // dy2\n              jpx = c2x + stack.shift(); // dx3\n              jpy = c2y; // dy3\n              c3x = jpx + stack.shift(); // dx4\n              c3y = c2y; // dy4\n              c4x = c3x + stack.shift(); // dx5\n              c4y = c3y + stack.shift(); // dy5\n              x = c4x + stack.shift(); // dx6\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n            case 37:\n              // flex1\n              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n              c1x = x + stack.shift(); // dx1\n              c1y = y + stack.shift(); // dy1\n              c2x = c1x + stack.shift(); // dx2\n              c2y = c1y + stack.shift(); // dy2\n              jpx = c2x + stack.shift(); // dx3\n              jpy = c2y + stack.shift(); // dy3\n              c3x = jpx + stack.shift(); // dx4\n              c3y = jpy + stack.shift(); // dy4\n              c4x = c3x + stack.shift(); // dx5\n              c4y = c3y + stack.shift(); // dy5\n              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                x = c4x + stack.shift();\n              } else {\n                y = c4y + stack.shift();\n              }\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n            default:\n              console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n              stack.length = 0;\n          }\n          break;\n        case 14:\n          // endchar\n          if (stack.length > 0 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n          if (open) {\n            p.closePath();\n            open = false;\n          }\n          break;\n        case 18:\n          // hstemhm\n          parseStems();\n          break;\n        case 19: // hintmask\n        case 20:\n          // cntrmask\n          parseStems();\n          i += nStems + 7 >> 3;\n          break;\n        case 21:\n          // rmoveto\n          if (stack.length > 2 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n          y += stack.pop();\n          x += stack.pop();\n          newContour(x, y);\n          break;\n        case 22:\n          // hmoveto\n          if (stack.length > 1 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n          x += stack.pop();\n          newContour(x, y);\n          break;\n        case 23:\n          // vstemhm\n          parseStems();\n          break;\n        case 24:\n          // rcurveline\n          while (stack.length > 2) {\n            c1x = x + stack.shift();\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + stack.shift();\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n          x += stack.shift();\n          y += stack.shift();\n          p.lineTo(x, y);\n          break;\n        case 25:\n          // rlinecurve\n          while (stack.length > 6) {\n            x += stack.shift();\n            y += stack.shift();\n            p.lineTo(x, y);\n          }\n          c1x = x + stack.shift();\n          c1y = y + stack.shift();\n          c2x = c1x + stack.shift();\n          c2y = c1y + stack.shift();\n          x = c2x + stack.shift();\n          y = c2y + stack.shift();\n          p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          break;\n        case 26:\n          // vvcurveto\n          if (stack.length % 2) {\n            x += stack.shift();\n          }\n          while (stack.length > 0) {\n            c1x = x;\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x;\n            y = c2y + stack.shift();\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n          break;\n        case 27:\n          // hhcurveto\n          if (stack.length % 2) {\n            y += stack.shift();\n          }\n          while (stack.length > 0) {\n            c1x = x + stack.shift();\n            c1y = y;\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y;\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n          break;\n        case 28:\n          // shortint\n          b1 = code[i];\n          b2 = code[i + 1];\n          stack.push((b1 << 24 | b2 << 16) >> 16);\n          i += 2;\n          break;\n        case 29:\n          // callgsubr\n          codeIndex = stack.pop() + font.gsubrsBias;\n          subrCode = font.gsubrs[codeIndex];\n          if (subrCode) {\n            parse(subrCode);\n          }\n          break;\n        case 30:\n          // vhcurveto\n          while (stack.length > 0) {\n            c1x = x;\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            c1x = x + stack.shift();\n            c1y = y;\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            y = c2y + stack.shift();\n            x = c2x + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n          break;\n        case 31:\n          // hvcurveto\n          while (stack.length > 0) {\n            c1x = x + stack.shift();\n            c1y = y;\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            y = c2y + stack.shift();\n            x = c2x + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n            if (stack.length === 0) {\n              break;\n            }\n            c1x = x;\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n          break;\n        default:\n          if (v < 32) {\n            console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n          } else if (v < 247) {\n            stack.push(v - 139);\n          } else if (v < 251) {\n            b1 = code[i];\n            i += 1;\n            stack.push((v - 247) * 256 + b1 + 108);\n          } else if (v < 255) {\n            b1 = code[i];\n            i += 1;\n            stack.push(-(v - 251) * 256 - b1 - 108);\n          } else {\n            b1 = code[i];\n            b2 = code[i + 1];\n            b3 = code[i + 2];\n            b4 = code[i + 3];\n            i += 4;\n            stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);\n          }\n      }\n    }\n  }\n  parse(code);\n  glyph.advanceWidth = width;\n  return p;\n}\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n  const fdSelect = [];\n  let fdIndex;\n  const parser = new parse.Parser(data, start);\n  const format = parser.parseCard8();\n  if (format === 0) {\n    // Simple list of nGlyphs elements\n    for (let iGid = 0; iGid < nGlyphs; iGid++) {\n      fdIndex = parser.parseCard8();\n      if (fdIndex >= fdArrayCount) {\n        throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n      }\n      fdSelect.push(fdIndex);\n    }\n  } else if (format === 3) {\n    // Ranges\n    const nRanges = parser.parseCard16();\n    let first = parser.parseCard16();\n    if (first !== 0) {\n      throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n    }\n    let next;\n    for (let iRange = 0; iRange < nRanges; iRange++) {\n      fdIndex = parser.parseCard8();\n      next = parser.parseCard16();\n      if (fdIndex >= fdArrayCount) {\n        throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n      }\n      if (next > nGlyphs) {\n        throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n      }\n      for (; first < next; first++) {\n        fdSelect.push(fdIndex);\n      }\n      first = next;\n    }\n    if (next !== nGlyphs) {\n      throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n    }\n  } else {\n    throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n  }\n  return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font) {\n  font.tables.cff = {};\n  const header = parseCFFHeader(data, start);\n  const nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n  const topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n  const stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n  const globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n  font.gsubrs = globalSubrIndex.objects;\n  font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n  const topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n  if (topDictArray.length !== 1) {\n    throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n  }\n  const topDict = topDictArray[0];\n  font.tables.cff.topDict = topDict;\n  if (topDict._privateDict) {\n    font.defaultWidthX = topDict._privateDict.defaultWidthX;\n    font.nominalWidthX = topDict._privateDict.nominalWidthX;\n  }\n  if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n    font.isCIDFont = true;\n  }\n  if (font.isCIDFont) {\n    let fdArrayOffset = topDict.fdArray;\n    let fdSelectOffset = topDict.fdSelect;\n    if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n      throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n    }\n    fdArrayOffset += start;\n    const fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n    const fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n    topDict._fdArray = fdArray;\n    fdSelectOffset += start;\n    topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n  }\n  const privateDictOffset = start + topDict.private[1];\n  const privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n  font.defaultWidthX = privateDict.defaultWidthX;\n  font.nominalWidthX = privateDict.nominalWidthX;\n  if (privateDict.subrs !== 0) {\n    const subrOffset = privateDictOffset + privateDict.subrs;\n    const subrIndex = parseCFFIndex(data, subrOffset);\n    font.subrs = subrIndex.objects;\n    font.subrsBias = calcCFFSubroutineBias(font.subrs);\n  } else {\n    font.subrs = [];\n    font.subrsBias = 0;\n  }\n\n  // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n  const charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n  font.nGlyphs = charStringsIndex.objects.length;\n  const charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n  if (topDict.encoding === 0) {\n    // Standard encoding\n    font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n  } else if (topDict.encoding === 1) {\n    // Expert encoding\n    font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n  } else {\n    font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n  }\n\n  // Prefer the CMAP encoding to the CFF encoding.\n  font.encoding = font.encoding || font.cffEncoding;\n  font.glyphs = new glyphset.GlyphSet(font);\n  for (let i = 0; i < font.nGlyphs; i += 1) {\n    const charString = charStringsIndex.objects[i];\n    font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n  }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n  let sid;\n\n  // Is the string in the CFF standard strings?\n  let i = cffStandardStrings.indexOf(s);\n  if (i >= 0) {\n    sid = i;\n  }\n\n  // Is the string already in the string index?\n  i = strings.indexOf(s);\n  if (i >= 0) {\n    sid = i + cffStandardStrings.length;\n  } else {\n    sid = cffStandardStrings.length + strings.length;\n    strings.push(s);\n  }\n  return sid;\n}\nfunction makeHeader() {\n  return new table.Record('Header', [{\n    name: 'major',\n    type: 'Card8',\n    value: 1\n  }, {\n    name: 'minor',\n    type: 'Card8',\n    value: 0\n  }, {\n    name: 'hdrSize',\n    type: 'Card8',\n    value: 4\n  }, {\n    name: 'major',\n    type: 'Card8',\n    value: 1\n  }]);\n}\nfunction makeNameIndex(fontNames) {\n  const t = new table.Record('Name INDEX', [{\n    name: 'names',\n    type: 'INDEX',\n    value: []\n  }]);\n  t.names = [];\n  for (let i = 0; i < fontNames.length; i += 1) {\n    t.names.push({\n      name: 'name_' + i,\n      type: 'NAME',\n      value: fontNames[i]\n    });\n  }\n  return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n  const m = {};\n  for (let i = 0; i < meta.length; i += 1) {\n    const entry = meta[i];\n    let value = attrs[entry.name];\n    if (value !== undefined && !equals(value, entry.value)) {\n      if (entry.type === 'SID') {\n        value = encodeString(value, strings);\n      }\n      m[entry.op] = {\n        name: entry.name,\n        type: entry.type,\n        value: value\n      };\n    }\n  }\n  return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n  const t = new table.Record('Top DICT', [{\n    name: 'dict',\n    type: 'DICT',\n    value: {}\n  }]);\n  t.dict = makeDict(TOP_DICT_META, attrs, strings);\n  return t;\n}\nfunction makeTopDictIndex(topDict) {\n  const t = new table.Record('Top DICT INDEX', [{\n    name: 'topDicts',\n    type: 'INDEX',\n    value: []\n  }]);\n  t.topDicts = [{\n    name: 'topDict_0',\n    type: 'TABLE',\n    value: topDict\n  }];\n  return t;\n}\nfunction makeStringIndex(strings) {\n  const t = new table.Record('String INDEX', [{\n    name: 'strings',\n    type: 'INDEX',\n    value: []\n  }]);\n  t.strings = [];\n  for (let i = 0; i < strings.length; i += 1) {\n    t.strings.push({\n      name: 'string_' + i,\n      type: 'STRING',\n      value: strings[i]\n    });\n  }\n  return t;\n}\nfunction makeGlobalSubrIndex() {\n  // Currently we don't use subroutines.\n  return new table.Record('Global Subr INDEX', [{\n    name: 'subrs',\n    type: 'INDEX',\n    value: []\n  }]);\n}\nfunction makeCharsets(glyphNames, strings) {\n  const t = new table.Record('Charsets', [{\n    name: 'format',\n    type: 'Card8',\n    value: 0\n  }]);\n  for (let i = 0; i < glyphNames.length; i += 1) {\n    const glyphName = glyphNames[i];\n    const glyphSID = encodeString(glyphName, strings);\n    t.fields.push({\n      name: 'glyph_' + i,\n      type: 'SID',\n      value: glyphSID\n    });\n  }\n  return t;\n}\nfunction glyphToOps(glyph) {\n  const ops = [];\n  const path = glyph.path;\n  ops.push({\n    name: 'width',\n    type: 'NUMBER',\n    value: glyph.advanceWidth\n  });\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < path.commands.length; i += 1) {\n    let dx;\n    let dy;\n    let cmd = path.commands[i];\n    if (cmd.type === 'Q') {\n      // CFF only supports bézier curves, so convert the quad to a bézier.\n      const _13 = 1 / 3;\n      const _23 = 2 / 3;\n\n      // We're going to create a new command so we don't change the original path.\n      cmd = {\n        type: 'C',\n        x: cmd.x,\n        y: cmd.y,\n        x1: _13 * x + _23 * cmd.x1,\n        y1: _13 * y + _23 * cmd.y1,\n        x2: _13 * cmd.x + _23 * cmd.x1,\n        y2: _13 * cmd.y + _23 * cmd.y1\n      };\n    }\n    if (cmd.type === 'M') {\n      dx = Math.round(cmd.x - x);\n      dy = Math.round(cmd.y - y);\n      ops.push({\n        name: 'dx',\n        type: 'NUMBER',\n        value: dx\n      });\n      ops.push({\n        name: 'dy',\n        type: 'NUMBER',\n        value: dy\n      });\n      ops.push({\n        name: 'rmoveto',\n        type: 'OP',\n        value: 21\n      });\n      x = Math.round(cmd.x);\n      y = Math.round(cmd.y);\n    } else if (cmd.type === 'L') {\n      dx = Math.round(cmd.x - x);\n      dy = Math.round(cmd.y - y);\n      ops.push({\n        name: 'dx',\n        type: 'NUMBER',\n        value: dx\n      });\n      ops.push({\n        name: 'dy',\n        type: 'NUMBER',\n        value: dy\n      });\n      ops.push({\n        name: 'rlineto',\n        type: 'OP',\n        value: 5\n      });\n      x = Math.round(cmd.x);\n      y = Math.round(cmd.y);\n    } else if (cmd.type === 'C') {\n      const dx1 = Math.round(cmd.x1 - x);\n      const dy1 = Math.round(cmd.y1 - y);\n      const dx2 = Math.round(cmd.x2 - cmd.x1);\n      const dy2 = Math.round(cmd.y2 - cmd.y1);\n      dx = Math.round(cmd.x - cmd.x2);\n      dy = Math.round(cmd.y - cmd.y2);\n      ops.push({\n        name: 'dx1',\n        type: 'NUMBER',\n        value: dx1\n      });\n      ops.push({\n        name: 'dy1',\n        type: 'NUMBER',\n        value: dy1\n      });\n      ops.push({\n        name: 'dx2',\n        type: 'NUMBER',\n        value: dx2\n      });\n      ops.push({\n        name: 'dy2',\n        type: 'NUMBER',\n        value: dy2\n      });\n      ops.push({\n        name: 'dx',\n        type: 'NUMBER',\n        value: dx\n      });\n      ops.push({\n        name: 'dy',\n        type: 'NUMBER',\n        value: dy\n      });\n      ops.push({\n        name: 'rrcurveto',\n        type: 'OP',\n        value: 8\n      });\n      x = Math.round(cmd.x);\n      y = Math.round(cmd.y);\n    }\n\n    // Contours are closed automatically.\n  }\n\n  ops.push({\n    name: 'endchar',\n    type: 'OP',\n    value: 14\n  });\n  return ops;\n}\nfunction makeCharStringsIndex(glyphs) {\n  const t = new table.Record('CharStrings INDEX', [{\n    name: 'charStrings',\n    type: 'INDEX',\n    value: []\n  }]);\n  for (let i = 0; i < glyphs.length; i += 1) {\n    const glyph = glyphs.get(i);\n    const ops = glyphToOps(glyph);\n    t.charStrings.push({\n      name: glyph.name,\n      type: 'CHARSTRING',\n      value: ops\n    });\n  }\n  return t;\n}\nfunction makePrivateDict(attrs, strings) {\n  const t = new table.Record('Private DICT', [{\n    name: 'dict',\n    type: 'DICT',\n    value: {}\n  }]);\n  t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n  return t;\n}\nfunction makeCFFTable(glyphs, options) {\n  const t = new table.Table('CFF ', [{\n    name: 'header',\n    type: 'RECORD'\n  }, {\n    name: 'nameIndex',\n    type: 'RECORD'\n  }, {\n    name: 'topDictIndex',\n    type: 'RECORD'\n  }, {\n    name: 'stringIndex',\n    type: 'RECORD'\n  }, {\n    name: 'globalSubrIndex',\n    type: 'RECORD'\n  }, {\n    name: 'charsets',\n    type: 'RECORD'\n  }, {\n    name: 'charStringsIndex',\n    type: 'RECORD'\n  }, {\n    name: 'privateDict',\n    type: 'RECORD'\n  }]);\n  const fontScale = 1 / options.unitsPerEm;\n  // We use non-zero values for the offsets so that the DICT encodes them.\n  // This is important because the size of the Top DICT plays a role in offset calculation,\n  // and the size shouldn't change after we've written correct offsets.\n  const attrs = {\n    version: options.version,\n    fullName: options.fullName,\n    familyName: options.familyName,\n    weight: options.weightName,\n    fontBBox: options.fontBBox || [0, 0, 0, 0],\n    fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n    charset: 999,\n    encoding: 0,\n    charStrings: 999,\n    private: [0, 999]\n  };\n  const privateAttrs = {};\n  const glyphNames = [];\n  let glyph;\n\n  // Skip first glyph (.notdef)\n  for (let i = 1; i < glyphs.length; i += 1) {\n    glyph = glyphs.get(i);\n    glyphNames.push(glyph.name);\n  }\n  const strings = [];\n  t.header = makeHeader();\n  t.nameIndex = makeNameIndex([options.postScriptName]);\n  let topDict = makeTopDict(attrs, strings);\n  t.topDictIndex = makeTopDictIndex(topDict);\n  t.globalSubrIndex = makeGlobalSubrIndex();\n  t.charsets = makeCharsets(glyphNames, strings);\n  t.charStringsIndex = makeCharStringsIndex(glyphs);\n  t.privateDict = makePrivateDict(privateAttrs, strings);\n\n  // Needs to come at the end, to encode all custom strings used in the font.\n  t.stringIndex = makeStringIndex(strings);\n  const startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();\n  attrs.charset = startOffset;\n\n  // We use the CFF standard encoding; proper encoding will be handled in cmap.\n  attrs.encoding = 0;\n  attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n  attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n  // Recreate the Top DICT INDEX with the correct offsets.\n  topDict = makeTopDict(attrs, strings);\n  t.topDictIndex = makeTopDictIndex(topDict);\n  return t;\n}\nexport default {\n  parse: parseCFFTable,\n  make: makeCFFTable\n};","map":{"version":3,"names":["CffEncoding","cffStandardEncoding","cffExpertEncoding","cffStandardStrings","glyphset","parse","Path","table","equals","a","b","Array","isArray","length","i","calcCFFSubroutineBias","subrs","bias","parseCFFIndex","data","start","conversionFn","offsets","objects","count","getCard16","objectOffset","endOffset","offsetSize","getByte","pos","push","getOffset","value","getBytes","startOffset","parseFloatOperand","parser","s","eof","lookup","parseByte","n1","n2","parseFloat","parseOperand","b0","b1","b2","b3","b4","Error","entriesToObject","entries","o","key","values","hasOwnProperty","isNaN","parseCFFDict","size","undefined","Parser","operands","relativeOffset","op","getCFFString","strings","index","interpretDict","dict","meta","newDict","m","type","j","name","parseCFFHeader","header","formatMajor","getCard8","formatMinor","TOP_DICT_META","PRIVATE_DICT_META","parseCFFTopDict","byteLength","parseCFFPrivateDict","gatherCFFTopDicts","cffIndex","topDictArray","iTopDict","topDictData","DataView","Uint8Array","buffer","topDict","_subrs","_subrsBias","privateSize","private","privateOffset","privateDict","_defaultWidthX","defaultWidthX","_nominalWidthX","nominalWidthX","subrOffset","subrIndex","_privateDict","parseCFFCharset","nGlyphs","sid","charset","format","parseCard8","parseSID","parseCard16","parseCFFEncoding","code","enc","nCodes","nRanges","first","nLeft","parseCFFCharstring","font","glyph","c1x","c1y","c2x","c2y","p","stack","nStems","haveWidth","open","x","y","subrsBias","isCIDFont","fdIndex","tables","cff","_fdSelect","fdDict","_fdArray","width","newContour","closePath","moveTo","parseStems","hasWidthArg","shift","codeIndex","subrCode","jpx","jpy","c3x","c3y","c4x","c4y","v","pop","lineTo","curveTo","Math","abs","console","log","gsubrsBias","gsubrs","advanceWidth","parseCFFFDSelect","fdArrayCount","fdSelect","iGid","next","iRange","parseCFFTable","nameIndex","bytesToString","topDictIndex","stringIndex","globalSubrIndex","ros","fdArrayOffset","fdArray","fdSelectOffset","fdArrayIndex","numGlyphs","privateDictOffset","charStringsIndex","charStrings","encoding","cffEncoding","glyphs","GlyphSet","charString","cffGlyphLoader","encodeString","indexOf","makeHeader","Record","makeNameIndex","fontNames","t","names","makeDict","attrs","entry","makeTopDict","makeTopDictIndex","topDicts","makeStringIndex","makeGlobalSubrIndex","makeCharsets","glyphNames","glyphName","glyphSID","fields","glyphToOps","ops","path","commands","dx","dy","cmd","_13","_23","x1","y1","x2","y2","round","dx1","dy1","dx2","dy2","makeCharStringsIndex","get","makePrivateDict","makeCFFTable","options","Table","fontScale","unitsPerEm","version","fullName","familyName","weight","weightName","fontBBox","fontMatrix","privateAttrs","postScriptName","charsets","sizeOf","make"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/_opentype.js@0.7.3@opentype.js/src/tables/cff.js"],"sourcesContent":["// The `CFF` table contains the glyph outlines in PostScript format.\n// https://www.microsoft.com/typography/OTSPEC/cff.htm\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf\n\nimport { CffEncoding, cffStandardEncoding, cffExpertEncoding, cffStandardStrings } from '../encoding';\nimport glyphset from '../glyphset';\nimport parse from '../parse';\nimport Path from '../path';\nimport table from '../table';\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (let i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    let bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    const offsets = [];\n    const objects = [];\n    const count = parse.getCard16(data, start);\n    let objectOffset;\n    let endOffset;\n    if (count !== 0) {\n        const offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        let pos = start + 3;\n        for (let i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (let i = 0; i < offsets.length - 1; i += 1) {\n        let value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    let s = '';\n    const eof = 15;\n    const lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        const b = parser.parseByte();\n        const n1 = b >> 4;\n        const n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    let b1;\n    let b2;\n    let b3;\n    let b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    const o = {};\n    for (let i = 0; i < entries.length; i += 1) {\n        const key = entries[i][0];\n        const values = entries[i][1];\n        let value;\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    const parser = new parse.Parser(data, start);\n    const entries = [];\n    let operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        let op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    const newDict = {};\n    let value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (let i = 0; i < meta.length; i += 1) {\n        const m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            const values = [];\n            values.length = m.type.length;\n            for (let j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    const header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nconst TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0]\n    },\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n    {name: 'uidBase', op: 1235, type: 'number'},\n    {name: 'fdArray', op: 1236, type: 'offset'},\n    {name: 'fdSelect', op: 1237, type: 'offset'},\n    {name: 'fontName', op: 1238, type: 'SID'}\n];\n\nconst PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    const dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    const dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    const topDictArray = [];\n    for (let iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        const topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        const topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        const privateSize = topDict.private[0];\n        const privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            const privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                const subrOffset = privateOffset + privateDict.subrs;\n                const subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    let sid;\n    let count;\n    const parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    const charset = ['.notdef'];\n\n    const format = parser.parseCard8();\n    if (format === 0) {\n        for (let i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (let i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (let i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    let code;\n    const enc = {};\n    const parser = new parse.Parser(data, start);\n    const format = parser.parseCard8();\n    if (format === 0) {\n        const nCodes = parser.parseCard8();\n        for (let i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        const nRanges = parser.parseCard8();\n        code = 1;\n        for (let i = 0; i < nRanges; i += 1) {\n            const first = parser.parseCard8();\n            const nLeft = parser.parseCard8();\n            for (let j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    let c1x;\n    let c1y;\n    let c2x;\n    let c2y;\n    const p = new Path();\n    const stack = [];\n    let nStems = 0;\n    let haveWidth = false;\n    let open = false;\n    let x = 0;\n    let y = 0;\n    let subrs;\n    let subrsBias;\n    let defaultWidthX;\n    let nominalWidthX;\n    if (font.isCIDFont) {\n        const fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        const fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    let width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        let hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        let b1;\n        let b2;\n        let b3;\n        let b4;\n        let codeIndex;\n        let subrCode;\n        let jpx;\n        let jpy;\n        let c3x;\n        let c3y;\n        let c4x;\n        let c4y;\n\n        let i = 0;\n        while (i < code.length) {\n            let v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x   + stack.shift();    // dx6\n                            y = c4y   + stack.shift();    // dy6\n                            stack.shift();                // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y;                      // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = y;                      // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    const fdSelect = [];\n    let fdIndex;\n    const parser = new parse.Parser(data, start);\n    const format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (let iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        const nRanges = parser.parseCard16();\n        let first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n        }\n        let next;\n        for (let iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            if (next > nGlyphs) {\n                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n        }\n    } else {\n        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font) {\n    font.tables.cff = {};\n    const header = parseCFFHeader(data, start);\n    const nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    const topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    const stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    const globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    const topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n    }\n\n    const topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        let fdArrayOffset = topDict.fdArray;\n        let fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n        }\n        fdArrayOffset += start;\n        const fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        const fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n\n    const privateDictOffset = start + topDict.private[1];\n    const privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        const subrOffset = privateDictOffset + privateDict.subrs;\n        const subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    const charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n    font.nGlyphs = charStringsIndex.objects.length;\n\n    const charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) { // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) { // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    for (let i = 0; i < font.nGlyphs; i += 1) {\n        const charString = charStringsIndex.objects[i];\n        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    let sid;\n\n    // Is the string in the CFF standard strings?\n    let i = cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + cffStandardStrings.length;\n    } else {\n        sid = cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new table.Record('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    const t = new table.Record('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (let i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    const m = {};\n    for (let i = 0; i < meta.length; i += 1) {\n        const entry = meta[i];\n        let value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    const t = new table.Record('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    const t = new table.Record('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    const t = new table.Record('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (let i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Record('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    const t = new table.Record('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (let i = 0; i < glyphNames.length; i += 1) {\n        const glyphName = glyphNames[i];\n        const glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    const ops = [];\n    const path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    let x = 0;\n    let y = 0;\n    for (let i = 0; i < path.commands.length; i += 1) {\n        let dx;\n        let dy;\n        let cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bézier curves, so convert the quad to a bézier.\n            const _13 = 1 / 3;\n            const _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: _13 * x + _23 * cmd.x1,\n                y1: _13 * y + _23 * cmd.y1,\n                x2: _13 * cmd.x + _23 * cmd.x1,\n                y2: _13 * cmd.y + _23 * cmd.y1\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            const dx1 = Math.round(cmd.x1 - x);\n            const dy1 = Math.round(cmd.y1 - y);\n            const dx2 = Math.round(cmd.x2 - cmd.x1);\n            const dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    const t = new table.Record('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (let i = 0; i < glyphs.length; i += 1) {\n        const glyph = glyphs.get(i);\n        const ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    const t = new table.Record('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    const t = new table.Table('CFF ', [\n        {name: 'header', type: 'RECORD'},\n        {name: 'nameIndex', type: 'RECORD'},\n        {name: 'topDictIndex', type: 'RECORD'},\n        {name: 'stringIndex', type: 'RECORD'},\n        {name: 'globalSubrIndex', type: 'RECORD'},\n        {name: 'charsets', type: 'RECORD'},\n        {name: 'charStringsIndex', type: 'RECORD'},\n        {name: 'privateDict', type: 'RECORD'}\n    ]);\n\n    const fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    const attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontBBox: options.fontBBox || [0, 0, 0, 0],\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    const privateAttrs = {};\n\n    const glyphNames = [];\n    let glyph;\n\n    // Skip first glyph (.notdef)\n    for (let i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    const strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    let topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    const startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\nexport default { parse: parseCFFTable, make: makeCFFTable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}