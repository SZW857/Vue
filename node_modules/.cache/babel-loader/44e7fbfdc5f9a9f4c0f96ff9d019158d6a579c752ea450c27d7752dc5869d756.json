{"ast":null,"code":"/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n'use strict';\n\nimport \"core-js/modules/es.array.push.js\";\nlet instructionTable;\nlet exec;\nlet execGlyph;\nlet execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n  // the font this hinting object is for\n  this.font = font;\n\n  // cached states\n  this._fpgmState = this._prepState = undefined;\n\n  // errorState\n  // 0 ... all okay\n  // 1 ... had an error in a glyf,\n  //       continue working but stop spamming\n  //       the console\n  // 2 ... error at prep, stop hinting at this ppem\n  // 3 ... error at fpeg, stop hinting for this font at all\n  this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n  return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n  //Rounding in TT is supposed to \"symmetrical around zero\"\n  return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n  return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n  return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n  return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n  return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nconst roundSuper = function (v) {\n  const period = this.srPeriod;\n  let phase = this.srPhase;\n  const threshold = this.srThreshold;\n  let sign = 1;\n  if (v < 0) {\n    v = -v;\n    sign = -1;\n  }\n  v += threshold - phase;\n  v = Math.trunc(v / period) * period;\n  v += phase;\n\n  // according to http://xgridfit.sourceforge.net/round.html\n  if (sign > 0 && v < 0) return phase;\n  if (sign < 0 && v > 0) return -phase;\n  return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nconst xUnitVector = {\n  x: 1,\n  y: 0,\n  axis: 'x',\n  // Gets the projected distance between two points.\n  // o1/o2 ... if true, respective original position is used.\n  distance: function (p1, p2, o1, o2) {\n    return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n  },\n  // Moves point p so the moved position has the same relative\n  // position to the moved positions of rp1 and rp2 than the\n  // original positions had.\n  //\n  // See APPENDIX on INTERPOLATE at the bottom of this file.\n  interpolate: function (p, rp1, rp2, pv) {\n    let do1;\n    let do2;\n    let doa1;\n    let doa2;\n    let dm1;\n    let dm2;\n    let dt;\n    if (!pv || pv === this) {\n      do1 = p.xo - rp1.xo;\n      do2 = p.xo - rp2.xo;\n      dm1 = rp1.x - rp1.xo;\n      dm2 = rp2.x - rp2.xo;\n      doa1 = Math.abs(do1);\n      doa2 = Math.abs(do2);\n      dt = doa1 + doa2;\n      if (dt === 0) {\n        p.x = p.xo + (dm1 + dm2) / 2;\n        return;\n      }\n      p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n      return;\n    }\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n    if (dt === 0) {\n      xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n      return;\n    }\n    xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n  },\n  // Slope of line normal to this\n  normalSlope: Number.NEGATIVE_INFINITY,\n  // Sets the point 'p' relative to point 'rp'\n  // by the distance 'd'.\n  //\n  // See APPENDIX on SETRELATIVE at the bottom of this file.\n  //\n  // p   ... point to set\n  // rp  ... reference point\n  // d   ... distance on projection vector\n  // pv  ... projection vector (undefined = this)\n  // org ... if true, uses the original position of rp as reference.\n  setRelative: function (p, rp, d, pv, org) {\n    if (!pv || pv === this) {\n      p.x = (org ? rp.xo : rp.x) + d;\n      return;\n    }\n    const rpx = org ? rp.xo : rp.x;\n    const rpy = org ? rp.yo : rp.y;\n    const rpdx = rpx + d * pv.x;\n    const rpdy = rpy + d * pv.y;\n    p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n  },\n  // Slope of vector line.\n  slope: 0,\n  // Touches the point p.\n  touch: function (p) {\n    p.xTouched = true;\n  },\n  // Tests if a point p is touched.\n  touched: function (p) {\n    return p.xTouched;\n  },\n  // Untouches the point p.\n  untouch: function (p) {\n    p.xTouched = false;\n  }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nconst yUnitVector = {\n  x: 0,\n  y: 1,\n  axis: 'y',\n  // Gets the projected distance between two points.\n  // o1/o2 ... if true, respective original position is used.\n  distance: function (p1, p2, o1, o2) {\n    return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n  },\n  // Moves point p so the moved position has the same relative\n  // position to the moved positions of rp1 and rp2 than the\n  // original positions had.\n  //\n  // See APPENDIX on INTERPOLATE at the bottom of this file.\n  interpolate: function (p, rp1, rp2, pv) {\n    let do1;\n    let do2;\n    let doa1;\n    let doa2;\n    let dm1;\n    let dm2;\n    let dt;\n    if (!pv || pv === this) {\n      do1 = p.yo - rp1.yo;\n      do2 = p.yo - rp2.yo;\n      dm1 = rp1.y - rp1.yo;\n      dm2 = rp2.y - rp2.yo;\n      doa1 = Math.abs(do1);\n      doa2 = Math.abs(do2);\n      dt = doa1 + doa2;\n      if (dt === 0) {\n        p.y = p.yo + (dm1 + dm2) / 2;\n        return;\n      }\n      p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n      return;\n    }\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n    if (dt === 0) {\n      yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n      return;\n    }\n    yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n  },\n  // Slope of line normal to this.\n  normalSlope: 0,\n  // Sets the point 'p' relative to point 'rp'\n  // by the distance 'd'\n  //\n  // See APPENDIX on SETRELATIVE at the bottom of this file.\n  //\n  // p   ... point to set\n  // rp  ... reference point\n  // d   ... distance on projection vector\n  // pv  ... projection vector (undefined = this)\n  // org ... if true, uses the original position of rp as reference.\n  setRelative: function (p, rp, d, pv, org) {\n    if (!pv || pv === this) {\n      p.y = (org ? rp.yo : rp.y) + d;\n      return;\n    }\n    const rpx = org ? rp.xo : rp.x;\n    const rpy = org ? rp.yo : rp.y;\n    const rpdx = rpx + d * pv.x;\n    const rpdy = rpy + d * pv.y;\n    p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n  },\n  // Slope of vector line.\n  slope: Number.POSITIVE_INFINITY,\n  // Touches the point p.\n  touch: function (p) {\n    p.yTouched = true;\n  },\n  // Tests if a point p is touched.\n  touched: function (p) {\n    return p.yTouched;\n  },\n  // Untouches the point p.\n  untouch: function (p) {\n    p.yTouched = false;\n  }\n};\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n  this.x = x;\n  this.y = y;\n  this.axis = undefined;\n  this.slope = y / x;\n  this.normalSlope = -x / y;\n  Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function (p1, p2, o1, o2) {\n  return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function (p, rp1, rp2, pv) {\n  let dm1;\n  let dm2;\n  let do1;\n  let do2;\n  let doa1;\n  let doa2;\n  let dt;\n  do1 = pv.distance(p, rp1, true, true);\n  do2 = pv.distance(p, rp2, true, true);\n  dm1 = pv.distance(rp1, rp1, false, true);\n  dm2 = pv.distance(rp2, rp2, false, true);\n  doa1 = Math.abs(do1);\n  doa2 = Math.abs(do2);\n  dt = doa1 + doa2;\n  if (dt === 0) {\n    this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n    return;\n  }\n  this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function (p, rp, d, pv, org) {\n  pv = pv || this;\n  const rpx = org ? rp.xo : rp.x;\n  const rpy = org ? rp.yo : rp.y;\n  const rpdx = rpx + d * pv.x;\n  const rpdy = rpy + d * pv.y;\n  const pvns = pv.normalSlope;\n  const fvs = this.slope;\n  const px = p.x;\n  const py = p.y;\n  p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n  p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function (p) {\n  p.xTouched = true;\n  p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n  const d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d;\n  if (x === 1 && y === 0) return xUnitVector;else if (x === 0 && y === 1) return yUnitVector;else return new UnitVector(x, y);\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(x, y, lastPointOfContour, onCurve) {\n  this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n  this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n  this.lastPointOfContour = lastPointOfContour;\n  this.onCurve = onCurve;\n  this.prevPointOnContour = undefined;\n  this.nextPointOnContour = undefined;\n  this.xTouched = false;\n  this.yTouched = false;\n  Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function (v) {\n  let p = this.nextPointOnContour;\n  while (!v.touched(p) && p !== this) p = p.nextPointOnContour;\n  return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function (v) {\n  let p = this.prevPointOnContour;\n  while (!v.touched(p) && p !== this) p = p.prevPointOnContour;\n  return p;\n};\n\n/*\n* The zero point.\n*/\nconst HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nconst defaultState = {\n  cvCutIn: 17 / 16,\n  // control value cut in\n  deltaBase: 9,\n  deltaShift: 0.125,\n  loop: 1,\n  // loops some instructions\n  minDis: 1,\n  // minimum distance\n  autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n  this.env = env;\n  this.stack = [];\n  this.prog = prog;\n  switch (env) {\n    case 'glyf':\n      this.zp0 = this.zp1 = this.zp2 = 1;\n      this.rp0 = this.rp1 = this.rp2 = 0;\n    /* fall through */\n    case 'prep':\n      this.fv = this.pv = this.dpv = xUnitVector;\n      this.round = roundToGrid;\n  }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function (glyph, ppem) {\n  if (typeof ppem !== 'number') {\n    throw new Error('Point size is not a number!');\n  }\n\n  // Received a fatal error, don't do any hinting anymore.\n  if (this._errorState > 2) return;\n  const font = this.font;\n  let prepState = this._prepState;\n  if (!prepState || prepState.ppem !== ppem) {\n    let fpgmState = this._fpgmState;\n    if (!fpgmState) {\n      // Executes the fpgm state.\n      // This is used by fonts to define functions.\n      State.prototype = defaultState;\n      fpgmState = this._fpgmState = new State('fpgm', font.tables.fpgm);\n      fpgmState.funcs = [];\n      fpgmState.font = font;\n      if (exports.DEBUG) {\n        console.log('---EXEC FPGM---');\n        fpgmState.step = -1;\n      }\n      try {\n        exec(fpgmState);\n      } catch (e) {\n        console.log('Hinting error in FPGM:' + e);\n        this._errorState = 3;\n        return;\n      }\n    }\n\n    // Executes the prep program for this ppem setting.\n    // This is used by fonts to set cvt values\n    // depending on to be rendered font size.\n\n    State.prototype = fpgmState;\n    prepState = this._prepState = new State('prep', font.tables.prep);\n    prepState.ppem = ppem;\n\n    // Creates a copy of the cvt table\n    // and scales it to the current ppem setting.\n    const oCvt = font.tables.cvt;\n    if (oCvt) {\n      const cvt = prepState.cvt = new Array(oCvt.length);\n      const scale = ppem / font.unitsPerEm;\n      for (let c = 0; c < oCvt.length; c++) {\n        cvt[c] = oCvt[c] * scale;\n      }\n    } else {\n      prepState.cvt = [];\n    }\n    if (exports.DEBUG) {\n      console.log('---EXEC PREP---');\n      prepState.step = -1;\n    }\n    try {\n      exec(prepState);\n    } catch (e) {\n      if (this._errorState < 2) {\n        console.log('Hinting error in PREP:' + e);\n      }\n      this._errorState = 2;\n    }\n  }\n  if (this._errorState > 1) return;\n  try {\n    return execGlyph(glyph, prepState);\n  } catch (e) {\n    if (this._errorState < 1) {\n      console.log('Hinting error:' + e);\n      console.log('Note: further hinting errors are silenced');\n    }\n    this._errorState = 1;\n    return undefined;\n  }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function (glyph, prepState) {\n  // original point positions\n  const xScale = prepState.ppem / prepState.font.unitsPerEm;\n  const yScale = xScale;\n  let components = glyph.components;\n  let contours;\n  let gZone;\n  let state;\n  State.prototype = prepState;\n  if (!components) {\n    state = new State('glyf', glyph.instructions);\n    if (exports.DEBUG) {\n      console.log('---EXEC GLYPH---');\n      state.step = -1;\n    }\n    execComponent(glyph, state, xScale, yScale);\n    gZone = state.gZone;\n  } else {\n    const font = prepState.font;\n    gZone = [];\n    contours = [];\n    for (let i = 0; i < components.length; i++) {\n      const c = components[i];\n      const cg = font.glyphs.get(c.glyphIndex);\n      state = new State('glyf', cg.instructions);\n      if (exports.DEBUG) {\n        console.log('---EXEC COMP ' + i + '---');\n        state.step = -1;\n      }\n      execComponent(cg, state, xScale, yScale);\n      // appends the computed points to the result array\n      // post processes the component points\n      const dx = Math.round(c.dx * xScale);\n      const dy = Math.round(c.dy * yScale);\n      const gz = state.gZone;\n      const cc = state.contours;\n      for (let pi = 0; pi < gz.length; pi++) {\n        const p = gz[pi];\n        p.xTouched = p.yTouched = false;\n        p.xo = p.x = p.x + dx;\n        p.yo = p.y = p.y + dy;\n      }\n      const gLen = gZone.length;\n      gZone.push.apply(gZone, gz);\n      for (let j = 0; j < cc.length; j++) {\n        contours.push(cc[j] + gLen);\n      }\n    }\n    if (glyph.instructions && !state.inhibitGridFit) {\n      // the composite has instructions on its own\n      state = new State('glyf', glyph.instructions);\n      state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n      state.contours = contours;\n\n      // note: HPZero cannot be used here, since\n      //       the point might be modified\n      gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));\n      if (exports.DEBUG) {\n        console.log('---EXEC COMPOSITE---');\n        state.step = -1;\n      }\n      exec(state);\n      gZone.length -= 2;\n    }\n  }\n  return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself by a non-component glyph.\n*/\nexecComponent = function (glyph, state, xScale, yScale) {\n  const points = glyph.points || [];\n  const pLen = points.length;\n  const gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n  const contours = state.contours = [];\n\n  // Scales the original points and\n  // makes copies for the hinted points.\n  let cp; // current point\n  for (let i = 0; i < pLen; i++) {\n    cp = points[i];\n    gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve);\n  }\n\n  // Chain links the contours.\n  let sp; // start point\n  let np; // next point\n\n  for (let i = 0; i < pLen; i++) {\n    cp = gZone[i];\n    if (!sp) {\n      sp = cp;\n      contours.push(i);\n    }\n    if (cp.lastPointOfContour) {\n      cp.nextPointOnContour = sp;\n      sp.prevPointOnContour = cp;\n      sp = undefined;\n    } else {\n      np = gZone[i + 1];\n      cp.nextPointOnContour = np;\n      np.prevPointOnContour = cp;\n    }\n  }\n  if (state.inhibitGridFit) return;\n  gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));\n  exec(state);\n\n  // Removes the extra points.\n  gZone.length -= 2;\n  if (exports.DEBUG) {\n    console.log('FINISHED GLYPH', state.stack);\n    for (let i = 0; i < pLen; i++) {\n      console.log(i, gZone[i].x, gZone[i].y);\n    }\n  }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function (state) {\n  let prog = state.prog;\n  if (!prog) return;\n  const pLen = prog.length;\n  let ins;\n  for (state.ip = 0; state.ip < pLen; state.ip++) {\n    if (exports.DEBUG) state.step++;\n    ins = instructionTable[prog[state.ip]];\n    if (!ins) {\n      throw new Error('unknown instruction: 0x' + Number(prog[state.ip]).toString(16));\n    }\n    ins(state);\n\n    // very extensive debugging for each step\n    /*\n    if (exports.DEBUG) {\n        var da;\n        if (state.gZone) {\n            da = [];\n            for (let i = 0; i < state.gZone.length; i++)\n            {\n                da.push(i + ' ' +\n                    state.gZone[i].x * 64 + ' ' +\n                    state.gZone[i].y * 64 + ' ' +\n                    (state.gZone[i].xTouched ? 'x' : '') +\n                    (state.gZone[i].yTouched ? 'y' : '')\n                );\n            }\n            console.log('GZ', da);\n        }\n         if (state.tZone) {\n            da = [];\n            for (let i = 0; i < state.tZone.length; i++) {\n                da.push(i + ' ' +\n                    state.tZone[i].x * 64 + ' ' +\n                    state.tZone[i].y * 64 + ' ' +\n                    (state.tZone[i].xTouched ? 'x' : '') +\n                    (state.tZone[i].yTouched ? 'y' : '')\n                );\n            }\n            console.log('TZ', da);\n        }\n         if (state.stack.length > 10) {\n            console.log(\n                state.stack.length,\n                '...', state.stack.slice(state.stack.length - 10)\n            );\n        } else {\n            console.log(state.stack.length, state.stack);\n        }\n    }\n    */\n  }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state) {\n  const tZone = state.tZone = new Array(state.gZone.length);\n\n  // no idea if this is actually correct...\n  for (let i = 0; i < tZone.length; i++) {\n    tZone[i] = new HPoint(0, 0);\n  }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse) {\n  const prog = state.prog;\n  let ip = state.ip;\n  let nesting = 1;\n  let ins;\n  do {\n    ins = prog[++ip];\n    if (ins === 0x58)\n      // IF\n      nesting++;else if (ins === 0x59)\n      // EIF\n      nesting--;else if (ins === 0x40)\n      // NPUSHB\n      ip += prog[ip + 1] + 1;else if (ins === 0x41)\n      // NPUSHW\n      ip += 2 * prog[ip + 1] + 1;else if (ins >= 0xB0 && ins <= 0xB7)\n      // PUSHB\n      ip += ins - 0xB0 + 1;else if (ins >= 0xB8 && ins <= 0xBF)\n      // PUSHW\n      ip += (ins - 0xB8 + 1) * 2;else if (handleElse && nesting === 1 && ins === 0x1B)\n      // ELSE\n      break;\n  } while (nesting > 0);\n  state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n  if (exports.DEBUG) console.log(state.step, 'SVTCA[' + v.axis + ']');\n  state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n  if (exports.DEBUG) console.log(state.step, 'SPVTCA[' + v.axis + ']');\n  state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n  if (exports.DEBUG) console.log(state.step, 'SFVTCA[' + v.axis + ']');\n  state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n  const stack = state.stack;\n  const p2i = stack.pop();\n  const p1i = stack.pop();\n  const p2 = state.z2[p2i];\n  const p1 = state.z1[p1i];\n  if (exports.DEBUG) console.log('SPVTL[' + a + ']', p2i, p1i);\n  let dx;\n  let dy;\n  if (!a) {\n    dx = p1.x - p2.x;\n    dy = p1.y - p2.y;\n  } else {\n    dx = p2.y - p1.y;\n    dy = p1.x - p2.x;\n  }\n  state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n  const stack = state.stack;\n  const p2i = stack.pop();\n  const p1i = stack.pop();\n  const p2 = state.z2[p2i];\n  const p1 = state.z1[p1i];\n  if (exports.DEBUG) console.log('SFVTL[' + a + ']', p2i, p1i);\n  let dx;\n  let dy;\n  if (!a) {\n    dx = p1.x - p2.x;\n    dy = p1.y - p2.y;\n  } else {\n    dx = p2.y - p1.y;\n    dy = p1.x - p2.x;\n  }\n  state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n  const stack = state.stack;\n  const y = stack.pop();\n  const x = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n  state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n  const stack = state.stack;\n  const y = stack.pop();\n  const x = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n  state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n  const stack = state.stack;\n  const pv = state.pv;\n  if (exports.DEBUG) console.log(state.step, 'GPV[]');\n  stack.push(pv.x * 0x4000);\n  stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n  const stack = state.stack;\n  const fv = state.fv;\n  if (exports.DEBUG) console.log(state.step, 'GFV[]');\n  stack.push(fv.x * 0x4000);\n  stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n  state.fv = state.pv;\n  if (exports.DEBUG) console.log(state.step, 'SFVTPV[]');\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state) {\n  const stack = state.stack;\n  const pa0i = stack.pop();\n  const pa1i = stack.pop();\n  const pb0i = stack.pop();\n  const pb1i = stack.pop();\n  const pi = stack.pop();\n  const z0 = state.z0;\n  const z1 = state.z1;\n  const pa0 = z0[pa0i];\n  const pa1 = z0[pa1i];\n  const pb0 = z1[pb0i];\n  const pb1 = z1[pb1i];\n  const p = state.z2[pi];\n  if (exports.DEBUG) console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi);\n\n  // math from\n  // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n  const x1 = pa0.x;\n  const y1 = pa0.y;\n  const x2 = pa1.x;\n  const y2 = pa1.y;\n  const x3 = pb0.x;\n  const y3 = pb0.y;\n  const x4 = pb1.x;\n  const y4 = pb1.y;\n  const div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n  const f1 = x1 * y2 - y1 * x2;\n  const f2 = x3 * y4 - y3 * x4;\n  p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n  p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n  state.rp0 = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SRP0[]', state.rp0);\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n  state.rp1 = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SRP1[]', state.rp1);\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n  state.rp2 = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SRP2[]', state.rp2);\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n  const n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZP0[]', n);\n  state.zp0 = n;\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z0 = state.tZone;\n      break;\n    case 1:\n      state.z0 = state.gZone;\n      break;\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n  const n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZP1[]', n);\n  state.zp1 = n;\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z1 = state.tZone;\n      break;\n    case 1:\n      state.z1 = state.gZone;\n      break;\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n  const n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZP2[]', n);\n  state.zp2 = n;\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z2 = state.tZone;\n      break;\n    case 1:\n      state.z2 = state.gZone;\n      break;\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n  const n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZPS[]', n);\n  state.zp0 = state.zp1 = state.zp2 = n;\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z0 = state.z1 = state.z2 = state.tZone;\n      break;\n    case 1:\n      state.z0 = state.z1 = state.z2 = state.gZone;\n      break;\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n  state.loop = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SLOOP[]', state.loop);\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RTG[]');\n  state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RTHG[]');\n  state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n  const d = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SMD[]', d);\n  state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n  // This instruction has been reached by executing a then branch\n  // so it just skips ahead until matching EIF.\n  //\n  // In case the IF was negative the IF[] instruction already\n  // skipped forward over the ELSE[]\n\n  if (exports.DEBUG) console.log(state.step, 'ELSE[]');\n  skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n  const o = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'JMPR[]', o);\n\n  // A jump by 1 would do nothing.\n  state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n  const n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SCVTCI[]', n);\n  state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n  const stack = state.stack;\n  if (exports.DEBUG) console.log(state.step, 'DUP[]');\n  stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n  if (exports.DEBUG) console.log(state.step, 'POP[]');\n  state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n  if (exports.DEBUG) console.log(state.step, 'CLEAR[]');\n  state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n  const stack = state.stack;\n  const a = stack.pop();\n  const b = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SWAP[]');\n  stack.push(a);\n  stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n  const stack = state.stack;\n  if (exports.DEBUG) console.log(state.step, 'DEPTH[]');\n  stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n  const stack = state.stack;\n  const fn = stack.pop();\n  const c = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'LOOPCALL[]', fn, c);\n\n  // saves callers program\n  const cip = state.ip;\n  const cprog = state.prog;\n  state.prog = state.funcs[fn];\n\n  // executes the function\n  for (let i = 0; i < c; i++) {\n    exec(state);\n    if (exports.DEBUG) console.log(++state.step, i + 1 < c ? 'next loopcall' : 'done loopcall', i);\n  }\n\n  // restores the callers program\n  state.ip = cip;\n  state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n  const fn = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'CALL[]', fn);\n\n  // saves callers program\n  const cip = state.ip;\n  const cprog = state.prog;\n  state.prog = state.funcs[fn];\n\n  // executes the function\n  exec(state);\n\n  // restores the callers program\n  state.ip = cip;\n  state.prog = cprog;\n  if (exports.DEBUG) console.log(++state.step, 'returning from', fn);\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n  const stack = state.stack;\n  const k = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'CINDEX[]', k);\n\n  // In case of k == 1, it copies the last element after popping\n  // thus stack.length - k.\n  stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n  const stack = state.stack;\n  const k = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MINDEX[]', k);\n  stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n  if (state.env !== 'fpgm') throw new Error('FDEF not allowed here');\n  const stack = state.stack;\n  const prog = state.prog;\n  let ip = state.ip;\n  const fn = stack.pop();\n  const ipBegin = ip;\n  if (exports.DEBUG) console.log(state.step, 'FDEF[]', fn);\n  while (prog[++ip] !== 0x2D);\n  state.ip = ip;\n  state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n  const pi = state.stack.pop();\n  const p = state.z0[pi];\n  const fv = state.fv;\n  const pv = state.pv;\n  if (exports.DEBUG) console.log(state.step, 'MDAP[' + round + ']', pi);\n  let d = pv.distance(p, HPZero);\n  if (round) d = state.round(d);\n  fv.setRelative(p, HPZero, d, pv);\n  fv.touch(p);\n  state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n  const z2 = state.z2;\n  const pLen = z2.length - 2;\n  let cp;\n  let pp;\n  let np;\n  if (exports.DEBUG) console.log(state.step, 'IUP[' + v.axis + ']');\n  for (let i = 0; i < pLen; i++) {\n    cp = z2[i]; // current point\n\n    // if this point has been touched go on\n    if (v.touched(cp)) continue;\n    pp = cp.prevTouched(v);\n\n    // no point on the contour has been touched?\n    if (pp === cp) continue;\n    np = cp.nextTouched(v);\n    if (pp === np) {\n      // only one point on the contour has been touched\n      // so simply moves the point like that\n\n      v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n    }\n    v.interpolate(cp, pp, np, v);\n  }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n  const stack = state.stack;\n  const rpi = a ? state.rp1 : state.rp2;\n  const rp = (a ? state.z0 : state.z1)[rpi];\n  const fv = state.fv;\n  const pv = state.pv;\n  let loop = state.loop;\n  const z2 = state.z2;\n  while (loop--) {\n    const pi = stack.pop();\n    const p = z2[pi];\n    const d = pv.distance(rp, rp, false, true);\n    fv.setRelative(p, p, d, pv);\n    fv.touch(p);\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi);\n    }\n  }\n  state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n  const stack = state.stack;\n  const rpi = a ? state.rp1 : state.rp2;\n  const rp = (a ? state.z0 : state.z1)[rpi];\n  const fv = state.fv;\n  const pv = state.pv;\n  const ci = stack.pop();\n  const sp = state.z2[state.contours[ci]];\n  let p = sp;\n  if (exports.DEBUG) console.log(state.step, 'SHC[' + a + ']', ci);\n  const d = pv.distance(rp, rp, false, true);\n  do {\n    if (p !== rp) fv.setRelative(p, p, d, pv);\n    p = p.nextPointOnContour;\n  } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n  const stack = state.stack;\n  const rpi = a ? state.rp1 : state.rp2;\n  const rp = (a ? state.z0 : state.z1)[rpi];\n  const fv = state.fv;\n  const pv = state.pv;\n  const e = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SHZ[' + a + ']', e);\n  let z;\n  switch (e) {\n    case 0:\n      z = state.tZone;\n      break;\n    case 1:\n      z = state.gZone;\n      break;\n    default:\n      throw new Error('Invalid zone');\n  }\n  let p;\n  const d = pv.distance(rp, rp, false, true);\n  const pLen = z.length - 2;\n  for (let i = 0; i < pLen; i++) {\n    p = z[i];\n    if (p !== rp) fv.setRelative(p, p, d, pv);\n  }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n  const stack = state.stack;\n  let loop = state.loop;\n  const fv = state.fv;\n  const d = stack.pop() / 0x40;\n  const z2 = state.z2;\n  while (loop--) {\n    const pi = stack.pop();\n    const p = z2[pi];\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHPIX[]', pi, d);\n    }\n    fv.setRelative(p, p, d);\n    fv.touch(p);\n  }\n  state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n  const stack = state.stack;\n  const rp1i = state.rp1;\n  const rp2i = state.rp2;\n  let loop = state.loop;\n  const rp1 = state.z0[rp1i];\n  const rp2 = state.z1[rp2i];\n  const fv = state.fv;\n  const pv = state.dpv;\n  const z2 = state.z2;\n  while (loop--) {\n    const pi = stack.pop();\n    const p = z2[pi];\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'IP[]', pi, rp1i, '<->', rp2i);\n    }\n    fv.interpolate(p, rp1, rp2, pv);\n    fv.touch(p);\n  }\n  state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n  const stack = state.stack;\n  const d = stack.pop() / 64;\n  const pi = stack.pop();\n  const p = state.z1[pi];\n  const rp0 = state.z0[state.rp0];\n  const fv = state.fv;\n  const pv = state.pv;\n  fv.setRelative(p, rp0, d, pv);\n  fv.touch(p);\n  if (exports.DEBUG) console.log(state.step, 'MSIRP[' + a + ']', d, pi);\n  state.rp1 = state.rp0;\n  state.rp2 = pi;\n  if (a) state.rp0 = pi;\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n  const stack = state.stack;\n  const rp0i = state.rp0;\n  const rp0 = state.z0[rp0i];\n  let loop = state.loop;\n  const fv = state.fv;\n  const pv = state.pv;\n  const z1 = state.z1;\n  while (loop--) {\n    const pi = stack.pop();\n    const p = z1[pi];\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'ALIGNRP[]', pi);\n    }\n    fv.setRelative(p, rp0, 0, pv);\n    fv.touch(p);\n  }\n  state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RTDG[]');\n  state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  const pi = stack.pop();\n  const p = state.z0[pi];\n  const fv = state.fv;\n  const pv = state.pv;\n  let cv = state.cvt[n];\n\n  // TODO cvtcutin should be considered here\n  if (round) cv = state.round(cv);\n  if (exports.DEBUG) {\n    console.log(state.step, 'MIAP[' + round + ']', n, '(', cv, ')', pi);\n  }\n  fv.setRelative(p, HPZero, cv, pv);\n  if (state.zp0 === 0) {\n    p.xo = p.x;\n    p.yo = p.y;\n  }\n  fv.touch(p);\n  state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n  const prog = state.prog;\n  let ip = state.ip;\n  const stack = state.stack;\n  const n = prog[++ip];\n  if (exports.DEBUG) console.log(state.step, 'NPUSHB[]', n);\n  for (let i = 0; i < n; i++) stack.push(prog[++ip]);\n  state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n  let ip = state.ip;\n  const prog = state.prog;\n  const stack = state.stack;\n  const n = prog[++ip];\n  if (exports.DEBUG) console.log(state.step, 'NPUSHW[]', n);\n  for (let i = 0; i < n; i++) {\n    let w = prog[++ip] << 8 | prog[++ip];\n    if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n    stack.push(w);\n  }\n  state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n  const stack = state.stack;\n  let store = state.store;\n  if (!store) store = state.store = [];\n  const v = stack.pop();\n  const l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'WS', v, l);\n  store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n  const stack = state.stack;\n  const store = state.store;\n  const l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'RS', l);\n  const v = store && store[l] || 0;\n  stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n  const stack = state.stack;\n  const v = stack.pop();\n  const l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'WCVTP', v, l);\n  state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n  const stack = state.stack;\n  const cvte = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'RCVT', cvte);\n  stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n  const stack = state.stack;\n  const pi = stack.pop();\n  const p = state.z2[pi];\n  if (exports.DEBUG) console.log(state.step, 'GC[' + a + ']', pi);\n  stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n  const stack = state.stack;\n  const pi2 = stack.pop();\n  const pi1 = stack.pop();\n  const p2 = state.z1[pi2];\n  const p1 = state.z0[pi1];\n  const d = state.dpv.distance(p1, p2, a, a);\n  if (exports.DEBUG) console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d);\n  state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n  if (exports.DEBUG) console.log(state.step, 'MPPEM[]');\n  state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n  if (exports.DEBUG) console.log(state.step, 'FLIPON[]');\n  state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'LT[]', e2, e1);\n  stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'LTEQ[]', e2, e1);\n  stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'GT[]', e2, e1);\n  stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'GTEQ[]', e2, e1);\n  stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'EQ[]', e2, e1);\n  stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'NEQ[]', e2, e1);\n  stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ODD[]', n);\n  stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'EVEN[]', n);\n  stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n  let test = state.stack.pop();\n  let ins;\n  if (exports.DEBUG) console.log(state.step, 'IF[]', test);\n\n  // if test is true it just continues\n  // if not the ip is skipped until matching ELSE or EIF\n  if (!test) {\n    skip(state, true);\n    if (exports.DEBUG) console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]');\n  }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n  // this can be reached normally when\n  // executing an else branch.\n  // -> just ignore it\n\n  if (exports.DEBUG) console.log(state.step, 'EIF[]');\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'AND[]', e2, e1);\n  stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'OR[]', e2, e1);\n  stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n  const stack = state.stack;\n  const e = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'NOT[]', e);\n  stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  const fv = state.fv;\n  const pv = state.pv;\n  const ppem = state.ppem;\n  const base = state.deltaBase + (b - 1) * 16;\n  const ds = state.deltaShift;\n  const z0 = state.z0;\n  if (exports.DEBUG) console.log(state.step, 'DELTAP[' + b + ']', n, stack);\n  for (let i = 0; i < n; i++) {\n    const pi = stack.pop();\n    const arg = stack.pop();\n    const appem = base + ((arg & 0xF0) >> 4);\n    if (appem !== ppem) continue;\n    let mag = (arg & 0x0F) - 8;\n    if (mag >= 0) mag++;\n    if (exports.DEBUG) console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds);\n    const p = z0[pi];\n    fv.setRelative(p, p, mag * ds, pv);\n  }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SDB[]', n);\n  state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SDS[]', n);\n  state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n  const stack = state.stack;\n  const n2 = stack.pop();\n  const n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ADD[]', n2, n1);\n  stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n  const stack = state.stack;\n  const n2 = stack.pop();\n  const n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SUB[]', n2, n1);\n  stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n  const stack = state.stack;\n  const n2 = stack.pop();\n  const n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'DIV[]', n2, n1);\n  stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n  const stack = state.stack;\n  const n2 = stack.pop();\n  const n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MUL[]', n2, n1);\n  stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ABS[]', n);\n  stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n  const stack = state.stack;\n  let n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'NEG[]', n);\n  stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'FLOOR[]', n);\n  stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'CEILING[]', n);\n  stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ROUND[]');\n  stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n  const stack = state.stack;\n  const v = stack.pop();\n  const l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'WCVTF[]', v, l);\n  state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n  const stack = state.stack;\n  const n = stack.pop();\n  const ppem = state.ppem;\n  const base = state.deltaBase + (b - 1) * 16;\n  const ds = state.deltaShift;\n  if (exports.DEBUG) console.log(state.step, 'DELTAC[' + b + ']', n, stack);\n  for (let i = 0; i < n; i++) {\n    const c = stack.pop();\n    const arg = stack.pop();\n    const appem = base + ((arg & 0xF0) >> 4);\n    if (appem !== ppem) continue;\n    let mag = (arg & 0x0F) - 8;\n    if (mag >= 0) mag++;\n    const delta = mag * ds;\n    if (exports.DEBUG) console.log(state.step, 'DELTACFIX', c, 'by', delta);\n    state.cvt[c] += delta;\n  }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n  let n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SROUND[]', n);\n  state.round = roundSuper;\n  let period;\n  switch (n & 0xC0) {\n    case 0x00:\n      period = 0.5;\n      break;\n    case 0x40:\n      period = 1;\n      break;\n    case 0x80:\n      period = 2;\n      break;\n    default:\n      throw new Error('invalid SROUND value');\n  }\n  state.srPeriod = period;\n  switch (n & 0x30) {\n    case 0x00:\n      state.srPhase = 0;\n      break;\n    case 0x10:\n      state.srPhase = 0.25 * period;\n      break;\n    case 0x20:\n      state.srPhase = 0.5 * period;\n      break;\n    case 0x30:\n      state.srPhase = 0.75 * period;\n      break;\n    default:\n      throw new Error('invalid SROUND value');\n  }\n  n &= 0x0F;\n  if (n === 0) state.srThreshold = 0;else state.srThreshold = (n / 8 - 0.5) * period;\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n  let n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'S45ROUND[]', n);\n  state.round = roundSuper;\n  let period;\n  switch (n & 0xC0) {\n    case 0x00:\n      period = Math.sqrt(2) / 2;\n      break;\n    case 0x40:\n      period = Math.sqrt(2);\n      break;\n    case 0x80:\n      period = 2 * Math.sqrt(2);\n      break;\n    default:\n      throw new Error('invalid S45ROUND value');\n  }\n  state.srPeriod = period;\n  switch (n & 0x30) {\n    case 0x00:\n      state.srPhase = 0;\n      break;\n    case 0x10:\n      state.srPhase = 0.25 * period;\n      break;\n    case 0x20:\n      state.srPhase = 0.5 * period;\n      break;\n    case 0x30:\n      state.srPhase = 0.75 * period;\n      break;\n    default:\n      throw new Error('invalid S45ROUND value');\n  }\n  n &= 0x0F;\n  if (n === 0) state.srThreshold = 0;else state.srThreshold = (n / 8 - 0.5) * period;\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n  if (exports.DEBUG) console.log(state.step, 'ROFF[]');\n  state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RUTG[]');\n  state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RDTG[]');\n  state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n  const n = state.stack.pop();\n\n  // ignored by opentype.js\n\n  if (exports.DEBUG) console.log(state.step, 'SCANCTRL[]', n);\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n  const stack = state.stack;\n  const p2i = stack.pop();\n  const p1i = stack.pop();\n  const p2 = state.z2[p2i];\n  const p1 = state.z1[p1i];\n  if (exports.DEBUG) console.log('SDPVTL[' + a + ']', p2i, p1i);\n  let dx;\n  let dy;\n  if (!a) {\n    dx = p1.x - p2.x;\n    dy = p1.y - p2.y;\n  } else {\n    dx = p2.y - p1.y;\n    dy = p1.x - p2.x;\n  }\n  state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n  const stack = state.stack;\n  const sel = stack.pop();\n  let r = 0;\n  if (exports.DEBUG) console.log(state.step, 'GETINFO[]', sel);\n\n  // v35 as in no subpixel hinting\n  if (sel & 0x01) r = 35;\n\n  // TODO rotation and stretch currently not supported\n  // and thus those GETINFO are always 0.\n\n  // opentype.js is always gray scaling\n  if (sel & 0x20) r |= 0x1000;\n  stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n  const stack = state.stack;\n  const a = stack.pop();\n  const b = stack.pop();\n  const c = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ROLL[]');\n  stack.push(b);\n  stack.push(a);\n  stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MAX[]', e2, e1);\n  stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n  const stack = state.stack;\n  const e2 = stack.pop();\n  const e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MIN[]', e2, e1);\n  stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n  const n = state.stack.pop();\n  // ignored by opentype.js\n  if (exports.DEBUG) console.log(state.step, 'SCANTYPE[]', n);\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n  const s = state.stack.pop();\n  let v = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'INSTCTRL[]', s, v);\n  switch (s) {\n    case 1:\n      state.inhibitGridFit = !!v;\n      return;\n    case 2:\n      state.ignoreCvt = !!v;\n      return;\n    default:\n      throw new Error('invalid INSTCTRL[] selector');\n  }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n  const stack = state.stack;\n  const prog = state.prog;\n  let ip = state.ip;\n  if (exports.DEBUG) console.log(state.step, 'PUSHB[' + n + ']');\n  for (let i = 0; i < n; i++) stack.push(prog[++ip]);\n  state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n  let ip = state.ip;\n  const prog = state.prog;\n  const stack = state.stack;\n  if (exports.DEBUG) console.log(state.ip, 'PUSHW[' + n + ']');\n  for (let i = 0; i < n; i++) {\n    let w = prog[++ip] << 8 | prog[++ip];\n    if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n    stack.push(w);\n  }\n  state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n  const stack = state.stack;\n  const cvte = indirect && stack.pop();\n  const pi = stack.pop();\n  const rp0i = state.rp0;\n  const rp = state.z0[rp0i];\n  const p = state.z1[pi];\n  const md = state.minDis;\n  const fv = state.fv;\n  const pv = state.dpv;\n  let od; // original distance\n  let d; // moving distance\n  let sign; // sign of distance\n  let cv;\n  d = od = pv.distance(p, rp, true, true);\n  sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n  // TODO consider autoFlip\n  d = Math.abs(d);\n  if (indirect) {\n    cv = state.cvt[cvte];\n    if (ro && Math.abs(d - cv) < state.cvCutIn) d = cv;\n  }\n  if (keepD && d < md) d = md;\n  if (ro) d = state.round(d);\n  fv.setRelative(p, rp, sign * d, pv);\n  fv.touch(p);\n  if (exports.DEBUG) {\n    console.log(state.step, (indirect ? 'MIRP[' : 'MDRP[') + (setRp0 ? 'M' : 'm') + (keepD ? '>' : '_') + (ro ? 'R' : '_') + (dt === 0 ? 'Gr' : dt === 1 ? 'Bl' : dt === 2 ? 'Wh' : '') + ']', indirect ? cvte + '(' + state.cvt[cvte] + ',' + cv + ')' : '', pi, '(d =', od, '->', sign * d, ')');\n  }\n  state.rp1 = state.rp0;\n  state.rp2 = pi;\n  if (setRp0) state.rp0 = pi;\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [/* 0x00 */SVTCA.bind(undefined, yUnitVector), /* 0x01 */SVTCA.bind(undefined, xUnitVector), /* 0x02 */SPVTCA.bind(undefined, yUnitVector), /* 0x03 */SPVTCA.bind(undefined, xUnitVector), /* 0x04 */SFVTCA.bind(undefined, yUnitVector), /* 0x05 */SFVTCA.bind(undefined, xUnitVector), /* 0x06 */SPVTL.bind(undefined, 0), /* 0x07 */SPVTL.bind(undefined, 1), /* 0x08 */SFVTL.bind(undefined, 0), /* 0x09 */SFVTL.bind(undefined, 1), /* 0x0A */SPVFS, /* 0x0B */SFVFS, /* 0x0C */GPV, /* 0x0D */GFV, /* 0x0E */SFVTPV, /* 0x0F */ISECT, /* 0x10 */SRP0, /* 0x11 */SRP1, /* 0x12 */SRP2, /* 0x13 */SZP0, /* 0x14 */SZP1, /* 0x15 */SZP2, /* 0x16 */SZPS, /* 0x17 */SLOOP, /* 0x18 */RTG, /* 0x19 */RTHG, /* 0x1A */SMD, /* 0x1B */ELSE, /* 0x1C */JMPR, /* 0x1D */SCVTCI, /* 0x1E */undefined,\n// TODO SSWCI\n/* 0x1F */\nundefined,\n// TODO SSW\n/* 0x20 */\nDUP, /* 0x21 */POP, /* 0x22 */CLEAR, /* 0x23 */SWAP, /* 0x24 */DEPTH, /* 0x25 */CINDEX, /* 0x26 */MINDEX, /* 0x27 */undefined,\n// TODO ALIGNPTS\n/* 0x28 */\nundefined, /* 0x29 */undefined,\n// TODO UTP\n/* 0x2A */\nLOOPCALL, /* 0x2B */CALL, /* 0x2C */FDEF, /* 0x2D */undefined,\n// ENDF (eaten by FDEF)\n/* 0x2E */\nMDAP.bind(undefined, 0), /* 0x2F */MDAP.bind(undefined, 1), /* 0x30 */IUP.bind(undefined, yUnitVector), /* 0x31 */IUP.bind(undefined, xUnitVector), /* 0x32 */SHP.bind(undefined, 0), /* 0x33 */SHP.bind(undefined, 1), /* 0x34 */SHC.bind(undefined, 0), /* 0x35 */SHC.bind(undefined, 1), /* 0x36 */SHZ.bind(undefined, 0), /* 0x37 */SHZ.bind(undefined, 1), /* 0x38 */SHPIX, /* 0x39 */IP, /* 0x3A */MSIRP.bind(undefined, 0), /* 0x3B */MSIRP.bind(undefined, 1), /* 0x3C */ALIGNRP, /* 0x3D */RTDG, /* 0x3E */MIAP.bind(undefined, 0), /* 0x3F */MIAP.bind(undefined, 1), /* 0x40 */NPUSHB, /* 0x41 */NPUSHW, /* 0x42 */WS, /* 0x43 */RS, /* 0x44 */WCVTP, /* 0x45 */RCVT, /* 0x46 */GC.bind(undefined, 0), /* 0x47 */GC.bind(undefined, 1), /* 0x48 */undefined,\n// TODO SCFS\n/* 0x49 */\nMD.bind(undefined, 0), /* 0x4A */MD.bind(undefined, 1), /* 0x4B */MPPEM, /* 0x4C */undefined,\n// TODO MPS\n/* 0x4D */\nFLIPON, /* 0x4E */undefined,\n// TODO FLIPOFF\n/* 0x4F */\nundefined,\n// TODO DEBUG\n/* 0x50 */\nLT, /* 0x51 */LTEQ, /* 0x52 */GT, /* 0x53 */GTEQ, /* 0x54 */EQ, /* 0x55 */NEQ, /* 0x56 */ODD, /* 0x57 */EVEN, /* 0x58 */IF, /* 0x59 */EIF, /* 0x5A */AND, /* 0x5B */OR, /* 0x5C */NOT, /* 0x5D */DELTAP123.bind(undefined, 1), /* 0x5E */SDB, /* 0x5F */SDS, /* 0x60 */ADD, /* 0x61 */SUB, /* 0x62 */DIV, /* 0x63 */MUL, /* 0x64 */ABS, /* 0x65 */NEG, /* 0x66 */FLOOR, /* 0x67 */CEILING, /* 0x68 */ROUND.bind(undefined, 0), /* 0x69 */ROUND.bind(undefined, 1), /* 0x6A */ROUND.bind(undefined, 2), /* 0x6B */ROUND.bind(undefined, 3), /* 0x6C */undefined,\n// TODO NROUND[ab]\n/* 0x6D */\nundefined,\n// TODO NROUND[ab]\n/* 0x6E */\nundefined,\n// TODO NROUND[ab]\n/* 0x6F */\nundefined,\n// TODO NROUND[ab]\n/* 0x70 */\nWCVTF, /* 0x71 */DELTAP123.bind(undefined, 2), /* 0x72 */DELTAP123.bind(undefined, 3), /* 0x73 */DELTAC123.bind(undefined, 1), /* 0x74 */DELTAC123.bind(undefined, 2), /* 0x75 */DELTAC123.bind(undefined, 3), /* 0x76 */SROUND, /* 0x77 */S45ROUND, /* 0x78 */undefined,\n// TODO JROT[]\n/* 0x79 */\nundefined,\n// TODO JROF[]\n/* 0x7A */\nROFF, /* 0x7B */undefined, /* 0x7C */RUTG, /* 0x7D */RDTG, /* 0x7E */POP,\n// actually SANGW, supposed to do only a pop though\n/* 0x7F */\nPOP,\n// actually AA, supposed to do only a pop though\n/* 0x80 */\nundefined,\n// TODO FLIPPT\n/* 0x81 */\nundefined,\n// TODO FLIPRGON\n/* 0x82 */\nundefined,\n// TODO FLIPRGOFF\n/* 0x83 */\nundefined, /* 0x84 */undefined, /* 0x85 */SCANCTRL, /* 0x86 */SDPVTL.bind(undefined, 0), /* 0x87 */SDPVTL.bind(undefined, 1), /* 0x88 */GETINFO, /* 0x89 */undefined,\n// TODO IDEF\n/* 0x8A */\nROLL, /* 0x8B */MAX, /* 0x8C */MIN, /* 0x8D */SCANTYPE, /* 0x8E */INSTCTRL, /* 0x8F */undefined, /* 0x90 */undefined, /* 0x91 */undefined, /* 0x92 */undefined, /* 0x93 */undefined, /* 0x94 */undefined, /* 0x95 */undefined, /* 0x96 */undefined, /* 0x97 */undefined, /* 0x98 */undefined, /* 0x99 */undefined, /* 0x9A */undefined, /* 0x9B */undefined, /* 0x9C */undefined, /* 0x9D */undefined, /* 0x9E */undefined, /* 0x9F */undefined, /* 0xA0 */undefined, /* 0xA1 */undefined, /* 0xA2 */undefined, /* 0xA3 */undefined, /* 0xA4 */undefined, /* 0xA5 */undefined, /* 0xA6 */undefined, /* 0xA7 */undefined, /* 0xA8 */undefined, /* 0xA9 */undefined, /* 0xAA */undefined, /* 0xAB */undefined, /* 0xAC */undefined, /* 0xAD */undefined, /* 0xAE */undefined, /* 0xAF */undefined, /* 0xB0 */PUSHB.bind(undefined, 1), /* 0xB1 */PUSHB.bind(undefined, 2), /* 0xB2 */PUSHB.bind(undefined, 3), /* 0xB3 */PUSHB.bind(undefined, 4), /* 0xB4 */PUSHB.bind(undefined, 5), /* 0xB5 */PUSHB.bind(undefined, 6), /* 0xB6 */PUSHB.bind(undefined, 7), /* 0xB7 */PUSHB.bind(undefined, 8), /* 0xB8 */PUSHW.bind(undefined, 1), /* 0xB9 */PUSHW.bind(undefined, 2), /* 0xBA */PUSHW.bind(undefined, 3), /* 0xBB */PUSHW.bind(undefined, 4), /* 0xBC */PUSHW.bind(undefined, 5), /* 0xBD */PUSHW.bind(undefined, 6), /* 0xBE */PUSHW.bind(undefined, 7), /* 0xBF */PUSHW.bind(undefined, 8), /* 0xC0 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0), /* 0xC1 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1), /* 0xC2 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2), /* 0xC3 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3), /* 0xC4 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0), /* 0xC5 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1), /* 0xC6 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2), /* 0xC7 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3), /* 0xC8 */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0), /* 0xC9 */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1), /* 0xCA */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2), /* 0xCB */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3), /* 0xCC */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0), /* 0xCD */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1), /* 0xCE */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2), /* 0xCF */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3), /* 0xD0 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0), /* 0xD1 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1), /* 0xD2 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2), /* 0xD3 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3), /* 0xD4 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0), /* 0xD5 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1), /* 0xD6 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2), /* 0xD7 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3), /* 0xD8 */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0), /* 0xD9 */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1), /* 0xDA */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2), /* 0xDB */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3), /* 0xDC */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0), /* 0xDD */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1), /* 0xDE */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2), /* 0xDF */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3), /* 0xE0 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0), /* 0xE1 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1), /* 0xE2 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2), /* 0xE3 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3), /* 0xE4 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0), /* 0xE5 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1), /* 0xE6 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2), /* 0xE7 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3), /* 0xE8 */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0), /* 0xE9 */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1), /* 0xEA */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2), /* 0xEB */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3), /* 0xEC */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0), /* 0xED */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1), /* 0xEE */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2), /* 0xEF */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3), /* 0xF0 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0), /* 0xF1 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1), /* 0xF2 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2), /* 0xF3 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3), /* 0xF4 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0), /* 0xF5 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1), /* 0xF6 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2), /* 0xF7 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3), /* 0xF8 */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0), /* 0xF9 */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1), /* 0xFA */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2), /* 0xFB */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3), /* 0xFC */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0), /* 0xFD */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1), /* 0xFE */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2), /* 0xFF */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)];\nexport default Hinting;\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/","map":{"version":3,"names":["instructionTable","exec","execGlyph","execComponent","Hinting","font","_fpgmState","_prepState","undefined","_errorState","roundOff","v","roundToGrid","Math","sign","round","abs","roundToDoubleGrid","roundToHalfGrid","roundUpToGrid","ceil","roundDownToGrid","floor","roundSuper","period","srPeriod","phase","srPhase","threshold","srThreshold","trunc","xUnitVector","x","y","axis","distance","p1","p2","o1","o2","xo","interpolate","p","rp1","rp2","pv","do1","do2","doa1","doa2","dm1","dm2","dt","setRelative","normalSlope","Number","NEGATIVE_INFINITY","rp","d","org","rpx","rpy","yo","rpdx","rpdy","slope","touch","xTouched","touched","untouch","yUnitVector","POSITIVE_INFINITY","yTouched","Object","freeze","UnitVector","prototype","pvns","fvs","px","py","getUnitVector","sqrt","HPoint","lastPointOfContour","onCurve","prevPointOnContour","nextPointOnContour","preventExtensions","nextTouched","prevTouched","HPZero","defaultState","cvCutIn","deltaBase","deltaShift","loop","minDis","autoFlip","State","env","prog","stack","zp0","zp1","zp2","rp0","fv","dpv","glyph","ppem","Error","prepState","fpgmState","tables","fpgm","funcs","exports","DEBUG","console","log","step","e","prep","oCvt","cvt","Array","length","scale","unitsPerEm","c","xScale","yScale","components","contours","gZone","state","instructions","i","cg","glyphs","get","glyphIndex","dx","dy","gz","cc","pi","gLen","push","apply","j","inhibitGridFit","z0","z1","z2","advanceWidth","points","pLen","cp","sp","np","ins","ip","toString","initTZone","tZone","skip","handleElse","nesting","SVTCA","SPVTCA","SFVTCA","SPVTL","a","p2i","pop","p1i","SFVTL","SPVFS","SFVFS","GPV","GFV","SFVTPV","ISECT","pa0i","pa1i","pb0i","pb1i","pa0","pa1","pb0","pb1","x1","y1","x2","y2","x3","y3","x4","y4","div","f1","f2","SRP0","SRP1","SRP2","SZP0","n","SZP1","SZP2","SZPS","SLOOP","RTG","RTHG","SMD","ELSE","JMPR","o","SCVTCI","DUP","POP","CLEAR","SWAP","b","DEPTH","LOOPCALL","fn","cip","cprog","CALL","CINDEX","k","MINDEX","splice","FDEF","ipBegin","slice","MDAP","IUP","pp","SHP","rpi","SHC","ci","SHZ","z","SHPIX","IP","rp1i","rp2i","MSIRP","ALIGNRP","rp0i","RTDG","MIAP","cv","NPUSHB","NPUSHW","w","WS","store","l","RS","WCVTP","RCVT","cvte","GC","MD","pi2","pi1","MPPEM","FLIPON","LT","e2","e1","LTEQ","GT","GTEQ","EQ","NEQ","ODD","EVEN","IF","test","EIF","AND","OR","NOT","DELTAP123","base","ds","arg","appem","mag","SDB","SDS","pow","ADD","n2","n1","SUB","DIV","MUL","ABS","NEG","FLOOR","CEILING","ROUND","WCVTF","DELTAC123","delta","SROUND","S45ROUND","ROFF","RUTG","RDTG","SCANCTRL","SDPVTL","GETINFO","sel","r","ROLL","MAX","max","MIN","min","SCANTYPE","INSTCTRL","s","ignoreCvt","PUSHB","PUSHW","MDRP_MIRP","indirect","setRp0","keepD","ro","md","od","bind"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/opentype.js/src/hintingtt.js"],"sourcesContent":["/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n'use strict';\n\nlet instructionTable;\nlet exec;\nlet execGlyph;\nlet execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nconst roundSuper = function (v) {\n    const period = this.srPeriod;\n    let phase = this.srPhase;\n    const threshold = this.srThreshold;\n    let sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (sign > 0 && v < 0) return phase;\n    if (sign < 0 && v > 0) return -phase;\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nconst xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        let do1;\n        let do2;\n        let doa1;\n        let doa2;\n        let dm1;\n        let dm2;\n        let dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        const rpx = org ? rp.xo : rp.x;\n        const rpy = org ? rp.yo : rp.y;\n        const rpdx = rpx + d * pv.x;\n        const rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nconst yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        let do1;\n        let do2;\n        let doa1;\n        let doa2;\n        let dm1;\n        let dm2;\n        let dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        const rpx = org ? rp.xo : rp.x;\n        const rpy = org ? rp.yo : rp.y;\n        const rpdx = rpx + d * pv.x;\n        const rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    let dm1;\n    let dm2;\n    let do1;\n    let do2;\n    let doa1;\n    let doa2;\n    let dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    const rpx = org ? rp.xo : rp.x;\n    const rpy = org ? rp.yo : rp.y;\n    const rpdx = rpx + d * pv.x;\n    const rpdy = rpy + d * pv.y;\n\n    const pvns = pv.normalSlope;\n    const fvs = this.slope;\n\n    const px = p.x;\n    const py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    const d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) return xUnitVector;\n    else if (x === 0 && y === 1) return yUnitVector;\n    else return new UnitVector(x, y);\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    let p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) p = p.nextPointOnContour;\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    let p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) p = p.prevPointOnContour;\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nconst HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nconst defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) return;\n\n    const font = this.font;\n    let prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        let fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        const oCvt = font.tables.cvt;\n        if (oCvt) {\n            const cvt = prepState.cvt = new Array(oCvt.length);\n            const scale = ppem / font.unitsPerEm;\n            for (let c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) return;\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    const xScale = prepState.ppem / prepState.font.unitsPerEm;\n    const yScale = xScale;\n    let components = glyph.components;\n    let contours;\n    let gZone;\n    let state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        const font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (let i = 0; i < components.length; i++) {\n            const c = components[i];\n            const cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            const dx = Math.round(c.dx * xScale);\n            const dy = Math.round(c.dy * yScale);\n            const gz = state.gZone;\n            const cc = state.contours;\n            for (let pi = 0; pi < gz.length; pi++) {\n                const p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            const gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (let j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself by a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    const points = glyph.points || [];\n    const pLen = points.length;\n    const gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    const contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    let cp; // current point\n    for (let i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    let sp; // start point\n    let np; // next point\n\n    for (let i = 0; i < pLen; i++) {\n        cp = gZone[i];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) return;\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (let i = 0; i < pLen; i++) {\n            console.log(i, gZone[i].x, gZone[i].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    let prog = state.prog;\n\n    if (!prog) return;\n\n    const pLen = prog.length;\n    let ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) state.step++;\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    const tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (let i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    const prog = state.prog;\n    let ip = state.ip;\n    let nesting = 1;\n    let ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            nesting++;\n        else if (ins === 0x59) // EIF\n            nesting--;\n        else if (ins === 0x40) // NPUSHB\n            ip += prog[ip + 1] + 1;\n        else if (ins === 0x41) // NPUSHW\n            ip += 2 * prog[ip + 1] + 1;\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            ip += ins - 0xB0 + 1;\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            ip += (ins - 0xB8 + 1) * 2;\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            break;\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) console.log(state.step, 'SVTCA[' + v.axis + ']');\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) console.log(state.step, 'SPVTCA[' + v.axis + ']');\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) console.log(state.step, 'SFVTCA[' + v.axis + ']');\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    const stack = state.stack;\n    const p2i = stack.pop();\n    const p1i = stack.pop();\n    const p2 = state.z2[p2i];\n    const p1 = state.z1[p1i];\n\n    if (exports.DEBUG) console.log('SPVTL[' + a + ']', p2i, p1i);\n\n    let dx;\n    let dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    const stack = state.stack;\n    const p2i = stack.pop();\n    const p1i = stack.pop();\n    const p2 = state.z2[p2i];\n    const p1 = state.z1[p1i];\n\n    if (exports.DEBUG) console.log('SFVTL[' + a + ']', p2i, p1i);\n\n    let dx;\n    let dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    const stack = state.stack;\n    const y = stack.pop();\n    const x = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    const stack = state.stack;\n    const y = stack.pop();\n    const x = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    const stack = state.stack;\n    const pv = state.pv;\n\n    if (exports.DEBUG) console.log(state.step, 'GPV[]');\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    const stack = state.stack;\n    const fv = state.fv;\n\n    if (exports.DEBUG) console.log(state.step, 'GFV[]');\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) console.log(state.step, 'SFVTPV[]');\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    const stack = state.stack;\n    const pa0i = stack.pop();\n    const pa1i = stack.pop();\n    const pb0i = stack.pop();\n    const pb1i = stack.pop();\n    const pi = stack.pop();\n    const z0 = state.z0;\n    const z1 = state.z1;\n    const pa0 = z0[pa0i];\n    const pa1 = z0[pa1i];\n    const pb0 = z1[pb0i];\n    const pb1 = z1[pb1i];\n    const p = state.z2[pi];\n\n    if (exports.DEBUG) console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi);\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    const x1 = pa0.x;\n    const y1 = pa0.y;\n    const x2 = pa1.x;\n    const y2 = pa1.y;\n    const x3 = pb0.x;\n    const y3 = pb0.y;\n    const x4 = pb1.x;\n    const y4 = pb1.y;\n\n    const div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    const f1 = x1 * y2 - y1 * x2;\n    const f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SRP0[]', state.rp0);\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SRP1[]', state.rp1);\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SRP2[]', state.rp2);\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZP0[]', n);\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZP1[]', n);\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZP2[]', n);\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZPS[]', n);\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SLOOP[]', state.loop);\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RTG[]');\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RTHG[]');\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    const d = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SMD[]', d);\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) console.log(state.step, 'ELSE[]');\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    const o = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'JMPR[]', o);\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SCVTCI[]', n);\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    const stack = state.stack;\n\n    if (exports.DEBUG) console.log(state.step, 'DUP[]');\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) console.log(state.step, 'POP[]');\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) console.log(state.step, 'CLEAR[]');\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    const stack = state.stack;\n\n    const a = stack.pop();\n    const b = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SWAP[]');\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    const stack = state.stack;\n\n    if (exports.DEBUG) console.log(state.step, 'DEPTH[]');\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    const stack = state.stack;\n    const fn = stack.pop();\n    const c = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'LOOPCALL[]', fn, c);\n\n    // saves callers program\n    const cip = state.ip;\n    const cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (let i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        );\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    const fn = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'CALL[]', fn);\n\n    // saves callers program\n    const cip = state.ip;\n    const cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) console.log(++state.step, 'returning from', fn);\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    const stack = state.stack;\n    const k = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'CINDEX[]', k);\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    const stack = state.stack;\n    const k = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MINDEX[]', k);\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') throw new Error('FDEF not allowed here');\n    const stack = state.stack;\n    const prog = state.prog;\n    let ip = state.ip;\n\n    const fn = stack.pop();\n    const ipBegin = ip;\n\n    if (exports.DEBUG) console.log(state.step, 'FDEF[]', fn);\n\n    while (prog[++ip] !== 0x2D);\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    const pi = state.stack.pop();\n    const p = state.z0[pi];\n    const fv = state.fv;\n    const pv = state.pv;\n\n    if (exports.DEBUG) console.log(state.step, 'MDAP[' + round + ']', pi);\n\n    let d = pv.distance(p, HPZero);\n\n    if (round) d = state.round(d);\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    const z2 = state.z2;\n    const pLen = z2.length - 2;\n    let cp;\n    let pp;\n    let np;\n\n    if (exports.DEBUG) console.log(state.step, 'IUP[' + v.axis + ']');\n\n    for (let i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) continue;\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) continue;\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    const stack = state.stack;\n    const rpi = a ? state.rp1 : state.rp2;\n    const rp = (a ? state.z0 : state.z1)[rpi];\n    const fv = state.fv;\n    const pv = state.pv;\n    let loop = state.loop;\n    const z2 = state.z2;\n\n    while (loop--)\n    {\n        const pi = stack.pop();\n        const p = z2[pi];\n\n        const d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    const stack = state.stack;\n    const rpi = a ? state.rp1 : state.rp2;\n    const rp = (a ? state.z0 : state.z1)[rpi];\n    const fv = state.fv;\n    const pv = state.pv;\n    const ci = stack.pop();\n    const sp = state.z2[state.contours[ci]];\n    let p = sp;\n\n    if (exports.DEBUG) console.log(state.step, 'SHC[' + a + ']', ci);\n\n    const d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) fv.setRelative(p, p, d, pv);\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    const stack = state.stack;\n    const rpi = a ? state.rp1 : state.rp2;\n    const rp = (a ? state.z0 : state.z1)[rpi];\n    const fv = state.fv;\n    const pv = state.pv;\n\n    const e = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SHZ[' + a + ']', e);\n\n    let z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    let p;\n    const d = pv.distance(rp, rp, false, true);\n    const pLen = z.length - 2;\n    for (let i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    const stack = state.stack;\n    let loop = state.loop;\n    const fv = state.fv;\n    const d = stack.pop() / 0x40;\n    const z2 = state.z2;\n\n    while (loop--) {\n        const pi = stack.pop();\n        const p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    const stack = state.stack;\n    const rp1i = state.rp1;\n    const rp2i = state.rp2;\n    let loop = state.loop;\n    const rp1 = state.z0[rp1i];\n    const rp2 = state.z1[rp2i];\n    const fv = state.fv;\n    const pv = state.dpv;\n    const z2 = state.z2;\n\n    while (loop--) {\n        const pi = stack.pop();\n        const p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    const stack = state.stack;\n    const d = stack.pop() / 64;\n    const pi = stack.pop();\n    const p = state.z1[pi];\n    const rp0 = state.z0[state.rp0];\n    const fv = state.fv;\n    const pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) console.log(state.step, 'MSIRP[' + a + ']', d, pi);\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) state.rp0 = pi;\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    const stack = state.stack;\n    const rp0i = state.rp0;\n    const rp0 = state.z0[rp0i];\n    let loop = state.loop;\n    const fv = state.fv;\n    const pv = state.pv;\n    const z1 = state.z1;\n\n    while (loop--) {\n        const pi = stack.pop();\n        const p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RTDG[]');\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n    const pi = stack.pop();\n    const p = state.z0[pi];\n    const fv = state.fv;\n    const pv = state.pv;\n    let cv = state.cvt[n];\n\n    // TODO cvtcutin should be considered here\n    if (round) cv = state.round(cv);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    fv.setRelative(p, HPZero, cv, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    const prog = state.prog;\n    let ip = state.ip;\n    const stack = state.stack;\n\n    const n = prog[++ip];\n\n    if (exports.DEBUG) console.log(state.step, 'NPUSHB[]', n);\n\n    for (let i = 0; i < n; i++) stack.push(prog[++ip]);\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    let ip = state.ip;\n    const prog = state.prog;\n    const stack = state.stack;\n    const n = prog[++ip];\n\n    if (exports.DEBUG) console.log(state.step, 'NPUSHW[]', n);\n\n    for (let i = 0; i < n; i++) {\n        let w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    const stack = state.stack;\n    let store = state.store;\n\n    if (!store) store = state.store = [];\n\n    const v = stack.pop();\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'WS', v, l);\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    const stack = state.stack;\n    const store = state.store;\n\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'RS', l);\n\n    const v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    const stack = state.stack;\n\n    const v = stack.pop();\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'WCVTP', v, l);\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    const stack = state.stack;\n    const cvte = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'RCVT', cvte);\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    const stack = state.stack;\n    const pi = stack.pop();\n    const p = state.z2[pi];\n\n    if (exports.DEBUG) console.log(state.step, 'GC[' + a + ']', pi);\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    const stack = state.stack;\n    const pi2 = stack.pop();\n    const pi1 = stack.pop();\n    const p2 = state.z1[pi2];\n    const p1 = state.z0[pi1];\n    const d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d);\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) console.log(state.step, 'MPPEM[]');\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) console.log(state.step, 'FLIPON[]');\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'LT[]', e2, e1);\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'LTEQ[]', e2, e1);\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'GT[]', e2, e1);\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'GTEQ[]', e2, e1);\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'EQ[]', e2, e1);\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'NEQ[]', e2, e1);\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ODD[]', n);\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'EVEN[]', n);\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    let test = state.stack.pop();\n    let ins;\n\n    if (exports.DEBUG) console.log(state.step, 'IF[]', test);\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]');\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) console.log(state.step, 'EIF[]');\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'AND[]', e2, e1);\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'OR[]', e2, e1);\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    const stack = state.stack;\n    const e = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'NOT[]', e);\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n    const fv = state.fv;\n    const pv = state.pv;\n    const ppem = state.ppem;\n    const base = state.deltaBase + (b - 1) * 16;\n    const ds = state.deltaShift;\n    const z0 = state.z0;\n\n    if (exports.DEBUG) console.log(state.step, 'DELTAP[' + b + ']', n, stack);\n\n    for (let i = 0; i < n; i++)\n    {\n        const pi = stack.pop();\n        const arg = stack.pop();\n        const appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) continue;\n\n        let mag = (arg & 0x0F) - 8;\n        if (mag >= 0) mag++;\n        if (exports.DEBUG) console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds);\n\n        const p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SDB[]', n);\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SDS[]', n);\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ADD[]', n2, n1);\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SUB[]', n2, n1);\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'DIV[]', n2, n1);\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MUL[]', n2, n1);\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ABS[]', n);\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    const stack = state.stack;\n    let n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'NEG[]', n);\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'FLOOR[]', n);\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'CEILING[]', n);\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ROUND[]');\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    const stack = state.stack;\n    const v = stack.pop();\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'WCVTF[]', v, l);\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n    const ppem = state.ppem;\n    const base = state.deltaBase + (b - 1) * 16;\n    const ds = state.deltaShift;\n\n    if (exports.DEBUG) console.log(state.step, 'DELTAC[' + b + ']', n, stack);\n\n    for (let i = 0; i < n; i++) {\n        const c = stack.pop();\n        const arg = stack.pop();\n        const appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) continue;\n\n        let mag = (arg & 0x0F) - 8;\n        if (mag >= 0) mag++;\n\n        const delta = mag * ds;\n\n        if (exports.DEBUG) console.log(state.step, 'DELTACFIX', c, 'by', delta);\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    let n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SROUND[]', n);\n\n    state.round = roundSuper;\n\n    let period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) state.srThreshold = 0;\n    else state.srThreshold = (n / 8 - 0.5) * period;\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    let n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'S45ROUND[]', n);\n\n    state.round = roundSuper;\n\n    let period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) state.srThreshold = 0;\n    else state.srThreshold = (n / 8 - 0.5) * period;\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) console.log(state.step, 'ROFF[]');\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RUTG[]');\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RDTG[]');\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    const n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) console.log(state.step, 'SCANCTRL[]', n);\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    const stack = state.stack;\n    const p2i = stack.pop();\n    const p1i = stack.pop();\n    const p2 = state.z2[p2i];\n    const p1 = state.z1[p1i];\n\n    if (exports.DEBUG) console.log('SDPVTL[' + a + ']', p2i, p1i);\n\n    let dx;\n    let dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    const stack = state.stack;\n    const sel = stack.pop();\n    let r = 0;\n\n    if (exports.DEBUG) console.log(state.step, 'GETINFO[]', sel);\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) r = 35;\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) r |= 0x1000;\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    const stack = state.stack;\n    const a = stack.pop();\n    const b = stack.pop();\n    const c = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ROLL[]');\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MAX[]', e2, e1);\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MIN[]', e2, e1);\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    const n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) console.log(state.step, 'SCANTYPE[]', n);\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    const s = state.stack.pop();\n    let v = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'INSTCTRL[]', s, v);\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    const stack = state.stack;\n    const prog = state.prog;\n    let ip = state.ip;\n\n    if (exports.DEBUG) console.log(state.step, 'PUSHB[' + n + ']');\n\n    for (let i = 0; i < n; i++) stack.push(prog[++ip]);\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    let ip = state.ip;\n    const prog = state.prog;\n    const stack = state.stack;\n\n    if (exports.DEBUG) console.log(state.ip, 'PUSHW[' + n + ']');\n\n    for (let i = 0; i < n; i++) {\n        let w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    const stack = state.stack;\n    const cvte = indirect && stack.pop();\n    const pi = stack.pop();\n    const rp0i = state.rp0;\n    const rp = state.z0[rp0i];\n    const p = state.z1[pi];\n\n    const md = state.minDis;\n    const fv = state.fv;\n    const pv = state.dpv;\n    let od; // original distance\n    let d; // moving distance\n    let sign; // sign of distance\n    let cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) d = cv;\n    }\n\n    if (keepD && d < md) d = md;\n\n    if (ro) d = state.round(d);\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) state.rp0 = pi;\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\nexport default Hinting;\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n"],"mappings":"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,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACnD,UAAWqU,SAAS,CAACO,IAAI,CAAC5U,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CACtD;AAED,eAAeJ,OAAO;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}