{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// The Layout object is the prototype of Substitution objects, and provides\n// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)\n\nimport check from './check';\nfunction searchTag(arr, tag) {\n  /* jshint bitwise: false */\n  let imin = 0;\n  let imax = arr.length - 1;\n  while (imin <= imax) {\n    const imid = imin + imax >>> 1;\n    const val = arr[imid].tag;\n    if (val === tag) {\n      return imid;\n    } else if (val < tag) {\n      imin = imid + 1;\n    } else {\n      imax = imid - 1;\n    }\n  }\n  // Not found: return -1-insertion point\n  return -imin - 1;\n}\nfunction binSearch(arr, value) {\n  /* jshint bitwise: false */\n  let imin = 0;\n  let imax = arr.length - 1;\n  while (imin <= imax) {\n    const imid = imin + imax >>> 1;\n    const val = arr[imid];\n    if (val === value) {\n      return imid;\n    } else if (val < value) {\n      imin = imid + 1;\n    } else {\n      imax = imid - 1;\n    }\n  }\n  // Not found: return -1-insertion point\n  return -imin - 1;\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n  this.font = font;\n  this.tableName = tableName;\n}\nLayout.prototype = {\n  /**\n   * Binary search an object by \"tag\" property\n   * @instance\n   * @function searchTag\n   * @memberof opentype.Layout\n   * @param  {Array} arr\n   * @param  {string} tag\n   * @return {number}\n   */\n  searchTag: searchTag,\n  /**\n   * Binary search in a list of numbers\n   * @instance\n   * @function binSearch\n   * @memberof opentype.Layout\n   * @param  {Array} arr\n   * @param  {number} value\n   * @return {number}\n   */\n  binSearch: binSearch,\n  /**\n   * Get or create the Layout table (GSUB, GPOS etc).\n   * @param  {boolean} create - Whether to create a new one.\n   * @return {Object} The GSUB or GPOS table.\n   */\n  getTable: function (create) {\n    let layout = this.font.tables[this.tableName];\n    if (!layout && create) {\n      layout = this.font.tables[this.tableName] = this.createDefaultTable();\n    }\n    return layout;\n  },\n  /**\n   * Returns all scripts in the substitution table.\n   * @instance\n   * @return {Array}\n   */\n  getScriptNames: function () {\n    let layout = this.getTable();\n    if (!layout) {\n      return [];\n    }\n    return layout.scripts.map(function (script) {\n      return script.tag;\n    });\n  },\n  /**\n   * Returns the best bet for a script name.\n   * Returns 'DFLT' if it exists.\n   * If not, returns 'latn' if it exists.\n   * If neither exist, returns undefined.\n   */\n  getDefaultScriptName: function () {\n    let layout = this.getTable();\n    if (!layout) {\n      return;\n    }\n    let hasLatn = false;\n    for (let i = 0; i < layout.scripts.length; i++) {\n      const name = layout.scripts[i].tag;\n      if (name === 'DFLT') return name;\n      if (name === 'latn') hasLatn = true;\n    }\n    if (hasLatn) return 'latn';\n  },\n  /**\n   * Returns all LangSysRecords in the given script.\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n   * @return {Object} An object with tag and script properties.\n   */\n  getScriptTable: function (script, create) {\n    const layout = this.getTable(create);\n    if (layout) {\n      script = script || 'DFLT';\n      const scripts = layout.scripts;\n      const pos = searchTag(layout.scripts, script);\n      if (pos >= 0) {\n        return scripts[pos].script;\n      } else if (create) {\n        const scr = {\n          tag: script,\n          script: {\n            defaultLangSys: {\n              reserved: 0,\n              reqFeatureIndex: 0xffff,\n              featureIndexes: []\n            },\n            langSysRecords: []\n          }\n        };\n        scripts.splice(-1 - pos, 0, scr);\n        return scr.script;\n      }\n    }\n  },\n  /**\n   * Returns a language system table\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dlft']\n   * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n   * @return {Object}\n   */\n  getLangSysTable: function (script, language, create) {\n    const scriptTable = this.getScriptTable(script, create);\n    if (scriptTable) {\n      if (!language || language === 'dflt' || language === 'DFLT') {\n        return scriptTable.defaultLangSys;\n      }\n      const pos = searchTag(scriptTable.langSysRecords, language);\n      if (pos >= 0) {\n        return scriptTable.langSysRecords[pos].langSys;\n      } else if (create) {\n        const langSysRecord = {\n          tag: language,\n          langSys: {\n            reserved: 0,\n            reqFeatureIndex: 0xffff,\n            featureIndexes: []\n          }\n        };\n        scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n        return langSysRecord.langSys;\n      }\n    }\n  },\n  /**\n   * Get a specific feature table.\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dlft']\n   * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n   * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n   * @return {Object}\n   */\n  getFeatureTable: function (script, language, feature, create) {\n    const langSysTable = this.getLangSysTable(script, language, create);\n    if (langSysTable) {\n      let featureRecord;\n      const featIndexes = langSysTable.featureIndexes;\n      const allFeatures = this.font.tables[this.tableName].features;\n      // The FeatureIndex array of indices is in arbitrary order,\n      // even if allFeatures is sorted alphabetically by feature tag.\n      for (let i = 0; i < featIndexes.length; i++) {\n        featureRecord = allFeatures[featIndexes[i]];\n        if (featureRecord.tag === feature) {\n          return featureRecord.feature;\n        }\n      }\n      if (create) {\n        const index = allFeatures.length;\n        // Automatic ordering of features would require to shift feature indexes in the script list.\n        check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n        featureRecord = {\n          tag: feature,\n          feature: {\n            params: 0,\n            lookupListIndexes: []\n          }\n        };\n        allFeatures.push(featureRecord);\n        featIndexes.push(index);\n        return featureRecord.feature;\n      }\n    }\n  },\n  /**\n   * Get the lookup tables of a given type for a script/language/feature.\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dlft']\n   * @param {string} feature - 4-letter feature code\n   * @param {number} lookupType - 1 to 8\n   * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n   * @return {Object[]}\n   */\n  getLookupTables: function (script, language, feature, lookupType, create) {\n    const featureTable = this.getFeatureTable(script, language, feature, create);\n    const tables = [];\n    if (featureTable) {\n      let lookupTable;\n      const lookupListIndexes = featureTable.lookupListIndexes;\n      const allLookups = this.font.tables[this.tableName].lookups;\n      // lookupListIndexes are in no particular order, so use naive search.\n      for (let i = 0; i < lookupListIndexes.length; i++) {\n        lookupTable = allLookups[lookupListIndexes[i]];\n        if (lookupTable.lookupType === lookupType) {\n          tables.push(lookupTable);\n        }\n      }\n      if (tables.length === 0 && create) {\n        lookupTable = {\n          lookupType: lookupType,\n          lookupFlag: 0,\n          subtables: [],\n          markFilteringSet: undefined\n        };\n        const index = allLookups.length;\n        allLookups.push(lookupTable);\n        lookupListIndexes.push(index);\n        return [lookupTable];\n      }\n    }\n    return tables;\n  },\n  /**\n   * Returns the list of glyph indexes of a coverage table.\n   * Format 1: the list is stored raw\n   * Format 2: compact list as range records.\n   * @instance\n   * @param  {Object} coverageTable\n   * @return {Array}\n   */\n  expandCoverage: function (coverageTable) {\n    if (coverageTable.format === 1) {\n      return coverageTable.glyphs;\n    } else {\n      const glyphs = [];\n      const ranges = coverageTable.ranges;\n      for (let i = 0; i < ranges.length; i++) {\n        const range = ranges[i];\n        const start = range.start;\n        const end = range.end;\n        for (let j = start; j <= end; j++) {\n          glyphs.push(j);\n        }\n      }\n      return glyphs;\n    }\n  }\n};\nexport default Layout;","map":{"version":3,"names":["check","searchTag","arr","tag","imin","imax","length","imid","val","binSearch","value","Layout","font","tableName","prototype","getTable","create","layout","tables","createDefaultTable","getScriptNames","scripts","map","script","getDefaultScriptName","hasLatn","i","name","getScriptTable","pos","scr","defaultLangSys","reserved","reqFeatureIndex","featureIndexes","langSysRecords","splice","getLangSysTable","language","scriptTable","langSys","langSysRecord","getFeatureTable","feature","langSysTable","featureRecord","featIndexes","allFeatures","features","index","assert","params","lookupListIndexes","push","getLookupTables","lookupType","featureTable","lookupTable","allLookups","lookups","lookupFlag","subtables","markFilteringSet","undefined","expandCoverage","coverageTable","format","glyphs","ranges","range","start","end","j"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/opentype.js/src/layout.js"],"sourcesContent":["// The Layout object is the prototype of Substitution objects, and provides\n// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)\n\nimport check from './check';\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    let imin = 0;\n    let imax = arr.length - 1;\n    while (imin <= imax) {\n        const imid = (imin + imax) >>> 1;\n        const val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    let imin = 0;\n    let imax = arr.length - 1;\n    while (imin <= imax) {\n        const imid = (imin + imax) >>> 1;\n        const val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function(create) {\n        let layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function() {\n        let layout = this.getTable();\n        if (!layout) { return []; }\n        return layout.scripts.map(function(script) {\n            return script.tag;\n        });\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function() {\n        let layout = this.getTable();\n        if (!layout) { return; }\n        let hasLatn = false;\n        for (let i = 0; i < layout.scripts.length; i++) {\n            const name = layout.scripts[i].tag;\n            if (name === 'DFLT') return name;\n            if (name === 'latn') hasLatn = true;\n        }\n        if (hasLatn) return 'latn';\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function(script, create) {\n        const layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            const scripts = layout.scripts;\n            const pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                const scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function(script, language, create) {\n        const scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            const pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                const langSysRecord = {\n                    tag: language,\n                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function(script, language, feature, create) {\n        const langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            let featureRecord;\n            const featIndexes = langSysTable.featureIndexes;\n            const allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (let i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                const index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 8\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function(script, language, feature, lookupType, create) {\n        const featureTable = this.getFeatureTable(script, language, feature, create);\n        const tables = [];\n        if (featureTable) {\n            let lookupTable;\n            const lookupListIndexes = featureTable.lookupListIndexes;\n            const allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (let i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                const index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            const glyphs = [];\n            const ranges = coverageTable.ranges;\n            for (let i = 0; i < ranges.length; i++) {\n                const range = ranges[i];\n                const start = range.start;\n                const end = range.end;\n                for (let j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n\n};\n\nexport default Layout;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}