{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// The `cmap` table stores the mappings from characters to glyphs.\n// https://www.microsoft.com/typography/OTSPEC/cmap.htm\n\nimport check from '../check';\nimport parse from '../parse';\nimport table from '../table';\nfunction parseCmapTableFormat12(cmap, p) {\n  //Skip reserved.\n  p.parseUShort();\n\n  // Length in bytes of the sub-tables.\n  cmap.length = p.parseULong();\n  cmap.language = p.parseULong();\n  let groupCount;\n  cmap.groupCount = groupCount = p.parseULong();\n  cmap.glyphIndexMap = {};\n  for (let i = 0; i < groupCount; i += 1) {\n    const startCharCode = p.parseULong();\n    const endCharCode = p.parseULong();\n    let startGlyphId = p.parseULong();\n    for (let c = startCharCode; c <= endCharCode; c += 1) {\n      cmap.glyphIndexMap[c] = startGlyphId;\n      startGlyphId++;\n    }\n  }\n}\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n  // Length in bytes of the sub-tables.\n  cmap.length = p.parseUShort();\n  cmap.language = p.parseUShort();\n\n  // segCount is stored x 2.\n  let segCount;\n  cmap.segCount = segCount = p.parseUShort() >> 1;\n\n  // Skip searchRange, entrySelector, rangeShift.\n  p.skip('uShort', 3);\n\n  // The \"unrolled\" mapping from character codes to glyph indices.\n  cmap.glyphIndexMap = {};\n  const endCountParser = new parse.Parser(data, start + offset + 14);\n  const startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n  const idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n  const idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n  let glyphIndexOffset = start + offset + 16 + segCount * 8;\n  for (let i = 0; i < segCount - 1; i += 1) {\n    let glyphIndex;\n    const endCount = endCountParser.parseUShort();\n    const startCount = startCountParser.parseUShort();\n    const idDelta = idDeltaParser.parseShort();\n    const idRangeOffset = idRangeOffsetParser.parseUShort();\n    for (let c = startCount; c <= endCount; c += 1) {\n      if (idRangeOffset !== 0) {\n        // The idRangeOffset is relative to the current position in the idRangeOffset array.\n        // Take the current offset in the idRangeOffset array.\n        glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;\n\n        // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n        glyphIndexOffset += idRangeOffset;\n\n        // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n        glyphIndexOffset += (c - startCount) * 2;\n        glyphIndex = parse.getUShort(data, glyphIndexOffset);\n        if (glyphIndex !== 0) {\n          glyphIndex = glyphIndex + idDelta & 0xFFFF;\n        }\n      } else {\n        glyphIndex = c + idDelta & 0xFFFF;\n      }\n      cmap.glyphIndexMap[c] = glyphIndex;\n    }\n  }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n  const cmap = {};\n  cmap.version = parse.getUShort(data, start);\n  check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n  // The cmap table can contain many sub-tables, each with their own format.\n  // We're only interested in a \"platform 3\" table. This is a Windows format.\n  cmap.numTables = parse.getUShort(data, start + 2);\n  let offset = -1;\n  for (let i = cmap.numTables - 1; i >= 0; i -= 1) {\n    const platformId = parse.getUShort(data, start + 4 + i * 8);\n    const encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n    if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {\n      offset = parse.getULong(data, start + 4 + i * 8 + 4);\n      break;\n    }\n  }\n  if (offset === -1) {\n    // There is no cmap table in the font that we support.\n    throw new Error('No valid cmap sub-tables found.');\n  }\n  const p = new parse.Parser(data, start + offset);\n  cmap.format = p.parseUShort();\n  if (cmap.format === 12) {\n    parseCmapTableFormat12(cmap, p);\n  } else if (cmap.format === 4) {\n    parseCmapTableFormat4(cmap, p, data, start, offset);\n  } else {\n    throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n  }\n  return cmap;\n}\nfunction addSegment(t, code, glyphIndex) {\n  t.segments.push({\n    end: code,\n    start: code,\n    delta: -(code - glyphIndex),\n    offset: 0\n  });\n}\nfunction addTerminatorSegment(t) {\n  t.segments.push({\n    end: 0xFFFF,\n    start: 0xFFFF,\n    delta: 1,\n    offset: 0\n  });\n}\nfunction makeCmapTable(glyphs) {\n  const t = new table.Table('cmap', [{\n    name: 'version',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'numTables',\n    type: 'USHORT',\n    value: 1\n  }, {\n    name: 'platformID',\n    type: 'USHORT',\n    value: 3\n  }, {\n    name: 'encodingID',\n    type: 'USHORT',\n    value: 1\n  }, {\n    name: 'offset',\n    type: 'ULONG',\n    value: 12\n  }, {\n    name: 'format',\n    type: 'USHORT',\n    value: 4\n  }, {\n    name: 'length',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'language',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'segCountX2',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'searchRange',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'entrySelector',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'rangeShift',\n    type: 'USHORT',\n    value: 0\n  }]);\n  t.segments = [];\n  for (let i = 0; i < glyphs.length; i += 1) {\n    const glyph = glyphs.get(i);\n    for (let j = 0; j < glyph.unicodes.length; j += 1) {\n      addSegment(t, glyph.unicodes[j], i);\n    }\n    t.segments = t.segments.sort(function (a, b) {\n      return a.start - b.start;\n    });\n  }\n  addTerminatorSegment(t);\n  let segCount;\n  segCount = t.segments.length;\n  t.segCountX2 = segCount * 2;\n  t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;\n  t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n  t.rangeShift = t.segCountX2 - t.searchRange;\n\n  // Set up parallel segment arrays.\n  let endCounts = [];\n  let startCounts = [];\n  let idDeltas = [];\n  let idRangeOffsets = [];\n  let glyphIds = [];\n  for (let i = 0; i < segCount; i += 1) {\n    const segment = t.segments[i];\n    endCounts = endCounts.concat({\n      name: 'end_' + i,\n      type: 'USHORT',\n      value: segment.end\n    });\n    startCounts = startCounts.concat({\n      name: 'start_' + i,\n      type: 'USHORT',\n      value: segment.start\n    });\n    idDeltas = idDeltas.concat({\n      name: 'idDelta_' + i,\n      type: 'SHORT',\n      value: segment.delta\n    });\n    idRangeOffsets = idRangeOffsets.concat({\n      name: 'idRangeOffset_' + i,\n      type: 'USHORT',\n      value: segment.offset\n    });\n    if (segment.glyphId !== undefined) {\n      glyphIds = glyphIds.concat({\n        name: 'glyph_' + i,\n        type: 'USHORT',\n        value: segment.glyphId\n      });\n    }\n  }\n  t.fields = t.fields.concat(endCounts);\n  t.fields.push({\n    name: 'reservedPad',\n    type: 'USHORT',\n    value: 0\n  });\n  t.fields = t.fields.concat(startCounts);\n  t.fields = t.fields.concat(idDeltas);\n  t.fields = t.fields.concat(idRangeOffsets);\n  t.fields = t.fields.concat(glyphIds);\n  t.length = 14 +\n  // Subtable header\n  endCounts.length * 2 + 2 +\n  // reservedPad\n  startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;\n  return t;\n}\nexport default {\n  parse: parseCmapTable,\n  make: makeCmapTable\n};","map":{"version":3,"names":["check","parse","table","parseCmapTableFormat12","cmap","p","parseUShort","length","parseULong","language","groupCount","glyphIndexMap","i","startCharCode","endCharCode","startGlyphId","c","parseCmapTableFormat4","data","start","offset","segCount","skip","endCountParser","Parser","startCountParser","idDeltaParser","idRangeOffsetParser","glyphIndexOffset","glyphIndex","endCount","startCount","idDelta","parseShort","idRangeOffset","relativeOffset","getUShort","parseCmapTable","version","argument","numTables","platformId","encodingId","getULong","Error","format","addSegment","t","code","segments","push","end","delta","addTerminatorSegment","makeCmapTable","glyphs","Table","name","type","value","glyph","get","j","unicodes","sort","a","b","segCountX2","searchRange","Math","pow","floor","log","entrySelector","rangeShift","endCounts","startCounts","idDeltas","idRangeOffsets","glyphIds","segment","concat","glyphId","undefined","fields","make"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/_opentype.js@0.7.3@opentype.js/src/tables/cmap.js"],"sourcesContent":["// The `cmap` table stores the mappings from characters to glyphs.\n// https://www.microsoft.com/typography/OTSPEC/cmap.htm\n\nimport check from '../check';\nimport parse from '../parse';\nimport table from '../table';\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    let groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (let i = 0; i < groupCount; i += 1) {\n        const startCharCode = p.parseULong();\n        const endCharCode = p.parseULong();\n        let startGlyphId = p.parseULong();\n\n        for (let c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    let segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    const endCountParser = new parse.Parser(data, start + offset + 14);\n    const startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    const idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    const idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    let glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (let i = 0; i < segCount - 1; i += 1) {\n        let glyphIndex;\n        const endCount = endCountParser.parseUShort();\n        const startCount = startCountParser.parseUShort();\n        const idDelta = idDeltaParser.parseShort();\n        const idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (let c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    const cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 3\" table. This is a Windows format.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    let offset = -1;\n    for (let i = cmap.numTables - 1; i >= 0; i -= 1) {\n        const platformId = parse.getUShort(data, start + 4 + (i * 8));\n        const encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {\n            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    const p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\nfunction makeCmapTable(glyphs) {\n    const t = new table.Table('cmap', [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: 1},\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: 12},\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    t.segments = [];\n    for (let i = 0; i < glyphs.length; i += 1) {\n        const glyph = glyphs.get(i);\n        for (let j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function(a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    let segCount;\n    segCount = t.segments.length;\n    t.segCountX2 = segCount * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    // Set up parallel segment arrays.\n    let endCounts = [];\n    let startCounts = [];\n    let idDeltas = [];\n    let idRangeOffsets = [];\n    let glyphIds = [];\n\n    for (let i = 0; i < segCount; i += 1) {\n        const segment = t.segments[i];\n        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n        if (segment.glyphId !== undefined) {\n            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n        }\n    }\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    return t;\n}\n\nexport default { parse: parseCmapTable, make: makeCmapTable };\n"],"mappings":";AAAA;AACA;;AAEA,OAAOA,KAAK,MAAM,UAAU;AAC5B,OAAOC,KAAK,MAAM,UAAU;AAC5B,OAAOC,KAAK,MAAM,UAAU;AAE5B,SAASC,sBAAsB,CAACC,IAAI,EAAEC,CAAC,EAAE;EACrC;EACAA,CAAC,CAACC,WAAW,EAAE;;EAEf;EACAF,IAAI,CAACG,MAAM,GAAGF,CAAC,CAACG,UAAU,EAAE;EAC5BJ,IAAI,CAACK,QAAQ,GAAGJ,CAAC,CAACG,UAAU,EAAE;EAE9B,IAAIE,UAAU;EACdN,IAAI,CAACM,UAAU,GAAGA,UAAU,GAAGL,CAAC,CAACG,UAAU,EAAE;EAC7CJ,IAAI,CAACO,aAAa,GAAG,CAAC,CAAC;EAEvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,EAAEE,CAAC,IAAI,CAAC,EAAE;IACpC,MAAMC,aAAa,GAAGR,CAAC,CAACG,UAAU,EAAE;IACpC,MAAMM,WAAW,GAAGT,CAAC,CAACG,UAAU,EAAE;IAClC,IAAIO,YAAY,GAAGV,CAAC,CAACG,UAAU,EAAE;IAEjC,KAAK,IAAIQ,CAAC,GAAGH,aAAa,EAAEG,CAAC,IAAIF,WAAW,EAAEE,CAAC,IAAI,CAAC,EAAE;MAClDZ,IAAI,CAACO,aAAa,CAACK,CAAC,CAAC,GAAGD,YAAY;MACpCA,YAAY,EAAE;IAClB;EACJ;AACJ;AAEA,SAASE,qBAAqB,CAACb,IAAI,EAAEC,CAAC,EAAEa,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAE;EACzD;EACAhB,IAAI,CAACG,MAAM,GAAGF,CAAC,CAACC,WAAW,EAAE;EAC7BF,IAAI,CAACK,QAAQ,GAAGJ,CAAC,CAACC,WAAW,EAAE;;EAE/B;EACA,IAAIe,QAAQ;EACZjB,IAAI,CAACiB,QAAQ,GAAGA,QAAQ,GAAGhB,CAAC,CAACC,WAAW,EAAE,IAAI,CAAC;;EAE/C;EACAD,CAAC,CAACiB,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;;EAEnB;EACAlB,IAAI,CAACO,aAAa,GAAG,CAAC,CAAC;EACvB,MAAMY,cAAc,GAAG,IAAItB,KAAK,CAACuB,MAAM,CAACN,IAAI,EAAEC,KAAK,GAAGC,MAAM,GAAG,EAAE,CAAC;EAClE,MAAMK,gBAAgB,GAAG,IAAIxB,KAAK,CAACuB,MAAM,CAACN,IAAI,EAAEC,KAAK,GAAGC,MAAM,GAAG,EAAE,GAAGC,QAAQ,GAAG,CAAC,CAAC;EACnF,MAAMK,aAAa,GAAG,IAAIzB,KAAK,CAACuB,MAAM,CAACN,IAAI,EAAEC,KAAK,GAAGC,MAAM,GAAG,EAAE,GAAGC,QAAQ,GAAG,CAAC,CAAC;EAChF,MAAMM,mBAAmB,GAAG,IAAI1B,KAAK,CAACuB,MAAM,CAACN,IAAI,EAAEC,KAAK,GAAGC,MAAM,GAAG,EAAE,GAAGC,QAAQ,GAAG,CAAC,CAAC;EACtF,IAAIO,gBAAgB,GAAGT,KAAK,GAAGC,MAAM,GAAG,EAAE,GAAGC,QAAQ,GAAG,CAAC;EACzD,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,QAAQ,GAAG,CAAC,EAAET,CAAC,IAAI,CAAC,EAAE;IACtC,IAAIiB,UAAU;IACd,MAAMC,QAAQ,GAAGP,cAAc,CAACjB,WAAW,EAAE;IAC7C,MAAMyB,UAAU,GAAGN,gBAAgB,CAACnB,WAAW,EAAE;IACjD,MAAM0B,OAAO,GAAGN,aAAa,CAACO,UAAU,EAAE;IAC1C,MAAMC,aAAa,GAAGP,mBAAmB,CAACrB,WAAW,EAAE;IACvD,KAAK,IAAIU,CAAC,GAAGe,UAAU,EAAEf,CAAC,IAAIc,QAAQ,EAAEd,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAIkB,aAAa,KAAK,CAAC,EAAE;QACrB;QACA;QACAN,gBAAgB,GAAID,mBAAmB,CAACP,MAAM,GAAGO,mBAAmB,CAACQ,cAAc,GAAG,CAAE;;QAExF;QACAP,gBAAgB,IAAIM,aAAa;;QAEjC;QACAN,gBAAgB,IAAI,CAACZ,CAAC,GAAGe,UAAU,IAAI,CAAC;QACxCF,UAAU,GAAG5B,KAAK,CAACmC,SAAS,CAAClB,IAAI,EAAEU,gBAAgB,CAAC;QACpD,IAAIC,UAAU,KAAK,CAAC,EAAE;UAClBA,UAAU,GAAIA,UAAU,GAAGG,OAAO,GAAI,MAAM;QAChD;MACJ,CAAC,MAAM;QACHH,UAAU,GAAIb,CAAC,GAAGgB,OAAO,GAAI,MAAM;MACvC;MAEA5B,IAAI,CAACO,aAAa,CAACK,CAAC,CAAC,GAAGa,UAAU;IACtC;EACJ;AACJ;;AAEA;AACA;AACA;AACA,SAASQ,cAAc,CAACnB,IAAI,EAAEC,KAAK,EAAE;EACjC,MAAMf,IAAI,GAAG,CAAC,CAAC;EACfA,IAAI,CAACkC,OAAO,GAAGrC,KAAK,CAACmC,SAAS,CAAClB,IAAI,EAAEC,KAAK,CAAC;EAC3CnB,KAAK,CAACuC,QAAQ,CAACnC,IAAI,CAACkC,OAAO,KAAK,CAAC,EAAE,iCAAiC,CAAC;;EAErE;EACA;EACAlC,IAAI,CAACoC,SAAS,GAAGvC,KAAK,CAACmC,SAAS,CAAClB,IAAI,EAAEC,KAAK,GAAG,CAAC,CAAC;EACjD,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,KAAK,IAAIR,CAAC,GAAGR,IAAI,CAACoC,SAAS,GAAG,CAAC,EAAE5B,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC7C,MAAM6B,UAAU,GAAGxC,KAAK,CAACmC,SAAS,CAAClB,IAAI,EAAEC,KAAK,GAAG,CAAC,GAAIP,CAAC,GAAG,CAAE,CAAC;IAC7D,MAAM8B,UAAU,GAAGzC,KAAK,CAACmC,SAAS,CAAClB,IAAI,EAAEC,KAAK,GAAG,CAAC,GAAIP,CAAC,GAAG,CAAE,GAAG,CAAC,CAAC;IACjE,IAAI6B,UAAU,KAAK,CAAC,KAAKC,UAAU,KAAK,CAAC,IAAIA,UAAU,KAAK,CAAC,IAAIA,UAAU,KAAK,EAAE,CAAC,EAAE;MACjFtB,MAAM,GAAGnB,KAAK,CAAC0C,QAAQ,CAACzB,IAAI,EAAEC,KAAK,GAAG,CAAC,GAAIP,CAAC,GAAG,CAAE,GAAG,CAAC,CAAC;MACtD;IACJ;EACJ;EAEA,IAAIQ,MAAM,KAAK,CAAC,CAAC,EAAE;IACf;IACA,MAAM,IAAIwB,KAAK,CAAC,iCAAiC,CAAC;EACtD;EAEA,MAAMvC,CAAC,GAAG,IAAIJ,KAAK,CAACuB,MAAM,CAACN,IAAI,EAAEC,KAAK,GAAGC,MAAM,CAAC;EAChDhB,IAAI,CAACyC,MAAM,GAAGxC,CAAC,CAACC,WAAW,EAAE;EAE7B,IAAIF,IAAI,CAACyC,MAAM,KAAK,EAAE,EAAE;IACpB1C,sBAAsB,CAACC,IAAI,EAAEC,CAAC,CAAC;EACnC,CAAC,MAAM,IAAID,IAAI,CAACyC,MAAM,KAAK,CAAC,EAAE;IAC1B5B,qBAAqB,CAACb,IAAI,EAAEC,CAAC,EAAEa,IAAI,EAAEC,KAAK,EAAEC,MAAM,CAAC;EACvD,CAAC,MAAM;IACH,MAAM,IAAIwB,KAAK,CAAC,+DAA+D,GAAGxC,IAAI,CAACyC,MAAM,GAAG,IAAI,CAAC;EACzG;EAEA,OAAOzC,IAAI;AACf;AAEA,SAAS0C,UAAU,CAACC,CAAC,EAAEC,IAAI,EAAEnB,UAAU,EAAE;EACrCkB,CAAC,CAACE,QAAQ,CAACC,IAAI,CAAC;IACZC,GAAG,EAAEH,IAAI;IACT7B,KAAK,EAAE6B,IAAI;IACXI,KAAK,EAAE,EAAEJ,IAAI,GAAGnB,UAAU,CAAC;IAC3BT,MAAM,EAAE;EACZ,CAAC,CAAC;AACN;AAEA,SAASiC,oBAAoB,CAACN,CAAC,EAAE;EAC7BA,CAAC,CAACE,QAAQ,CAACC,IAAI,CAAC;IACZC,GAAG,EAAE,MAAM;IACXhC,KAAK,EAAE,MAAM;IACbiC,KAAK,EAAE,CAAC;IACRhC,MAAM,EAAE;EACZ,CAAC,CAAC;AACN;AAEA,SAASkC,aAAa,CAACC,MAAM,EAAE;EAC3B,MAAMR,CAAC,GAAG,IAAI7C,KAAK,CAACsD,KAAK,CAAC,MAAM,EAAE,CAC9B;IAACC,IAAI,EAAE,SAAS;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC3C;IAACF,IAAI,EAAE,WAAW;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC7C;IAACF,IAAI,EAAE,YAAY;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC9C;IAACF,IAAI,EAAE,YAAY;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC9C;IAACF,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAE,OAAO;IAAEC,KAAK,EAAE;EAAE,CAAC,EAC1C;IAACF,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC1C;IAACF,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC1C;IAACF,IAAI,EAAE,UAAU;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC5C;IAACF,IAAI,EAAE,YAAY;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC9C;IAACF,IAAI,EAAE,aAAa;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EAC/C;IAACF,IAAI,EAAE,eAAe;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,EACjD;IAACF,IAAI,EAAE,YAAY;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,CACjD,CAAC;EAEFZ,CAAC,CAACE,QAAQ,GAAG,EAAE;EACf,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2C,MAAM,CAAChD,MAAM,EAAEK,CAAC,IAAI,CAAC,EAAE;IACvC,MAAMgD,KAAK,GAAGL,MAAM,CAACM,GAAG,CAACjD,CAAC,CAAC;IAC3B,KAAK,IAAIkD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACG,QAAQ,CAACxD,MAAM,EAAEuD,CAAC,IAAI,CAAC,EAAE;MAC/ChB,UAAU,CAACC,CAAC,EAAEa,KAAK,CAACG,QAAQ,CAACD,CAAC,CAAC,EAAElD,CAAC,CAAC;IACvC;IAEAmC,CAAC,CAACE,QAAQ,GAAGF,CAAC,CAACE,QAAQ,CAACe,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;MACxC,OAAOD,CAAC,CAAC9C,KAAK,GAAG+C,CAAC,CAAC/C,KAAK;IAC5B,CAAC,CAAC;EACN;EAEAkC,oBAAoB,CAACN,CAAC,CAAC;EAEvB,IAAI1B,QAAQ;EACZA,QAAQ,GAAG0B,CAAC,CAACE,QAAQ,CAAC1C,MAAM;EAC5BwC,CAAC,CAACoB,UAAU,GAAG9C,QAAQ,GAAG,CAAC;EAC3B0B,CAAC,CAACqB,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,KAAK,CAACF,IAAI,CAACG,GAAG,CAACnD,QAAQ,CAAC,GAAGgD,IAAI,CAACG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EAC7EzB,CAAC,CAAC0B,aAAa,GAAGJ,IAAI,CAACG,GAAG,CAACzB,CAAC,CAACqB,WAAW,GAAG,CAAC,CAAC,GAAGC,IAAI,CAACG,GAAG,CAAC,CAAC,CAAC;EAC3DzB,CAAC,CAAC2B,UAAU,GAAG3B,CAAC,CAACoB,UAAU,GAAGpB,CAAC,CAACqB,WAAW;;EAE3C;EACA,IAAIO,SAAS,GAAG,EAAE;EAClB,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,cAAc,GAAG,EAAE;EACvB,IAAIC,QAAQ,GAAG,EAAE;EAEjB,KAAK,IAAInE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,QAAQ,EAAET,CAAC,IAAI,CAAC,EAAE;IAClC,MAAMoE,OAAO,GAAGjC,CAAC,CAACE,QAAQ,CAACrC,CAAC,CAAC;IAC7B+D,SAAS,GAAGA,SAAS,CAACM,MAAM,CAAC;MAACxB,IAAI,EAAE,MAAM,GAAG7C,CAAC;MAAE8C,IAAI,EAAE,QAAQ;MAAEC,KAAK,EAAEqB,OAAO,CAAC7B;IAAG,CAAC,CAAC;IACpFyB,WAAW,GAAGA,WAAW,CAACK,MAAM,CAAC;MAACxB,IAAI,EAAE,QAAQ,GAAG7C,CAAC;MAAE8C,IAAI,EAAE,QAAQ;MAAEC,KAAK,EAAEqB,OAAO,CAAC7D;IAAK,CAAC,CAAC;IAC5F0D,QAAQ,GAAGA,QAAQ,CAACI,MAAM,CAAC;MAACxB,IAAI,EAAE,UAAU,GAAG7C,CAAC;MAAE8C,IAAI,EAAE,OAAO;MAAEC,KAAK,EAAEqB,OAAO,CAAC5B;IAAK,CAAC,CAAC;IACvF0B,cAAc,GAAGA,cAAc,CAACG,MAAM,CAAC;MAACxB,IAAI,EAAE,gBAAgB,GAAG7C,CAAC;MAAE8C,IAAI,EAAE,QAAQ;MAAEC,KAAK,EAAEqB,OAAO,CAAC5D;IAAM,CAAC,CAAC;IAC3G,IAAI4D,OAAO,CAACE,OAAO,KAAKC,SAAS,EAAE;MAC/BJ,QAAQ,GAAGA,QAAQ,CAACE,MAAM,CAAC;QAACxB,IAAI,EAAE,QAAQ,GAAG7C,CAAC;QAAE8C,IAAI,EAAE,QAAQ;QAAEC,KAAK,EAAEqB,OAAO,CAACE;MAAO,CAAC,CAAC;IAC5F;EACJ;EAEAnC,CAAC,CAACqC,MAAM,GAAGrC,CAAC,CAACqC,MAAM,CAACH,MAAM,CAACN,SAAS,CAAC;EACrC5B,CAAC,CAACqC,MAAM,CAAClC,IAAI,CAAC;IAACO,IAAI,EAAE,aAAa;IAAEC,IAAI,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAC,CAAC,CAAC;EAC9DZ,CAAC,CAACqC,MAAM,GAAGrC,CAAC,CAACqC,MAAM,CAACH,MAAM,CAACL,WAAW,CAAC;EACvC7B,CAAC,CAACqC,MAAM,GAAGrC,CAAC,CAACqC,MAAM,CAACH,MAAM,CAACJ,QAAQ,CAAC;EACpC9B,CAAC,CAACqC,MAAM,GAAGrC,CAAC,CAACqC,MAAM,CAACH,MAAM,CAACH,cAAc,CAAC;EAC1C/B,CAAC,CAACqC,MAAM,GAAGrC,CAAC,CAACqC,MAAM,CAACH,MAAM,CAACF,QAAQ,CAAC;EAEpChC,CAAC,CAACxC,MAAM,GAAG,EAAE;EAAG;EACZoE,SAAS,CAACpE,MAAM,GAAG,CAAC,GACpB,CAAC;EAAG;EACJqE,WAAW,CAACrE,MAAM,GAAG,CAAC,GACtBsE,QAAQ,CAACtE,MAAM,GAAG,CAAC,GACnBuE,cAAc,CAACvE,MAAM,GAAG,CAAC,GACzBwE,QAAQ,CAACxE,MAAM,GAAG,CAAC;EAEvB,OAAOwC,CAAC;AACZ;AAEA,eAAe;EAAE9C,KAAK,EAAEoC,cAAc;EAAEgD,IAAI,EAAE/B;AAAc,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}