{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Parsing utility functions\n\nimport check from './check';\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n  return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n  return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n  return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n  return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n  const decimal = dataView.getInt16(offset, false);\n  const fraction = dataView.getUint16(offset + 2, false);\n  return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n  let tag = '';\n  for (let i = offset; i < offset + 4; i += 1) {\n    tag += String.fromCharCode(dataView.getInt8(i));\n  }\n  return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n  let v = 0;\n  for (let i = 0; i < offSize; i += 1) {\n    v <<= 8;\n    v += dataView.getUint8(offset + i);\n  }\n  return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n  const bytes = [];\n  for (let i = startOffset; i < endOffset; i += 1) {\n    bytes.push(dataView.getUint8(i));\n  }\n  return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n  let s = '';\n  for (let i = 0; i < bytes.length; i += 1) {\n    s += String.fromCharCode(bytes[i]);\n  }\n  return s;\n}\nconst typeOffsets = {\n  byte: 1,\n  uShort: 2,\n  short: 2,\n  uLong: 4,\n  fixed: 4,\n  longDateTime: 8,\n  tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n  this.data = data;\n  this.offset = offset;\n  this.relativeOffset = 0;\n}\nParser.prototype.parseByte = function () {\n  const v = this.data.getUint8(this.offset + this.relativeOffset);\n  this.relativeOffset += 1;\n  return v;\n};\nParser.prototype.parseChar = function () {\n  const v = this.data.getInt8(this.offset + this.relativeOffset);\n  this.relativeOffset += 1;\n  return v;\n};\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\nParser.prototype.parseUShort = function () {\n  const v = this.data.getUint16(this.offset + this.relativeOffset);\n  this.relativeOffset += 2;\n  return v;\n};\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\nParser.prototype.parseShort = function () {\n  const v = this.data.getInt16(this.offset + this.relativeOffset);\n  this.relativeOffset += 2;\n  return v;\n};\nParser.prototype.parseF2Dot14 = function () {\n  const v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n  this.relativeOffset += 2;\n  return v;\n};\nParser.prototype.parseULong = function () {\n  const v = getULong(this.data, this.offset + this.relativeOffset);\n  this.relativeOffset += 4;\n  return v;\n};\nParser.prototype.parseFixed = function () {\n  const v = getFixed(this.data, this.offset + this.relativeOffset);\n  this.relativeOffset += 4;\n  return v;\n};\nParser.prototype.parseString = function (length) {\n  const dataView = this.data;\n  const offset = this.offset + this.relativeOffset;\n  let string = '';\n  this.relativeOffset += length;\n  for (let i = 0; i < length; i++) {\n    string += String.fromCharCode(dataView.getUint8(offset + i));\n  }\n  return string;\n};\nParser.prototype.parseTag = function () {\n  return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function () {\n  let v = getULong(this.data, this.offset + this.relativeOffset + 4);\n  // Subtract seconds between 01/01/1904 and 01/01/1970\n  // to convert Apple Mac timestamp to Standard Unix timestamp\n  v -= 2082844800;\n  this.relativeOffset += 8;\n  return v;\n};\nParser.prototype.parseVersion = function () {\n  const major = getUShort(this.data, this.offset + this.relativeOffset);\n\n  // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n  // This returns the correct number if minor = 0xN000 where N is 0-9\n  const minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n  this.relativeOffset += 4;\n  return major + minor / 0x1000 / 10;\n};\nParser.prototype.skip = function (type, amount) {\n  if (amount === undefined) {\n    amount = 1;\n  }\n  this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function (count) {\n  if (count === undefined) {\n    count = this.parseUShort();\n  }\n  const offsets = new Array(count);\n  const dataView = this.data;\n  let offset = this.offset + this.relativeOffset;\n  for (let i = 0; i < count; i++) {\n    offsets[i] = dataView.getUint16(offset);\n    offset += 2;\n  }\n  this.relativeOffset += count * 2;\n  return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function (count) {\n  const list = new Array(count);\n  const dataView = this.data;\n  let offset = this.offset + this.relativeOffset;\n  for (let i = 0; i < count; i++) {\n    list[i] = dataView.getInt16(offset);\n    offset += 2;\n  }\n  this.relativeOffset += count * 2;\n  return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function (count) {\n  const list = new Array(count);\n  const dataView = this.data;\n  let offset = this.offset + this.relativeOffset;\n  for (let i = 0; i < count; i++) {\n    list[i] = dataView.getUint8(offset++);\n  }\n  this.relativeOffset += count;\n  return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function (count, itemCallback) {\n  if (!itemCallback) {\n    itemCallback = count;\n    count = this.parseUShort();\n  }\n  const list = new Array(count);\n  for (let i = 0; i < count; i++) {\n    list[i] = itemCallback.call(this);\n  }\n  return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function (count, recordDescription) {\n  // If the count argument is absent, read it in the stream.\n  if (!recordDescription) {\n    recordDescription = count;\n    count = this.parseUShort();\n  }\n  const records = new Array(count);\n  const fields = Object.keys(recordDescription);\n  for (let i = 0; i < count; i++) {\n    const rec = {};\n    for (let j = 0; j < fields.length; j++) {\n      const fieldName = fields[j];\n      const fieldType = recordDescription[fieldName];\n      rec[fieldName] = fieldType.call(this);\n    }\n    records[i] = rec;\n  }\n  return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function (description) {\n  if (typeof description === 'function') {\n    return description.call(this);\n  } else {\n    const fields = Object.keys(description);\n    const struct = {};\n    for (let j = 0; j < fields.length; j++) {\n      const fieldName = fields[j];\n      const fieldType = description[fieldName];\n      struct[fieldName] = fieldType.call(this);\n    }\n    return struct;\n  }\n};\nParser.prototype.parsePointer = function (description) {\n  const structOffset = this.parseOffset16();\n  if (structOffset > 0) {\n    // NULL offset => return undefined\n    return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n  }\n  return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function (itemCallback) {\n  const offsets = this.parseOffset16List();\n  const count = offsets.length;\n  const relativeOffset = this.relativeOffset;\n  const list = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const start = offsets[i];\n    if (start === 0) {\n      // NULL offset\n      list[i] = undefined; // Add i as owned property to list. Convenient with assert.\n      continue;\n    }\n    this.relativeOffset = start;\n    if (itemCallback) {\n      const subOffsets = this.parseOffset16List();\n      const subList = new Array(subOffsets.length);\n      for (let j = 0; j < subOffsets.length; j++) {\n        this.relativeOffset = start + subOffsets[j];\n        subList[j] = itemCallback.call(this);\n      }\n      list[i] = subList;\n    } else {\n      list[i] = this.parseUShortList();\n    }\n  }\n  this.relativeOffset = relativeOffset;\n  return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function () {\n  const startOffset = this.offset + this.relativeOffset;\n  const format = this.parseUShort();\n  const count = this.parseUShort();\n  if (format === 1) {\n    return {\n      format: 1,\n      glyphs: this.parseUShortList(count)\n    };\n  } else if (format === 2) {\n    const ranges = new Array(count);\n    for (let i = 0; i < count; i++) {\n      ranges[i] = {\n        start: this.parseUShort(),\n        end: this.parseUShort(),\n        index: this.parseUShort()\n      };\n    }\n    return {\n      format: 2,\n      ranges: ranges\n    };\n  }\n  throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function () {\n  const startOffset = this.offset + this.relativeOffset;\n  const format = this.parseUShort();\n  if (format === 1) {\n    return {\n      format: 1,\n      startGlyph: this.parseUShort(),\n      classes: this.parseUShortList()\n    };\n  } else if (format === 2) {\n    return {\n      format: 2,\n      ranges: this.parseRecordList({\n        start: Parser.uShort,\n        end: Parser.uShort,\n        classId: Parser.uShort\n      })\n    };\n  }\n  throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function (count, itemCallback) {\n  return function () {\n    return this.parseList(count, itemCallback);\n  };\n};\nParser.recordList = function (count, recordDescription) {\n  return function () {\n    return this.parseRecordList(count, recordDescription);\n  };\n};\nParser.pointer = function (description) {\n  return function () {\n    return this.parsePointer(description);\n  };\n};\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nconst langSysTable = {\n  reserved: Parser.uShort,\n  reqFeatureIndex: Parser.uShort,\n  featureIndexes: Parser.uShortList\n};\nParser.prototype.parseScriptList = function () {\n  return this.parsePointer(Parser.recordList({\n    tag: Parser.tag,\n    script: Parser.pointer({\n      defaultLangSys: Parser.pointer(langSysTable),\n      langSysRecords: Parser.recordList({\n        tag: Parser.tag,\n        langSys: Parser.pointer(langSysTable)\n      })\n    })\n  }));\n};\nParser.prototype.parseFeatureList = function () {\n  return this.parsePointer(Parser.recordList({\n    tag: Parser.tag,\n    feature: Parser.pointer({\n      featureParams: Parser.offset16,\n      lookupListIndexes: Parser.uShortList\n    })\n  }));\n};\nParser.prototype.parseLookupList = function (lookupTableParsers) {\n  return this.parsePointer(Parser.list(Parser.pointer(function () {\n    const lookupType = this.parseUShort();\n    check.argument(1 <= lookupType && lookupType <= 8, 'GSUB lookup type ' + lookupType + ' unknown.');\n    const lookupFlag = this.parseUShort();\n    const useMarkFilteringSet = lookupFlag & 0x10;\n    return {\n      lookupType: lookupType,\n      lookupFlag: lookupFlag,\n      subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n      markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n    };\n  })));\n};\nexport default {\n  getByte,\n  getCard8: getByte,\n  getUShort,\n  getCard16: getUShort,\n  getShort,\n  getULong,\n  getFixed,\n  getTag,\n  getOffset,\n  getBytes,\n  bytesToString,\n  Parser\n};\nexport { Parser };","map":{"version":3,"names":["check","getByte","dataView","offset","getUint8","getUShort","getUint16","getShort","getInt16","getULong","getUint32","getFixed","decimal","fraction","getTag","tag","i","String","fromCharCode","getInt8","getOffset","offSize","v","getBytes","startOffset","endOffset","bytes","push","bytesToString","s","length","typeOffsets","byte","uShort","short","uLong","fixed","longDateTime","Parser","data","relativeOffset","prototype","parseByte","parseChar","parseCard8","parseUShort","parseCard16","parseSID","parseOffset16","parseShort","parseF2Dot14","parseULong","parseFixed","parseString","string","parseTag","parseLongDateTime","parseVersion","major","minor","skip","type","amount","undefined","parseOffset16List","parseUShortList","count","offsets","Array","parseShortList","list","parseByteList","parseList","itemCallback","call","parseRecordList","recordDescription","records","fields","Object","keys","rec","j","fieldName","fieldType","parseStruct","description","struct","parsePointer","structOffset","parseListOfLists","start","subOffsets","subList","parseCoverage","format","glyphs","ranges","end","index","Error","toString","parseClassDef","startGlyph","classes","classId","recordList","pointer","offset16","uShortList","coverage","classDef","langSysTable","reserved","reqFeatureIndex","featureIndexes","parseScriptList","script","defaultLangSys","langSysRecords","langSys","parseFeatureList","feature","featureParams","lookupListIndexes","parseLookupList","lookupTableParsers","lookupType","argument","lookupFlag","useMarkFilteringSet","subtables","markFilteringSet","getCard8","getCard16"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/_opentype.js@0.7.3@opentype.js/src/parse.js"],"sourcesContent":["// Parsing utility functions\n\nimport check from './check';\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    const decimal = dataView.getInt16(offset, false);\n    const fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    let tag = '';\n    for (let i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    let v = 0;\n    for (let i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    const bytes = [];\n    for (let i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    let s = '';\n    for (let i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nconst typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    const v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    const v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    const v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    const v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    const v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    const v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseFixed = function() {\n    const v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    const dataView = this.data;\n    const offset = this.offset + this.relativeOffset;\n    let string = '';\n    this.relativeOffset += length;\n    for (let i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    let v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function() {\n    const major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // This returns the correct number if minor = 0xN000 where N is 0-9\n    const minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    return major + minor / 0x1000 / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    const offsets = new Array(count);\n    const dataView = this.data;\n    let offset = this.offset + this.relativeOffset;\n    for (let i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    const list = new Array(count);\n    const dataView = this.data;\n    let offset = this.offset + this.relativeOffset;\n    for (let i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    const list = new Array(count);\n    const dataView = this.data;\n    let offset = this.offset + this.relativeOffset;\n    for (let i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    const list = new Array(count);\n    for (let i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    const records = new Array(count);\n    const fields = Object.keys(recordDescription);\n    for (let i = 0; i < count; i++) {\n        const rec = {};\n        for (let j = 0; j < fields.length; j++) {\n            const fieldName = fields[j];\n            const fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        const fields = Object.keys(description);\n        const struct = {};\n        for (let j = 0; j < fields.length; j++) {\n            const fieldName = fields[j];\n            const fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\nParser.prototype.parsePointer = function(description) {\n    const structOffset = this.parseOffset16();\n    if (structOffset > 0) {                         // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    const offsets = this.parseOffset16List();\n    const count = offsets.length;\n    const relativeOffset = this.relativeOffset;\n    const list = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const start = offsets[i];\n        if (start === 0) {                  // NULL offset\n            list[i] = undefined;            // Add i as owned property to list. Convenient with assert.\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            const subOffsets = this.parseOffset16List();\n            const subList = new Array(subOffsets.length);\n            for (let j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    const startOffset = this.offset + this.relativeOffset;\n    const format = this.parseUShort();\n    const count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        const ranges = new Array(count);\n        for (let i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    const startOffset = this.offset + this.relativeOffset;\n    const format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nconst langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    }));\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    }));\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        const lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 8, 'GSUB lookup type ' + lookupType + ' unknown.');\n        const lookupFlag = this.parseUShort();\n        const useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    })));\n};\n\nexport default {\n    getByte,\n    getCard8: getByte,\n    getUShort,\n    getCard16: getUShort,\n    getShort,\n    getULong,\n    getFixed,\n    getTag,\n    getOffset,\n    getBytes,\n    bytesToString,\n    Parser,\n};\n\nexport { Parser };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}