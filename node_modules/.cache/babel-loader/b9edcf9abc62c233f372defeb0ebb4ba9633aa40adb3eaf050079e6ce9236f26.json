{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\n// opentype.js\n// https://github.com/nodebox/opentype.js\n// (c) 2015 Frederik De Bleser\n// opentype.js may be freely distributed under the MIT license.\n\n/* global DataView, Uint8Array, XMLHttpRequest  */\n\nimport inflate from 'tiny-inflate';\nimport Font from './font';\nimport Glyph from './glyph';\nimport { CmapEncoding, GlyphNames, addGlyphNames } from './encoding';\nimport parse from './parse';\nimport BoundingBox from './bbox';\nimport Path from './path';\nimport { nodeBufferToArrayBuffer } from './util';\nimport cmap from './tables/cmap';\nimport cff from './tables/cff';\nimport fvar from './tables/fvar';\nimport glyf from './tables/glyf';\nimport gpos from './tables/gpos';\nimport gsub from './tables/gsub';\nimport head from './tables/head';\nimport hhea from './tables/hhea';\nimport hmtx from './tables/hmtx';\nimport kern from './tables/kern';\nimport ltag from './tables/ltag';\nimport loca from './tables/loca';\nimport maxp from './tables/maxp';\nimport _name from './tables/name';\nimport os2 from './tables/os2';\nimport post from './tables/post';\nimport meta from './tables/meta';\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n  const fs = require('fs');\n  fs.readFile(path, function (err, buffer) {\n    if (err) {\n      return callback(err.message);\n    }\n    callback(null, nodeBufferToArrayBuffer(buffer));\n  });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n  const request = new XMLHttpRequest();\n  request.open('get', url, true);\n  request.responseType = 'arraybuffer';\n  request.onload = function () {\n    if (request.status !== 200) {\n      return callback('Font could not be loaded: ' + request.statusText);\n    }\n    return callback(null, request.response);\n  };\n  request.onerror = function () {\n    callback('Font could not be loaded');\n  };\n  request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n  const tableEntries = [];\n  let p = 12;\n  for (let i = 0; i < numTables; i += 1) {\n    const tag = parse.getTag(data, p);\n    const checksum = parse.getULong(data, p + 4);\n    const offset = parse.getULong(data, p + 8);\n    const length = parse.getULong(data, p + 12);\n    tableEntries.push({\n      tag: tag,\n      checksum: checksum,\n      offset: offset,\n      length: length,\n      compression: false\n    });\n    p += 16;\n  }\n  return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n  const tableEntries = [];\n  let p = 44; // offset to the first table directory entry.\n  for (let i = 0; i < numTables; i += 1) {\n    const tag = parse.getTag(data, p);\n    const offset = parse.getULong(data, p + 4);\n    const compLength = parse.getULong(data, p + 8);\n    const origLength = parse.getULong(data, p + 12);\n    let compression;\n    if (compLength < origLength) {\n      compression = 'WOFF';\n    } else {\n      compression = false;\n    }\n    tableEntries.push({\n      tag: tag,\n      offset: offset,\n      compression: compression,\n      compressedLength: compLength,\n      length: origLength\n    });\n    p += 20;\n  }\n  return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n  if (tableEntry.compression === 'WOFF') {\n    const inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n    const outBuffer = new Uint8Array(tableEntry.length);\n    inflate(inBuffer, outBuffer);\n    if (outBuffer.byteLength !== tableEntry.length) {\n      throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n    }\n    const view = new DataView(outBuffer.buffer, 0);\n    return {\n      data: view,\n      offset: 0\n    };\n  } else {\n    return {\n      data: data,\n      offset: tableEntry.offset\n    };\n  }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer) {\n  let indexToLocFormat;\n  let ltagTable;\n\n  // Since the constructor can also be called to create new fonts from scratch, we indicate this\n  // should be an empty font that we'll fill with our own data.\n  const font = new Font({\n    empty: true\n  });\n\n  // OpenType fonts use big endian byte ordering.\n  // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n  // Instead we use DataViews where we can specify endianness.\n  const data = new DataView(buffer, 0);\n  let numTables;\n  let tableEntries = [];\n  const signature = parse.getTag(data, 0);\n  if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n    font.outlinesFormat = 'truetype';\n    numTables = parse.getUShort(data, 4);\n    tableEntries = parseOpenTypeTableEntries(data, numTables);\n  } else if (signature === 'OTTO') {\n    font.outlinesFormat = 'cff';\n    numTables = parse.getUShort(data, 4);\n    tableEntries = parseOpenTypeTableEntries(data, numTables);\n  } else if (signature === 'wOFF') {\n    const flavor = parse.getTag(data, 4);\n    if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n      font.outlinesFormat = 'truetype';\n    } else if (flavor === 'OTTO') {\n      font.outlinesFormat = 'cff';\n    } else {\n      throw new Error('Unsupported OpenType flavor ' + signature);\n    }\n    numTables = parse.getUShort(data, 12);\n    tableEntries = parseWOFFTableEntries(data, numTables);\n  } else {\n    throw new Error('Unsupported OpenType signature ' + signature);\n  }\n  let cffTableEntry;\n  let fvarTableEntry;\n  let glyfTableEntry;\n  let gposTableEntry;\n  let gsubTableEntry;\n  let hmtxTableEntry;\n  let kernTableEntry;\n  let locaTableEntry;\n  let nameTableEntry;\n  let metaTableEntry;\n  let p;\n  for (let i = 0; i < numTables; i += 1) {\n    const tableEntry = tableEntries[i];\n    let table;\n    switch (tableEntry.tag) {\n      case 'cmap':\n        table = uncompressTable(data, tableEntry);\n        font.tables.cmap = cmap.parse(table.data, table.offset);\n        font.encoding = new CmapEncoding(font.tables.cmap);\n        break;\n      case 'cvt ':\n        table = uncompressTable(data, tableEntry);\n        p = new parse.Parser(table.data, table.offset);\n        font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n        break;\n      case 'fvar':\n        fvarTableEntry = tableEntry;\n        break;\n      case 'fpgm':\n        table = uncompressTable(data, tableEntry);\n        p = new parse.Parser(table.data, table.offset);\n        font.tables.fpgm = p.parseByteList(tableEntry.length);\n        break;\n      case 'head':\n        table = uncompressTable(data, tableEntry);\n        font.tables.head = head.parse(table.data, table.offset);\n        font.unitsPerEm = font.tables.head.unitsPerEm;\n        indexToLocFormat = font.tables.head.indexToLocFormat;\n        break;\n      case 'hhea':\n        table = uncompressTable(data, tableEntry);\n        font.tables.hhea = hhea.parse(table.data, table.offset);\n        font.ascender = font.tables.hhea.ascender;\n        font.descender = font.tables.hhea.descender;\n        font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n        break;\n      case 'hmtx':\n        hmtxTableEntry = tableEntry;\n        break;\n      case 'ltag':\n        table = uncompressTable(data, tableEntry);\n        ltagTable = ltag.parse(table.data, table.offset);\n        break;\n      case 'maxp':\n        table = uncompressTable(data, tableEntry);\n        font.tables.maxp = maxp.parse(table.data, table.offset);\n        font.numGlyphs = font.tables.maxp.numGlyphs;\n        break;\n      case 'name':\n        nameTableEntry = tableEntry;\n        break;\n      case 'OS/2':\n        table = uncompressTable(data, tableEntry);\n        font.tables.os2 = os2.parse(table.data, table.offset);\n        break;\n      case 'post':\n        table = uncompressTable(data, tableEntry);\n        font.tables.post = post.parse(table.data, table.offset);\n        font.glyphNames = new GlyphNames(font.tables.post);\n        break;\n      case 'prep':\n        table = uncompressTable(data, tableEntry);\n        p = new parse.Parser(table.data, table.offset);\n        font.tables.prep = p.parseByteList(tableEntry.length);\n        break;\n      case 'glyf':\n        glyfTableEntry = tableEntry;\n        break;\n      case 'loca':\n        locaTableEntry = tableEntry;\n        break;\n      case 'CFF ':\n        cffTableEntry = tableEntry;\n        break;\n      case 'kern':\n        kernTableEntry = tableEntry;\n        break;\n      case 'GPOS':\n        gposTableEntry = tableEntry;\n        break;\n      case 'GSUB':\n        gsubTableEntry = tableEntry;\n        break;\n      case 'meta':\n        metaTableEntry = tableEntry;\n        break;\n    }\n  }\n  const nameTable = uncompressTable(data, nameTableEntry);\n  font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n  font.names = font.tables.name;\n  if (glyfTableEntry && locaTableEntry) {\n    const shortVersion = indexToLocFormat === 0;\n    const locaTable = uncompressTable(data, locaTableEntry);\n    const locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n    const glyfTable = uncompressTable(data, glyfTableEntry);\n    font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);\n  } else if (cffTableEntry) {\n    const cffTable = uncompressTable(data, cffTableEntry);\n    cff.parse(cffTable.data, cffTable.offset, font);\n  } else {\n    throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n  }\n  const hmtxTable = uncompressTable(data, hmtxTableEntry);\n  hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);\n  addGlyphNames(font);\n  if (kernTableEntry) {\n    const kernTable = uncompressTable(data, kernTableEntry);\n    font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n  } else {\n    font.kerningPairs = {};\n  }\n  if (gposTableEntry) {\n    const gposTable = uncompressTable(data, gposTableEntry);\n    gpos.parse(gposTable.data, gposTable.offset, font);\n  }\n  if (gsubTableEntry) {\n    const gsubTable = uncompressTable(data, gsubTableEntry);\n    font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n  }\n  if (fvarTableEntry) {\n    const fvarTable = uncompressTable(data, fvarTableEntry);\n    font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n  }\n  if (metaTableEntry) {\n    const metaTable = uncompressTable(data, metaTableEntry);\n    font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n    font.metas = font.tables.meta;\n  }\n  return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback) {\n  const isNode = typeof window === 'undefined';\n  const loadFn = isNode ? loadFromFile : loadFromUrl;\n  loadFn(url, function (err, arrayBuffer) {\n    if (err) {\n      return callback(err);\n    }\n    let font;\n    try {\n      font = parseBuffer(arrayBuffer);\n    } catch (e) {\n      return callback(e, null);\n    }\n    return callback(null, font);\n  });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @return {opentype.Font}\n */\nfunction loadSync(url) {\n  const fs = require('fs');\n  const buffer = fs.readFileSync(url);\n  return parseBuffer(nodeBufferToArrayBuffer(buffer));\n}\nexport { Font, Glyph, Path, BoundingBox, parse as _parse, parseBuffer as parse, load, loadSync };","map":{"version":3,"names":["inflate","Font","Glyph","CmapEncoding","GlyphNames","addGlyphNames","parse","BoundingBox","Path","nodeBufferToArrayBuffer","cmap","cff","fvar","glyf","gpos","gsub","head","hhea","hmtx","kern","ltag","loca","maxp","_name","os2","post","meta","loadFromFile","path","callback","fs","require","readFile","err","buffer","message","loadFromUrl","url","request","XMLHttpRequest","open","responseType","onload","status","statusText","response","onerror","send","parseOpenTypeTableEntries","data","numTables","tableEntries","p","i","tag","getTag","checksum","getULong","offset","length","push","compression","parseWOFFTableEntries","compLength","origLength","compressedLength","uncompressTable","tableEntry","inBuffer","Uint8Array","outBuffer","byteLength","Error","view","DataView","parseBuffer","indexToLocFormat","ltagTable","font","empty","signature","String","fromCharCode","outlinesFormat","getUShort","flavor","cffTableEntry","fvarTableEntry","glyfTableEntry","gposTableEntry","gsubTableEntry","hmtxTableEntry","kernTableEntry","locaTableEntry","nameTableEntry","metaTableEntry","table","tables","encoding","Parser","cvt","parseShortList","fpgm","parseByteList","unitsPerEm","ascender","descender","numberOfHMetrics","numGlyphs","glyphNames","prep","nameTable","name","names","shortVersion","locaTable","locaOffsets","glyfTable","glyphs","cffTable","hmtxTable","kernTable","kerningPairs","gposTable","gsubTable","fvarTable","metaTable","metas","load","isNode","window","loadFn","arrayBuffer","e","loadSync","readFileSync","_parse"],"sources":["C:/Users/14486/Desktop/社区公益系统前端/vue_community/node_modules/opentype.js/src/opentype.js"],"sourcesContent":["// opentype.js\n// https://github.com/nodebox/opentype.js\n// (c) 2015 Frederik De Bleser\n// opentype.js may be freely distributed under the MIT license.\n\n/* global DataView, Uint8Array, XMLHttpRequest  */\n\nimport inflate from 'tiny-inflate';\nimport Font from './font';\nimport Glyph from './glyph';\nimport { CmapEncoding, GlyphNames, addGlyphNames } from './encoding';\nimport parse from './parse';\nimport BoundingBox from './bbox';\nimport Path from './path';\nimport { nodeBufferToArrayBuffer } from './util';\nimport cmap from './tables/cmap';\nimport cff from './tables/cff';\nimport fvar from './tables/fvar';\nimport glyf from './tables/glyf';\nimport gpos from './tables/gpos';\nimport gsub from './tables/gsub';\nimport head from './tables/head';\nimport hhea from './tables/hhea';\nimport hmtx from './tables/hmtx';\nimport kern from './tables/kern';\nimport ltag from './tables/ltag';\nimport loca from './tables/loca';\nimport maxp from './tables/maxp';\nimport _name from './tables/name';\nimport os2 from './tables/os2';\nimport post from './tables/post';\nimport meta from './tables/meta';\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n    const fs = require('fs');\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, nodeBufferToArrayBuffer(buffer));\n    });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n    const request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.status !== 200) {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n\n        return callback(null, request.response);\n    };\n\n    request.onerror = function () {\n        callback('Font could not be loaded');\n    };\n\n    request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    const tableEntries = [];\n    let p = 12;\n    for (let i = 0; i < numTables; i += 1) {\n        const tag = parse.getTag(data, p);\n        const checksum = parse.getULong(data, p + 4);\n        const offset = parse.getULong(data, p + 8);\n        const length = parse.getULong(data, p + 12);\n        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    const tableEntries = [];\n    let p = 44; // offset to the first table directory entry.\n    for (let i = 0; i < numTables; i += 1) {\n        const tag = parse.getTag(data, p);\n        const offset = parse.getULong(data, p + 4);\n        const compLength = parse.getULong(data, p + 8);\n        const origLength = parse.getULong(data, p + 12);\n        let compression;\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({tag: tag, offset: offset, compression: compression,\n            compressedLength: compLength, length: origLength});\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        const inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        const outBuffer = new Uint8Array(tableEntry.length);\n        inflate(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n        }\n\n        const view = new DataView(outBuffer.buffer, 0);\n        return {data: view, offset: 0};\n    } else {\n        return {data: data, offset: tableEntry.offset};\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer) {\n    let indexToLocFormat;\n    let ltagTable;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    const font = new Font({empty: true});\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    const data = new DataView(buffer, 0);\n    let numTables;\n    let tableEntries = [];\n    const signature = parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        const flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    let cffTableEntry;\n    let fvarTableEntry;\n    let glyfTableEntry;\n    let gposTableEntry;\n    let gsubTableEntry;\n    let hmtxTableEntry;\n    let kernTableEntry;\n    let locaTableEntry;\n    let nameTableEntry;\n    let metaTableEntry;\n    let p;\n\n    for (let i = 0; i < numTables; i += 1) {\n        const tableEntry = tableEntries[i];\n        let table;\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'name':\n                nameTableEntry = tableEntry;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                font.glyphNames = new GlyphNames(font.tables.post);\n                break;\n            case 'prep' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    const nameTable = uncompressTable(data, nameTableEntry);\n    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n    font.names = font.tables.name;\n\n    if (glyfTableEntry && locaTableEntry) {\n        const shortVersion = indexToLocFormat === 0;\n        const locaTable = uncompressTable(data, locaTableEntry);\n        const locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        const glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);\n    } else if (cffTableEntry) {\n        const cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    const hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);\n    addGlyphNames(font);\n\n    if (kernTableEntry) {\n        const kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gposTableEntry) {\n        const gposTable = uncompressTable(data, gposTableEntry);\n        gpos.parse(gposTable.data, gposTable.offset, font);\n    }\n\n    if (gsubTableEntry) {\n        const gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        const fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n\n    if (metaTableEntry) {\n        const metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback) {\n    const isNode = typeof window === 'undefined';\n    const loadFn = isNode ? loadFromFile : loadFromUrl;\n    loadFn(url, function(err, arrayBuffer) {\n        if (err) {\n            return callback(err);\n        }\n        let font;\n        try {\n            font = parseBuffer(arrayBuffer);\n        } catch (e) {\n            return callback(e, null);\n        }\n        return callback(null, font);\n    });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @return {opentype.Font}\n */\nfunction loadSync(url) {\n    const fs = require('fs');\n    const buffer = fs.readFileSync(url);\n    return parseBuffer(nodeBufferToArrayBuffer(buffer));\n}\n\nexport {\n    Font,\n    Glyph,\n    Path,\n    BoundingBox,\n    parse as _parse,\n    parseBuffer as parse,\n    load,\n    loadSync\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}